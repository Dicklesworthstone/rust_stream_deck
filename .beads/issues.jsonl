{"id":"bd-10c","title":"Add --exec, --on-press, --on-release flags to CLI","description":"Add to Watch command in src/cli/mod.rs:\n- --exec <CMD>: Command for any key event ({key} substituted)\n- --on-press <CMD>: Command for press events only\n- --on-release <CMD>: Command for release events only\n- --exec-timeout <MS>: Timeout for command execution (default: 5000)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.286502630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.315959421Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10c","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.315913896Z","created_by":"ubuntu"}]}
{"id":"bd-10v","title":"Add --no-open flag to serve","description":"By default, open browser to http://localhost:PORT\nWith --no-open, just print URL and dont open browser.\n\nUseful for headless/server scenarios.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.079956565Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:51.093955392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10v","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.093899026Z","created_by":"ubuntu"}]}
{"id":"bd-117","title":"Implement diff-based apply","description":"Only apply changes:\n1. Track previous ConfigState\n2. Load new config\n3. Compute diff (changed keys, brightness)\n4. Apply only changed items\n5. Update tracked state\n\nMore efficient than full re-apply.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.675738818Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.688270112Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-117","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.688223104Z","created_by":"ubuntu"}]}
{"id":"bd-11p","title":"Build frontend JavaScript logic","description":"Create static/app.js:\n- Fetch and display device info\n- Handle image drag-and-drop\n- Brightness slider updates\n- WebSocket for live events\n- Color picker integration","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:48.733315351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:48.749847778Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-11p","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:48.749796221Z","created_by":"ubuntu"}]}
{"id":"bd-123","title":"Test with various editors","description":"Manual testing:\n- VSCode (may write temp files)\n- Vim (backup then write)\n- nano (direct write)\n- sed -i (replace)\n\nEnsure debouncing handles each pattern.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.860516467Z","created_by":"ubuntu","updated_at":"2026-01-19T18:39:15.190193039Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-123","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:15.190158744Z","created_by":"ubuntu"},{"issue_id":"bd-123","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.870801802Z","created_by":"ubuntu"}]}
{"id":"bd-13e","title":"Add font rendering dependencies","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nab_glyph = \"0.2\"      # Modern font rendering\nimageproc = \"0.23\"    # Drawing on images\n```\n\nab_glyph is preferred over rusttype for better performance.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:13.794603556Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:13.823919262Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-13e","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:13.823857295Z","created_by":"ubuntu"}]}
{"id":"bd-156","title":"EPIC: Scripting Hooks on Key Press","description":"## Overview\n**Rank: #8 of 15** | **Impact: High** | **Effort: Low** | **Confidence: Medium-High**\n\nRun shell commands when Stream Deck buttons are pressed, making the device an automation trigger.\n\n## Problem Statement\nCurrently `sd watch` just reports button events to stdout. Users must:\n- Parse the JSON output in another script\n- Build their own event loop\n- Handle the complexity of process management\n\nThis makes the device a passive reporter rather than an active automation tool.\n\n## Solution\nExecute shell commands directly on key press:\n```bash\n# Simple: run a script per key\nsd watch --exec \"~/scripts/key-{key}.sh\"\n\n# Inline command with key substitution\nsd watch --on-press \"notify-send \\\"Key {key} pressed\\\"\"\n\n# Different commands for press vs release\nsd watch \\\n  --on-press \"echo pressed {key}\" \\\n  --on-release \"echo released {key}\"\n\n# With a command map file\nsd watch --keymap ~/keymap.yaml\n```\n\nKeymap file format:\n```yaml\n# ~/keymap.yaml\nkeys:\n  0:\n    press: open -a \"Google Chrome\"\n    release: null  # Optional\n  1:\n    press: osascript -e \"tell application \\\"Spotify\\\" to playpause\"\n  2:\n    press: ~/scripts/toggle-mic.sh\n  \n  # Range with pattern\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\n## Why This Is #8 Priority\n1. **Makes device useful**: Transforms from reporter to automation trigger\n2. **Unix philosophy**: Compose with existing tools, dont reinvent\n3. **Agent-friendly**: AI agents can wire up arbitrary actions\n4. **Low implementation effort**: Fork/exec in watch loop is straightforward\n5. **Immediate value**: Users can automate without writing custom code\n\n## Implementation Approach\n\n### Phase 1: Simple --exec Flag\n```rust\n// In src/cli/mod.rs\nWatch {\n    /// Command to execute on key press ({key} = key index)\n    #[arg(long)]\n    exec: Option<String>,\n    \n    /// Command for press events\n    #[arg(long)]\n    on_press: Option<String>,\n    \n    /// Command for release events  \n    #[arg(long)]\n    on_release: Option<String>,\n    \n    /// Keymap configuration file\n    #[arg(long)]\n    keymap: Option<PathBuf>,\n    \n    /// Timeout for command execution (ms)\n    #[arg(long, default_value = \"5000\")]\n    exec_timeout: u64,\n    \n    // ... existing flags\n}\n\n// In main.rs\nfn cmd_watch(device: &Device, opts: WatchOptions) -> Result<()> {\n    loop {\n        if let Some(event) = device.read_input(opts.timeout)? {\n            // Always emit the event (for robot mode consumers)\n            emit_event(&event, opts.robot);\n            \n            // Execute hooks if configured\n            if let Some(cmd) = resolve_command(&opts, &event) {\n                execute_hook(&cmd, opts.exec_timeout)?;\n            }\n        }\n    }\n}\n\nfn resolve_command(opts: &WatchOptions, event: &KeyEvent) -> Option<String> {\n    // Priority: keymap > on_press/on_release > exec\n    if let Some(keymap) = &opts.keymap {\n        return keymap.get_command(event.key, event.pressed);\n    }\n    \n    let template = match event.pressed {\n        true => opts.on_press.as_ref().or(opts.exec.as_ref()),\n        false => opts.on_release.as_ref(),\n    };\n    \n    template.map(|t| t.replace(\"{key}\", &event.key.to_string()))\n}\n\nfn execute_hook(cmd: &str, timeout_ms: u64) -> Result<()> {\n    use std::process::Command;\n    \n    let child = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .spawn()?;\n    \n    // Non-blocking: dont wait for completion\n    // Or with timeout if configured\n    Ok(())\n}\n```\n\n### Phase 2: Keymap File Support\n```rust\n// In src/config/keymap.rs (new file)\n#[derive(Debug, Deserialize)]\npub struct Keymap {\n    pub keys: HashMap<KeySelector, KeyActions>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct KeyActions {\n    pub press: Option<String>,\n    pub release: Option<String>,\n}\n\nimpl Keymap {\n    pub fn load(path: &Path) -> Result<Self> {\n        let content = std::fs::read_to_string(path)?;\n        Ok(serde_yaml::from_str(&content)?)\n    }\n    \n    pub fn get_command(&self, key: u8, pressed: bool) -> Option<String> {\n        for (selector, actions) in &self.keys {\n            if selector.matches(key) {\n                let template = if pressed { &actions.press } else { &actions.release };\n                return template.as_ref().map(|t| \n                    t.replace(\"{key}\", &key.to_string())\n                );\n            }\n        }\n        None\n    }\n}\n```\n\n## Security Considerations\n1. **No shell injection from device**: Key index is always a number\n2. **User-provided commands only**: We execute what the user configured\n3. **Timeout protection**: Prevent runaway commands\n4. **Non-blocking execution**: Dont block the event loop on slow commands\n5. **Error isolation**: Command failure doesnt crash watch mode\n\n## Key Design Decisions\n1. **Shell execution via sh -c**: Allows pipes, redirects, etc.\n2. **Non-blocking by default**: Fire-and-forget for responsiveness\n3. **{key} substitution**: Simple, predictable placeholder\n4. **Keymap file optional**: Simple use cases dont need files\n5. **Press/release separation**: Different actions for different events\n\n## Robot Mode Integration\n```json\n// Events include hook execution status\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"timestamp\": \"...\",\n  \"hook\": {\n    \"command\": \"~/scripts/key-05.sh\",\n    \"status\": \"started\",\n    \"pid\": 12345\n  }\n}\n\n// Optionally report completion\n{\n  \"event\": \"hook_completed\",\n  \"key\": 5,\n  \"pid\": 12345,\n  \"exit_code\": 0,\n  \"duration_ms\": 150\n}\n```\n\n## Success Criteria\n- [ ] `--exec` flag runs command on any key press\n- [ ] `--on-press` and `--on-release` for event-specific commands\n- [ ] `{key}` placeholder substituted correctly\n- [ ] `--keymap` loads YAML keymap file\n- [ ] Commands execute non-blocking\n- [ ] Timeout prevents runaway commands\n- [ ] Robot mode reports hook execution\n- [ ] Command errors dont crash watch mode\n\n## Files to Create/Modify\n- `src/cli/mod.rs`: Add exec flags to Watch command\n- `src/main.rs`: Implement hook execution in watch loop\n- `src/config/keymap.rs`: New keymap file support\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for keymap schema consistency\n\n## Estimated Subtasks\n1. Add --exec, --on-press, --on-release flags to CLI\n2. Implement command template substitution\n3. Implement non-blocking command execution\n4. Add timeout support for commands\n5. Implement keymap file loading\n6. Integrate hook execution into watch loop\n7. Add robot mode hook status reporting\n8. Handle command errors gracefully\n9. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:18:49.274948425Z","created_by":"ubuntu","updated_at":"2026-01-19T18:18:49.313818630Z","compaction_level":0,"original_size":0,"labels":["automation","priority-8","scripting","watch"]}
{"id":"bd-15d","title":"Add test coverage reporting with tarpaulin","description":"## Purpose\nTrack and enforce test coverage metrics.\n\n## Setup\n```toml\n# Cargo.toml\n[dev-dependencies]\n# ... existing\n\n# .github/workflows/ci.yml (for reference)\n# - cargo install cargo-tarpaulin\n# - cargo tarpaulin --out Html --out Lcov\n```\n\n## Configuration\n```toml\n# tarpaulin.toml\n[default]\nrun-types = [\"Tests\"]\nskip-clean = true\nverbose = true\nall-features = false\nworkspace = false\ntimeout = \"120s\"\nout = [\"Html\", \"Lcov\"]\noutput-dir = \"coverage\"\n\n# Exclude generated code and test utilities\nexclude-files = [\n    \"tests/*\",\n    \"build.rs\",\n]\n```\n\n## Usage\n```bash\n# Generate coverage report\ncargo tarpaulin\n\n# With specific target\ncargo tarpaulin --test integration\n\n# Enforce minimum coverage\ncargo tarpaulin --fail-under 70\n```\n\n## Success Criteria\n- [ ] tarpaulin configured and working\n- [ ] HTML report generated\n- [ ] Coverage badge available\n- [ ] CI integration documented\n- [ ] Minimum coverage threshold defined (suggest: 70%)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:52.660169348Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:52.670162573Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-15d","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:52.670102600Z","created_by":"ubuntu"}]}
{"id":"bd-169","title":"Implement KeyConfig parsing","description":"Implement KeyConfig enum and serde deserialization:\n- Image { image: PathBuf }\n- Pattern { pattern: String }\n- Color { color: ColorSpec }\n- Clear { clear: bool }\n\nHandle untagged enum deserialization properly.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.342822871Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:56.357925747Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-169","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.357886824Z","created_by":"ubuntu"}]}
{"id":"bd-16u","title":"Write tests for export functionality","description":"## Test Coverage for Export to Shell Script\n\n### Unit Tests - Bash Export\n\n1. **Empty Session Tests**\n   - No state = minimal script with shebang only\n   - No brightness set = no brightness command\n   - No keys set = no set-key commands\n   - Shebang and set -e present by default\n\n2. **Brightness Export Tests**\n   - Brightness 0 exported correctly\n   - Brightness 100 exported correctly\n   - Brightness 50 with --serial flag\n   - Only most recent brightness (not history)\n\n3. **Key Image Export Tests**\n   - Image paths exported correctly\n   - Multiple images in key order\n   - Paths with spaces quoted correctly\n   - Paths with quotes escaped correctly\n   - Paths with shell specials ($, `, !) escaped\n   - Absolute paths by default\n   - Relative paths with --relative flag\n\n4. **Key Color Export Tests**\n   - Hex colors exported: #FF5500\n   - Named colors converted: \"red\" → \"#FF0000\"\n   - RGB format preserved or converted\n   - Mixed images and colors ordered correctly\n\n5. **Clear Key Export Tests**\n   - Cleared keys generate clear-key commands\n   - Clear-all if all keys cleared\n   - Interleaved with set commands\n\n6. **Command Ordering Tests**\n   - Brightness first (device setup)\n   - Then key operations (set, fill, clear)\n   - Consistent ordering for reproducibility\n   - Keys sorted by index\n\n### Unit Tests - Path Handling\n\n7. **Special Character Tests**\n   - Space: `/path/my image.png` → `\"/path/my image.png\"`\n   - Quote: `/path/\"quoted\".png` → `\"/path/\\\"quoted\\\".png\"`\n   - Dollar: `/path/$var.png` → `\"/path/\\$var.png\"`\n   - Backtick: `/path/\\`cmd\\`.png` → `\"/path/\\\\\\`cmd\\\\\\`.png\"`\n   - Newline in filename (edge case)\n   - Unicode paths preserved correctly\n\n8. **Absolute vs Relative Paths**\n   - Default: absolute paths\n   - --relative: paths relative to script location\n   - --relative + --embed: irrelevant (embedded)\n   - Symlinks followed for absolute\n\n### Unit Tests - Base64 Embedding\n\n9. **Embed Mode Tests**\n   - Image data base64 encoded inline\n   - Script decodes and pipes to sd\n   - Valid base64 that decodes correctly\n   - Large images (1MB) work without issue\n   - Multiple images each embedded separately\n\n10. **Embed Script Structure**\n    - Uses heredoc for cleanliness\n    - Or inline base64 with pipe\n    - Comments indicate original path\n    - Script works on fresh system (no deps)\n\n### Integration Tests\n\n11. **Roundtrip Tests**\n    - Set up device state\n    - Export to script\n    - Clear device\n    - Run script\n    - Verify state restored exactly\n\n12. **Cross-Device Tests**\n    - Export from XL\n    - Run on Mini (fails gracefully for out-of-range keys)\n    - Warning for key mismatch\n\n### E2E Tests\n\n13. **CLI Output Tests**\n    - `sd export bash` outputs to stdout\n    - `sd export bash -o script.sh` writes to file\n    - `sd export bash --embed` includes base64 data\n    - `sd export bash --serial ABC123` includes serial flag\n\n14. **Shell Execution Tests**\n    - Generated script passes shellcheck\n    - Generated script passes bash -n (syntax check)\n    - Script runs without error on test system\n    - Script is idempotent (run twice = same result)\n\n### Fish/PowerShell Export Tests\n\n15. **Fish Shell Export**\n    - set -x for variables\n    - Command substitution with ()\n    - Proper string quoting rules\n    - Tested with fish --no-execute\n\n16. **PowerShell Export**\n    - Param() block for parameters\n    - $ErrorActionPreference = \"Stop\"\n    - Proper string quoting rules\n    - Tested with pwsh -NoExecute\n\n### Logging Requirements\n- TRACE: Each command added to script, path escaping decisions\n- DEBUG: Export options, file counts\n- INFO: Export started/completed, output location\n- WARN: Missing source images (referenced but not found)\n- ERROR: Write failures, invalid state","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.979294395Z","created_by":"ubuntu","updated_at":"2026-01-19T21:07:18.644852414Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-16u","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:03.246254901Z","created_by":"ubuntu"},{"issue_id":"bd-16u","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.996155501Z","created_by":"ubuntu"},{"issue_id":"bd-16u","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:09.298328669Z","created_by":"ubuntu"}]}
{"id":"bd-17e","title":"Add robot mode hook status reporting","description":"Emit hook execution in robot mode:\n```json\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"hook\": {\"command\": \"...\", \"status\": \"started\", \"pid\": 12345}\n}\n```\n\nOptionally report completion/timeout.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.271293808Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.283235562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-17e","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.283150772Z","created_by":"ubuntu"}]}
{"id":"bd-180","title":"Implement MockDevice for unit testing","description":"## Purpose\nCreate a mock device implementation that records operations and allows assertions in unit tests.\n\n## Implementation\n```rust\n// src/device/mock.rs\nuse std::collections::VecDeque;\n\npub struct MockDevice {\n    info: DeviceInfo,\n    brightness: u8,\n    keys: HashMap<u8, Vec<u8>>,  // key -> image data\n    input_queue: VecDeque<KeyEvent>,\n    operation_log: Vec<Operation>,\n    error_injection: Option<SdError>,\n}\n\n#[derive(Debug, Clone)]\npub enum Operation {\n    SetBrightness(u8),\n    SetKeyImage { key: u8, size: usize },\n    ClearKey(u8),\n    ReadInput,\n    Flush,\n}\n\nimpl MockDevice {\n    pub fn new(model: DeviceModel) -> Self;\n    \n    // Test helpers\n    pub fn inject_error(&mut self, error: SdError);\n    pub fn queue_input(&mut self, event: KeyEvent);\n    pub fn get_operations(&self) -> &[Operation];\n    pub fn get_key_image(&self, key: u8) -> Option<&[u8]>;\n    pub fn get_brightness(&self) -> u8;\n    pub fn clear_operations(&mut self);\n}\n\nimpl DeviceOperations for MockDevice {\n    // Implement all trait methods\n    // Record operations to log\n    // Return injected errors when configured\n}\n```\n\n## Device Models\nSupport mocking different Stream Deck variants:\n```rust\npub enum DeviceModel {\n    Mini,      // 6 keys\n    Original,  // 15 keys\n    XL,        // 32 keys\n    MK2,       // 15 keys\n    Pedal,     // 3 pedals\n}\n```\n\n## Success Criteria\n- [ ] MockDevice implements DeviceOperations trait\n- [ ] Can configure device model (key count, dimensions)\n- [ ] Records all operations for assertion\n- [ ] Supports error injection\n- [ ] Supports input event queuing\n- [ ] Thread-safe for concurrent tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:49.917342512Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:49.928750702Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-180","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:49.928687102Z","created_by":"ubuntu"}]}
{"id":"bd-18h","title":"Integrate rate limiter into batch set-keys","description":"Modify batch operations:\n1. Create RateLimiter if --rate-limit specified\n2. Call limiter.wait() before each device operation\n3. Apply default rate limit for large batches\n\nPrevents USB flooding on rapid operations.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:20.391609830Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:20.408684178Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-18h","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:20.408634585Z","created_by":"ubuntu"}]}
{"id":"bd-1ch","title":"Add error handling and continue-on-error","description":"Implement error handling:\n- When continue_on_error=false: fail fast on first error\n- When continue_on_error=true: collect all errors, report at end\n- Include key index and file path in error messages\n- Track partial success (N of M keys set)","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.535377378Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.551934833Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ch","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.551895849Z","created_by":"ubuntu"}]}
{"id":"bd-1dc","title":"Add state tracking to all mutating commands","description":"Modify each command handler to track state:\n- brightness: track_brightness(level)\n- set-key: track_set_key(key, path)\n- fill-key: track_fill_key(key, color)\n- clear-key: track_clear_key(key)\n- clear-all: track_clear_all(key_count)\n\nCall after successful device operation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.467962903Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.478565857Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1dc","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.478517055Z","created_by":"ubuntu"}]}
{"id":"bd-1es","title":"Create output module structure with Output trait","description":"# Create output module structure with Output trait\n\n## Purpose\nCreate the src/output/ module that defines the Output trait abstraction. This trait is the cornerstone of the entire integration - it allows commands to output data without knowing whether they are in robot mode or human mode.\n\n## Background\nThe current codebase has output logic scattered throughout main.rs with direct println! calls for JSON and colored output. This task centralizes all output behind a trait, enabling:\n1. Clean separation of concerns\n2. Easy testing (mock output implementations)\n3. Future extensibility (e.g., file output, remote logging)\n\n## Technical Details\n\n### Module Structure\n```\nsrc/output/\n├── mod.rs      # OutputMode enum, Output trait, re-exports\n├── robot.rs    # RobotOutput implementation (JSON)\n└── human.rs    # HumanOutput implementation (rich_rust)\n```\n\n### OutputMode Enum (src/output/mod.rs)\n```rust\nuse rich_rust::prelude::*;\n\n/// Determines how command output is rendered\npub enum OutputMode {\n    /// JSON output for AI agents and scripting\n    Robot(RobotFormat),\n    /// Styled terminal output for human users\n    Human(Console),\n}\n\n/// JSON formatting options\npub enum RobotFormat {\n    /// Pretty-printed JSON (default for --robot)\n    Json,\n    /// Single-line JSON (--format=json-compact)\n    JsonCompact,\n}\n\nimpl OutputMode {\n    /// Create OutputMode from CLI arguments\n    pub fn from_cli(cli: &Cli) -> Self {\n        if cli.use_json() {\n            let format = if cli.use_compact_json() {\n                RobotFormat::JsonCompact\n            } else {\n                RobotFormat::Json\n            };\n            Self::Robot(format)\n        } else {\n            // rich_rust Console auto-detects:\n            // - TTY vs pipe (disables colors when piped)\n            // - NO_COLOR env var\n            // - Terminal color capabilities (4/8/24-bit)\n            let console = Console::builder()\n                .safe_box(cli.no_color)  // ASCII fallback if requested\n                .build();\n            Self::Human(console)\n        }\n    }\n    \n    pub fn is_robot(&self) -> bool {\n        matches!(self, Self::Robot(_))\n    }\n    \n    /// Get the appropriate Output implementation\n    pub fn as_output(&self) -> Box<dyn Output> {\n        match self {\n            Self::Robot(format) => Box::new(RobotOutput::new(*format)),\n            Self::Human(console) => Box::new(HumanOutput::new(console.clone())),\n        }\n    }\n}\n```\n\n### Output Trait (src/output/mod.rs)\n```rust\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse std::path::Path;\n\n/// Trait for all output operations\n/// \n/// This trait abstracts over robot mode (JSON) and human mode (rich_rust).\n/// Commands call these methods without knowing the output mode.\npub trait Output {\n    // Basic messages\n    fn success(&self, message: &str);\n    fn error(&self, error: &SdError);\n    fn warning(&self, message: &str);\n    fn info(&self, message: &str);\n    \n    // Device operations\n    fn device_list(&self, devices: &[DeviceInfo]);\n    fn device_info(&self, info: &DeviceInfo);\n    \n    // Button events (for watch command)\n    fn button_event(&self, event: &ButtonEvent);\n    fn button_states(&self, states: &[bool]);\n    \n    // Display operations\n    fn brightness_set(&self, level: u8);\n    fn key_set(&self, key: u8, image: &Path);\n    fn key_cleared(&self, key: u8);\n    fn key_filled(&self, key: u8, color: &str);\n    fn all_cleared(&self);\n    fn all_filled(&self, color: &str);\n    \n    // Metadata\n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>);\n    \n    // Visual separators (no-op in robot mode)\n    fn rule(&self, title: Option<&str>);\n    fn newline(&self);\n}\n```\n\n### Re-exports\n```rust\npub mod robot;\npub mod human;\n\npub use robot::RobotOutput;\npub use human::HumanOutput;\n```\n\n## Design Decisions\n\n### Why a Trait Instead of Enum Methods?\nA trait allows:\n1. Open extension (new output modes without modifying enum)\n2. Mock implementations for testing\n3. Dynamic dispatch when output mode varies at runtime\n\n### Why Clone Console?\nThe Console from rich_rust is cheap to clone (it's mostly Rc<RefCell<...>>). Cloning allows HumanOutput to own its console.\n\n### Why Box<dyn Output>?\nCommands receive &dyn Output for maximum flexibility. The boxing happens once at startup.\n\n## Implementation Steps\n1. Create src/output/ directory\n2. Create src/output/mod.rs with OutputMode and Output trait\n3. Add placeholder modules for robot.rs and human.rs\n4. Add mod output; to src/lib.rs or src/main.rs\n5. Verify compilation\n\n## Verification\n```bash\ncargo check --all-targets\n```\n\n## Acceptance Criteria\n- [ ] src/output/mod.rs exists with OutputMode and Output trait\n- [ ] Output trait has all methods listed above\n- [ ] OutputMode::from_cli() correctly detects robot vs human mode\n- [ ] Module compiles without errors\n- [ ] No changes to existing command behavior (yet)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:58.061089633Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:58.106837677Z","compaction_level":0,"original_size":0,"labels":["architecture","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-1es","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:02:58.101765117Z","created_by":"ubuntu"},{"issue_id":"bd-1es","depends_on_id":"bd-pnk","type":"blocks","created_at":"2026-01-19T21:02:58.106797001Z","created_by":"ubuntu"}]}
{"id":"bd-1eu","title":"Add robot mode cache hit/miss reporting","description":"In robot mode, include cache info:\n```json\n{\n  \"key\": 5,\n  \"cache\": {\"hit\": true, \"path\": \"...\"}\n}\n```\n\nUseful for diagnosing performance.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:40.506479431Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:40.520617811Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1eu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:40.520564341Z","created_by":"ubuntu"}]}
{"id":"bd-1fd","title":"Implement text positioning","description":"Add TextPosition enum:\n- Top: centered at top with padding\n- Center: centered both ways\n- Bottom: centered at bottom with padding\n- Custom { x, y }: explicit coordinates\n\nCalculate position based on text metrics.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.298548355Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.309658684Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1fd","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.309593942Z","created_by":"ubuntu"}]}
{"id":"bd-1g6","title":"Write tests for image caching","description":"## Test Coverage for Image Caching\n\n### Unit Tests - Cache Key Generation\n\n1. **Content-Based Hashing**\n   - Same content = same hash\n   - Different content = different hash\n   - Hash includes file content (not path)\n   - Hash includes target dimensions\n   - Hash is deterministic\n\n2. **Dimension Handling**\n   - 72x72 (XL keys) and 96x96 (MK2 keys) are different\n   - Same image at different sizes = different entries\n   - Hash format: `{content_sha256}-{width}x{height}.bin`\n\n3. **Path Independence**\n   - `/path/a/icon.png` and `/path/b/icon.png` with same content → same hash\n   - Renaming file doesn't change hash\n   - Moving file doesn't change hash\n\n### Unit Tests - Cache Operations\n\n4. **Cache Miss Behavior**\n   - get() returns None for missing entry\n   - put() stores data correctly\n   - Data retrievable immediately after put()\n   - File created with correct name\n\n5. **Cache Hit Behavior**\n   - get() returns exact stored data\n   - Data matches what was put()\n   - No reprocessing of image\n   - File timestamp unchanged\n\n6. **Cache Invalidation (Implicit)**\n   - Modified source file → new hash → cache miss\n   - Old entry becomes orphan (not deleted)\n   - New entry created for modified file\n\n### Unit Tests - Cache Management\n\n7. **Stats Accuracy**\n   - Entry count matches actual files\n   - Size sum matches actual disk usage\n   - Empty cache shows zero entries/size\n   - Stats reflect recent operations\n\n8. **Clear Operation**\n   - Removes all .bin files\n   - Directory structure preserved\n   - Stats shows zero after clear\n   - Safe with concurrent access\n\n9. **Directory Management**\n   - Creates cache dir if not exists\n   - Handles missing parent directories\n   - Respects XDG_CACHE_HOME\n   - Handles permission errors gracefully\n\n### Integration Tests (require MockDevice)\n\n1. **Full Workflow - Cold Cache**\n   - Clear cache\n   - Set key with image\n   - Verify image processed\n   - Verify cache entry created\n   - Check stats shows 1 entry\n\n2. **Full Workflow - Warm Cache**\n   - Set same key with same image again\n   - Verify no reprocessing (fast)\n   - Verify cache hit logged\n   - Check stats unchanged\n\n3. **Multiple Images**\n   - Set 10 different images\n   - Verify 10 cache entries\n   - Clear and set same 10 again\n   - Verify all 10 cache hits\n\n4. **Device Model Differences**\n   - Same image for XL (72x72) and MK2 (96x96)\n   - Verify 2 different cache entries\n   - Verify correct entry used per device\n\n5. **Performance Comparison**\n   - Time to set 32 keys, cold cache\n   - Time to set 32 keys, warm cache\n   - Warm should be > 5x faster\n\n### E2E Tests (require E2E harness)\n\n1. **Cache Commands**\n   ```bash\n   # Show stats\n   sd cache stats\n   # Output: Cache location: ~/.cache/sd/images/\n   #         Entries: 47\n   #         Size: 2.3 MB\n   \n   # Clear cache\n   sd cache clear\n   # Output: Cleared 47 entries (2.3 MB)\n   \n   # Verify cleared\n   sd cache stats\n   # Output: Cache location: ~/.cache/sd/images/\n   #         Entries: 0\n   #         Size: 0 B\n   ```\n\n2. **Robot Mode Stats**\n   ```json\n   {\n     \"command\": \"cache_stats\",\n     \"cache\": {\n       \"location\": \"/home/user/.cache/sd/images\",\n       \"entries\": 47,\n       \"size_bytes\": 2412345\n     }\n   }\n   ```\n\n3. **Cache Performance Logging**\n   ```bash\n   RUST_LOG=sd=debug sd set-key 0 icon.png\n   # Shows: cache_miss, processing_ms, stored_bytes\n   \n   RUST_LOG=sd=debug sd set-key 0 icon.png  # again\n   # Shows: cache_hit, retrieved_bytes\n   ```\n\n### Edge Case Tests\n\n1. **Disk Full**\n   - Cache gracefully handles disk full\n   - Operation completes (without caching)\n   - Warning logged\n\n2. **Corrupted Cache Entry**\n   - Detect corrupted .bin file\n   - Regenerate from source\n   - Log warning about corruption\n\n3. **Concurrent Access**\n   - Multiple sd processes writing cache\n   - No data corruption\n   - Atomic writes (write to temp, rename)\n\n4. **Large Images**\n   - 4K image cached correctly\n   - Memory usage reasonable during processing\n   - Cached size is post-resize (small)\n\n### Test Fixtures\n\n```\ntests/fixtures/images/\n├── icon-72x72.png       # Pre-sized for XL\n├── icon-256x256.png     # Needs resize\n├── icon-4k.png          # Large image test\n├── duplicate/\n│   ├── a/icon.png       # Same content as b/\n│   └── b/icon.png       # Same content as a/\n└── formats/\n    ├── test.png\n    ├── test.jpg\n    └── test.webp\n```\n\n### Performance Targets\n- Cache lookup: < 1ms\n- Cache storage: < 10ms\n- Hash computation: < 5ms for 1MB image\n- Memory: < 10MB for cache operations","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:41.073285158Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:09.864888670Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1g6","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:51.427266969Z","created_by":"ubuntu"},{"issue_id":"bd-1g6","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:09.864841551Z","created_by":"ubuntu"},{"issue_id":"bd-1g6","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:41.087502506Z","created_by":"ubuntu"}]}
{"id":"bd-1go","title":"Implement simple RateLimiter struct","description":"Create src/rate_limit.rs:\n```rust\npub struct RateLimiter {\n    min_interval: Duration,\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    pub fn new(min_interval: Duration) -> Self;\n    pub fn wait(&mut self);      // Block until allowed\n    pub fn check(&self) -> bool; // Non-blocking check\n    pub fn try_acquire(&mut self) -> bool; // Try without blocking\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.219455612Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:18.249376667Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1go","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.249333887Z","created_by":"ubuntu"}]}
{"id":"bd-1gy","title":"Add PowerShell output format","description":"With --format powershell:\n- Use PowerShell syntax\n- Proper escaping for Windows paths\n- Different comment style","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.318755708Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:04.335099500Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1gy","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.335053844Z","created_by":"ubuntu"}]}
{"id":"bd-1he","title":"Write tests with sample profile files","description":"## Test Coverage for Elgato Profile Import\n\n### Unit Tests\n\n1. **ZIP Structure Validation**\n   - Valid .streamDeckProfile opens without error\n   - Invalid ZIP (corrupted) returns clear error\n   - Missing manifest.json returns error with suggestion\n   - Missing Profiles/ directory returns error\n   - Extra files in ZIP ignored (forward compat)\n\n2. **Manifest Parsing Tests**\n   - Parse Version field\n   - Parse DeviceUUID field\n   - Parse DeviceModel field (StreamDeckXL, StreamDeckMK2, etc.)\n   - Unknown DeviceModel logged as warning, proceeds\n   - Missing required fields return clear error\n\n3. **Profile JSON Parsing Tests**\n   - Parse profile Name and UUID\n   - Parse Keys array with all properties\n   - Parse Actions array (even if unsupported)\n   - Handle missing optional fields gracefully\n   - Handle extra unknown fields (forward compat)\n\n4. **Key Type Mapping Tests**\n   - Static image → KeyConfig::Image\n   - Solid color → KeyConfig::Color\n   - Website URL → log warning, convert to label or skip\n   - Folder → log warning, note nested structure\n   - Multi-action → log warning, list actions\n   - System action → map to shell command where possible\n\n5. **Image Extraction Tests**\n   - PNG images extracted correctly\n   - JPG images extracted correctly  \n   - Animated GIF → extract first frame, warn about animation\n   - Missing referenced image → clear error with path\n   - Image path resolution from relative to absolute\n\n### Integration Tests (require MockDevice)\n\n1. **Full Import Workflow**\n   - Import valid profile\n   - Verify all keys stored in config DB\n   - Verify images copied to config storage\n   - Apply imported profile to MockDevice\n   - Verify MockDevice state matches profile\n\n2. **Partial Import (Unsupported Features)**\n   - Import profile with folders\n   - Verify supported keys imported\n   - Verify warnings logged for unsupported\n   - Verify apply works for supported keys\n\n3. **Profile Management**\n   - `sd init --import profile.streamDeckProfile`\n   - `sd config list` shows imported profile\n   - `sd config show <name>` displays contents\n   - `sd apply <name>` applies to device\n\n4. **Image Storage Tests**\n   - Images stored with content-addressable names\n   - Duplicate images deduplicated\n   - Image retrieval works after import\n   - Storage handles large images\n\n### E2E Tests (require E2E harness)\n\n1. **CLI Import Flow**\n   - `sd init --import ~/Downloads/MySetup.streamDeckProfile`\n   - Verify exit code 0 on success\n   - Verify human-readable summary output\n   - Robot mode returns structured JSON\n\n2. **Error Handling**\n   - Non-existent file → clear error\n   - Non-ZIP file → \"not a valid profile\" error\n   - Profile for different device model → warning + proceed\n   - Permission denied → clear error\n\n3. **Round-Trip Test**\n   - Export profile from Elgato software\n   - Import to sd\n   - Apply to device\n   - Save as sd snapshot\n   - Compare snapshot to original profile\n\n### Test Fixtures (tests/fixtures/profiles/)\n\n```\nprofiles/\n├── valid/\n│   ├── minimal.streamDeckProfile     # Just manifest + 1 key\n│   ├── full-xl.streamDeckProfile     # 32 keys, various types\n│   ├── mk2-layout.streamDeckProfile  # 15 keys for MK2\n│   └── with-folders.streamDeckProfile # Nested folder structure\n├── unsupported/\n│   ├── with-multiaction.streamDeckProfile\n│   ├── with-animation.streamDeckProfile\n│   └── with-system-actions.streamDeckProfile\n├── invalid/\n│   ├── corrupted.streamDeckProfile   # Invalid ZIP\n│   ├── missing-manifest.streamDeckProfile\n│   ├── bad-json.streamDeckProfile    # Invalid JSON in profile\n│   └── missing-images.streamDeckProfile\n└── README.md                          # How to create test fixtures\n```\n\n### Fixture Creation Guide\n\nTo create test fixtures from Elgato software:\n1. Create profile in Stream Deck software\n2. Right-click profile → Export\n3. Copy to tests/fixtures/profiles/\n4. Document what's in the profile\n\n### Logging Requirements\n- DEBUG: Each file extracted from ZIP\n- INFO: Profile loaded, key count, device model\n- WARN: Unsupported features with feature name and impact\n- ERROR: Parse failures with location and suggestion","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.811560473Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:06.368185167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1he","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:47.355684984Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:06.368148297Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-2ky","type":"blocks","created_at":"2026-01-19T18:39:18.590934320Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.820941004Z","created_by":"ubuntu"}]}
{"id":"bd-1hi","title":"Implement dry-run for brightness command","description":"When dry_run=true:\n- Show current brightness (if readable)\n- Show target brightness\n- Show device info\n- Return without calling device\n\nRobot mode: JSON with action details\nHuman mode: formatted preview text","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.986179469Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:43.996964545Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1hi","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.996911625Z","created_by":"ubuntu"}]}
{"id":"bd-1im","title":"Add cache clear command","description":"Implement sd cache clear:\n- Remove all .bin files from cache directory\n- Report number of entries removed\n- Confirm before clearing (unless --force)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.939628450Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.957039341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1im","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.956989828Z","created_by":"ubuntu"}]}
{"id":"bd-1jf","title":"Obtain and bundle Inter font (OFL licensed)","description":"Add Inter font to binary:\n1. Download Inter-Regular.ttf from Google Fonts\n2. Place in assets/ directory\n3. Embed with include_bytes!()\n\nInter is OFL licensed - free to bundle.\nAlternative: Roboto, Source Sans Pro.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.288939436Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.299350899Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jf","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.299283902Z","created_by":"ubuntu"}]}
{"id":"bd-1jk","title":"Test generated completions for fish","description":"Manual testing (if fish available):\n1. Generate: sd completions fish > /tmp/sd.fish\n2. Source: source /tmp/sd.fish\n3. Test completion\n4. Verify no errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.082684903Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:12.269301415Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jk","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:12.269263674Z","created_by":"ubuntu"},{"issue_id":"bd-1jk","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.091697852Z","created_by":"ubuntu"}]}
{"id":"bd-1kd","title":"Implement non-blocking command execution","description":"## Purpose\nExecute commands without blocking the watch loop so button events are always responsive.\n\n## Implementation\n```rust\n// src/hooks/executor.rs\nuse std::process::{Command, Child, Stdio};\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, warn, error, info, instrument};\n\n/// Manages background command execution with optional tracking\npub struct CommandExecutor {\n    /// Active child processes by key\n    active_children: HashMap<u8, TrackedChild>,\n    /// Maximum concurrent commands per key (prevents spam)\n    max_per_key: usize,\n    /// Default timeout for commands\n    default_timeout: Duration,\n}\n\nstruct TrackedChild {\n    child: Child,\n    started_at: Instant,\n    command: String,\n    key: u8,\n}\n\nimpl CommandExecutor {\n    pub fn new(default_timeout: Duration) -> Self {\n        Self {\n            active_children: HashMap::new(),\n            max_per_key: 1,  // One command per key at a time\n            default_timeout,\n        }\n    }\n    \n    /// Execute a command non-blocking, optionally tracking it\n    #[instrument(skip(self), fields(key = %key))]\n    pub fn execute(&mut self, key: u8, command: &str, track: bool) -> Result<Option<u32>> {\n        // Check if a command is already running for this key\n        if let Some(existing) = self.active_children.get(&key) {\n            warn!(\n                key = %key,\n                existing_pid = %existing.child.id(),\n                elapsed_ms = %existing.started_at.elapsed().as_millis(),\n                \"Command already running for key, skipping\"\n            );\n            return Ok(None);\n        }\n        \n        trace!(command = %command, \"Spawning command\");\n        \n        let child = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(command)\n            .stdin(Stdio::null())\n            .stdout(Stdio::piped())  // Capture for logging\n            .stderr(Stdio::piped())\n            .spawn()?;\n        \n        let pid = child.id();\n        info!(pid = %pid, key = %key, \"Command started\");\n        \n        if track {\n            self.active_children.insert(key, TrackedChild {\n                child,\n                started_at: Instant::now(),\n                command: command.to_string(),\n                key,\n            });\n        }\n        \n        Ok(Some(pid))\n    }\n    \n    /// Check for completed commands and log their results\n    #[instrument(skip(self))]\n    pub fn reap_completed(&mut self) -> Vec<CommandResult> {\n        let mut results = Vec::new();\n        let mut completed_keys = Vec::new();\n        \n        for (key, tracked) in &mut self.active_children {\n            match tracked.child.try_wait() {\n                Ok(Some(status)) => {\n                    let duration = tracked.started_at.elapsed();\n                    let exit_code = status.code().unwrap_or(-1);\n                    \n                    if status.success() {\n                        debug!(\n                            key = %key,\n                            exit_code = %exit_code,\n                            duration_ms = %duration.as_millis(),\n                            \"Command completed successfully\"\n                        );\n                    } else {\n                        warn!(\n                            key = %key,\n                            exit_code = %exit_code,\n                            duration_ms = %duration.as_millis(),\n                            command = %tracked.command,\n                            \"Command failed\"\n                        );\n                    }\n                    \n                    results.push(CommandResult {\n                        key: *key,\n                        exit_code,\n                        duration,\n                        command: tracked.command.clone(),\n                    });\n                    completed_keys.push(*key);\n                }\n                Ok(None) => {\n                    // Still running, check for timeout\n                    if tracked.started_at.elapsed() > self.default_timeout {\n                        error!(\n                            key = %key,\n                            pid = %tracked.child.id(),\n                            timeout_ms = %self.default_timeout.as_millis(),\n                            \"Command timed out, killing\"\n                        );\n                        let _ = tracked.child.kill();\n                        completed_keys.push(*key);\n                    }\n                }\n                Err(e) => {\n                    error!(key = %key, error = %e, \"Failed to check command status\");\n                    completed_keys.push(*key);\n                }\n            }\n        }\n        \n        for key in completed_keys {\n            self.active_children.remove(&key);\n        }\n        \n        results\n    }\n    \n    /// Kill all active commands (for cleanup)\n    pub fn kill_all(&mut self) {\n        for (key, mut tracked) in self.active_children.drain() {\n            warn!(\n                key = %key,\n                pid = %tracked.child.id(),\n                \"Killing active command on shutdown\"\n            );\n            let _ = tracked.child.kill();\n        }\n    }\n}\n\npub struct CommandResult {\n    pub key: u8,\n    pub exit_code: i32,\n    pub duration: Duration,\n    pub command: String,\n}\n```\n\n## Integration with Watch Loop\n```rust\n// In watch command handler\nlet mut executor = CommandExecutor::new(Duration::from_millis(opts.exec_timeout));\n\nloop {\n    // Reap any completed commands first\n    let completed = executor.reap_completed();\n    for result in completed {\n        if opts.robot {\n            emit_hook_result(&result);\n        }\n    }\n    \n    // Read device input\n    if let Some(event) = device.read_input(timeout)? {\n        // ... emit event ...\n        \n        if let Some(cmd) = resolve_command(&opts, &event) {\n            match executor.execute(event.key, &cmd, opts.robot) {\n                Ok(Some(pid)) => {\n                    if opts.robot {\n                        emit_hook_started(event.key, &cmd, pid);\n                    }\n                }\n                Ok(None) => { /* Skipped - already running */ }\n                Err(e) => error!(error = %e, \"Failed to execute command\"),\n            }\n        }\n    }\n}\n\n// On shutdown (Ctrl+C)\nexecutor.kill_all();\n```\n\n## Success Criteria\n- [ ] Commands execute without blocking event reading\n- [ ] Duplicate commands for same key are prevented\n- [ ] Timed out commands are killed\n- [ ] Completed commands are reaped and logged\n- [ ] All child processes cleaned up on shutdown\n\n## Logging Requirements\n- TRACE: Command being spawned, argument details\n- DEBUG: Command completed successfully, exit code, duration\n- INFO: Command started with PID\n- WARN: Command already running for key (skipped), command failed with non-zero exit\n- ERROR: Command timed out, failed to check status, failed to spawn","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.147168248Z","created_by":"ubuntu","updated_at":"2026-01-19T20:49:50.361905834Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kd","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.161513186Z","created_by":"ubuntu"}]}
{"id":"bd-1kw","title":"Write tests for batch operations","description":"## Test Coverage for Batch Operations\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **Pattern Parsing Tests**\n   - `key-{index}.png` parses correctly\n   - `icon_{index:02d}.jpg` with format specifiers\n   - Invalid patterns return clear errors\n   - Empty pattern handling\n\n2. **Directory Scanning Tests**\n   - Finds all matching files in flat directory\n   - Handles nested directories (should not recurse by default)\n   - Handles empty directories gracefully\n   - Handles non-existent directories with clear error\n   - Handles permission denied with clear error\n\n3. **Image Validation Tests**\n   - Valid PNG files accepted\n   - Valid JPG files accepted\n   - Corrupted images return specific error\n   - Non-image files (text, binary) rejected with clear error\n   - Zero-byte files rejected\n\n4. **Key Mapping Tests**\n   - key-00.png maps to key 0\n   - key-31.png maps to key 31\n   - key-32.png rejected (out of range for XL)\n   - Gaps handled correctly (key-00 and key-05 with nothing between)\n\n5. **Continue-On-Error Tests**\n   - Without flag: first error aborts entire operation\n   - With flag: collects all errors, continues processing\n   - Error report includes all failed keys and reasons\n   - Successful keys still applied even when some fail\n\n### Integration Tests (require MockDevice)\n\n1. **Full Device Setup**\n   - Load 32 images for Stream Deck XL\n   - Load 15 images for Stream Deck MK2\n   - Load 6 images for Stream Deck Mini\n   - Verify all keys set correctly via MockDevice assertions\n\n2. **Partial Device Setup**\n   - Load 10 of 32 images\n   - Verify only specified keys changed\n   - Verify unspecified keys unchanged\n\n3. **Robot Mode Output**\n   - JSON output includes per-key status\n   - Success includes key index, source path, dimensions\n   - Failure includes key index, error reason, suggestion\n   - Timing information included for performance analysis\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Invocation**\n   - `sd set-keys ./test-dir/` works with valid directory\n   - `sd set-keys ./test-dir/ --pattern \"icon-{index}.png\"` uses custom pattern\n   - `sd set-keys ./test-dir/ --continue-on-error` continues on failures\n   - `sd set-keys ./nonexistent/` returns exit code 1 with clear error\n\n2. **Human Output Verification**\n   - Progress messages show key count\n   - Success message shows total applied\n   - Error messages are actionable\n\n### Logging Requirements\n- TRACE: Each file discovered during scan\n- DEBUG: Pattern matching decisions, image loading steps\n- INFO: Overall operation start/complete, key count\n- WARN: Skipped files (missing, wrong format)\n- ERROR: Failed operations with full context\n\n### Test Data (from bd-2ky fixtures)\n- tests/fixtures/batch/complete-32/ - full XL layout\n- tests/fixtures/batch/partial-10/ - sparse layout\n- tests/fixtures/batch/corrupted/ - invalid images\n- tests/fixtures/batch/mixed-formats/ - PNG, JPG, WebP","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:23:43.108243605Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:50.955996693Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kw","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:34.167591460Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:49.161941811Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-2ky","type":"blocks","created_at":"2026-01-19T21:02:50.955950906Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:43.117865321Z","created_by":"ubuntu"}]}
{"id":"bd-1lk","title":"Create theme system with SdTheme struct","description":"# Create theme system with SdTheme struct\n\n## Purpose\nDefine a cohesive visual identity for the Stream Deck CLI through a centralized theme system. This ensures consistent colors, styles, and visual elements across all commands.\n\n## Background\n\n### Why a Theme System?\nWithout centralized theme management:\n- Colors would be scattered across multiple files\n- Changing the visual identity would require editing many places\n- Inconsistent styling would create a disjointed experience\n\n### Design Philosophy\nThe theme should feel:\n- **Premium**: High-quality, polished appearance\n- **Technical**: Appropriate for a developer tool\n- **Branded**: Subtle Stream Deck identity (blue accent)\n- **Accessible**: Works on various terminal color schemes\n\n## Technical Details\n\n### Module Structure\n```\nsrc/theme/\n├── mod.rs       # SdTheme struct and Default impl\n└── (future: additional themes if needed)\n```\n\n### SdTheme Struct (src/theme/mod.rs)\n```rust\nuse rich_rust::prelude::*;\n\n/// Visual theme for Stream Deck CLI human-mode output\n/// \n/// This struct centralizes all colors and styles used throughout\n/// the CLI, ensuring visual consistency and easy customization.\npub struct SdTheme {\n    // ═══════════════════════════════════════════════════════\n    // Brand Colors\n    // ═══════════════════════════════════════════════════════\n    \n    /// Primary accent color (Stream Deck blue)\n    /// Used for: headers, panel borders, highlights\n    pub accent: Color,\n    \n    /// Success color (green)\n    /// Used for: success messages, checkmarks, positive states\n    pub success: Color,\n    \n    /// Error color (red)\n    /// Used for: error messages, X marks, negative states\n    pub error: Color,\n    \n    /// Warning color (amber)\n    /// Used for: warnings, key indices, attention items\n    pub warning: Color,\n    \n    /// Muted color (gray)\n    /// Used for: timestamps, secondary info, hints\n    pub muted: Color,\n    \n    // ═══════════════════════════════════════════════════════\n    // Component Styles\n    // ═══════════════════════════════════════════════════════\n    \n    /// Style for section headers\n    /// Applied to: device names, section titles\n    pub header: Style,\n    \n    /// Style for labels/keys in key-value pairs\n    /// Applied to: \"Serial:\", \"Firmware:\", etc.\n    pub label: Style,\n    \n    /// Style for values in key-value pairs\n    /// Applied to: actual serial numbers, versions, etc.\n    pub value: Style,\n    \n    /// Style for key indices (0-31)\n    /// Applied to: key numbers in events and operations\n    pub key_index: Style,\n    \n    /// Style for device serial numbers\n    /// Applied to: serial number display\n    pub device_serial: Style,\n    \n    /// Style for brightness values\n    /// Applied to: brightness percentage\n    pub brightness: Style,\n    \n    /// Style for button press events\n    /// Applied to: \"pressed\" state indicator\n    pub button_pressed: Style,\n    \n    /// Style for button release events\n    /// Applied to: \"released\" state indicator\n    pub button_released: Style,\n    \n    // ═══════════════════════════════════════════════════════\n    // Box Drawing\n    // ═══════════════════════════════════════════════════════\n    \n    /// Box character set for panels and tables\n    /// Default: ROUNDED (╭─╮) for modern terminals\n    /// Fallback: ASCII (+--+) when safe_box is enabled\n    pub box_style: &'static BoxChars,\n}\n```\n\n### Color Palette\n```rust\nimpl Default for SdTheme {\n    fn default() -> Self {\n        // Helper to parse color or panic (these are constants, so safe)\n        let color = |hex: &str| Color::parse(hex).expect(\"invalid theme color\");\n        \n        Self {\n            // Brand colors - carefully chosen for terminal visibility\n            accent: color(\"#0080FF\"),     // Stream Deck blue\n            success: color(\"#00D26A\"),    // Vibrant green\n            error: color(\"#FF4757\"),      // Soft red (not harsh)\n            warning: color(\"#FFA502\"),    // Amber/orange\n            muted: color(\"#747D8C\"),      // Medium gray\n            \n            // Component styles built from brand colors\n            header: Style::new()\n                .bold()\n                .color(color(\"#0080FF\")),\n            \n            label: Style::new()\n                .dim(),\n            \n            value: Style::new()\n                .bold(),\n            \n            key_index: Style::new()\n                .bold()\n                .color(color(\"#FFA502\")),\n            \n            device_serial: Style::new()\n                .italic()\n                .color(color(\"#747D8C\")),\n            \n            brightness: Style::new()\n                .bold()\n                .color(color(\"#00D26A\")),\n            \n            button_pressed: Style::new()\n                .bold()\n                .color(color(\"#00D26A\")),\n            \n            button_released: Style::new()\n                .dim(),\n            \n            box_style: &BoxChars::ROUNDED,\n        }\n    }\n}\n```\n\n### Usage Pattern\n```rust\nlet theme = SdTheme::default();\n\n// Use in output formatting\nlet mut text = Text::new(\"\");\ntext.append_styled(\"Serial: \", theme.label.clone());\ntext.append_styled(&device.serial, theme.device_serial.clone());\n\n// Use colors for panels\nlet panel = Panel::from_text(\"content\")\n    .border_style(Style::new().color(theme.accent));\n```\n\n## Color Selection Rationale\n\n### Accent (#0080FF)\n- Stream Deck devices feature blue LED backlighting\n- Blue conveys technology, reliability, precision\n- High visibility on both light and dark backgrounds\n\n### Success (#00D26A)\n- Standard \"green = good\" convention\n- Bright enough to stand out\n- Not so bright as to be harsh\n\n### Error (#FF4757)\n- Soft red that draws attention without being alarming\n- Readable against dark backgrounds\n- Not pure red (#FF0000) which can be harsh\n\n### Warning (#FFA502)\n- Amber/orange for caution\n- Distinct from both error (red) and success (green)\n- Used for key indices to make them pop\n\n### Muted (#747D8C)\n- Medium gray for secondary information\n- Readable but doesn't compete with primary content\n- Works on both light and dark terminals\n\n## Implementation Steps\n1. Create src/theme/ directory\n2. Create src/theme/mod.rs with SdTheme struct\n3. Implement Default trait with color palette\n4. Add mod theme; to main module\n5. Test color rendering in terminal\n\n## Verification\n```bash\ncargo check --all-targets\n# Manual: Create a test that prints all theme colors\n```\n\n## Future Considerations\n- Environment variable for theme selection (e.g., SD_THEME=dark)\n- High-contrast theme for accessibility\n- Theme customization via config file\n\n## Acceptance Criteria\n- [ ] src/theme/mod.rs exists with SdTheme struct\n- [ ] All colors parse correctly\n- [ ] Default implementation provides complete theme\n- [ ] Theme is usable from other modules\n- [ ] Colors render correctly in 24-bit terminal","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:03:31.559055622Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:31.606787351Z","compaction_level":0,"original_size":0,"labels":["design","phase-1","rich-rust","theme"],"dependencies":[{"issue_id":"bd-1lk","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:03:31.602205695Z","created_by":"ubuntu"},{"issue_id":"bd-1lk","depends_on_id":"bd-pnk","type":"blocks","created_at":"2026-01-19T21:03:31.606756994Z","created_by":"ubuntu"}]}
{"id":"bd-1mz","title":"Write tests for text rendering","description":"Test coverage:\n1. Basic text rendering produces valid image\n2. Positioning calculations\n3. Color parsing\n4. Multi-line handling\n5. Custom font loading\n6. Overlay on existing image","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:18.486160476Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:07.381545144Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1mz","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:49.883258559Z","created_by":"ubuntu"},{"issue_id":"bd-1mz","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:18.495504950Z","created_by":"ubuntu"},{"issue_id":"bd-1mz","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:07.381508044Z","created_by":"ubuntu"}]}
{"id":"bd-1n3","title":"Write tests for rate limiting","description":"Test coverage:\n1. RateLimiter blocks correctly\n2. TokenBucket refills properly\n3. Burst capacity works\n4. Timing accuracy (within tolerance)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.853066162Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:08.720527173Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1n3","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:01.679672417Z","created_by":"ubuntu"},{"issue_id":"bd-1n3","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:08.720488751Z","created_by":"ubuntu"},{"issue_id":"bd-1n3","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.870109300Z","created_by":"ubuntu"}]}
{"id":"bd-1os","title":"Implement open_with_retry in device.rs","description":"## Purpose\nAdd robust connection retry logic to handle USB flakiness and disconnections.\n\n## Implementation\n\n### ConnectionOptions Struct\n```rust\n// src/device.rs\nuse std::time::Duration;\n\n#[derive(Debug, Clone)]\npub struct ConnectionOptions {\n    /// Maximum number of connection attempts (default: 3)\n    pub max_retries: u32,\n    /// Initial delay between retries (default: 1000ms)\n    pub retry_delay: Duration,\n    /// Exponential backoff factor (default: 1.5)\n    pub backoff_factor: f32,\n    /// Maximum delay cap (default: 10000ms)\n    pub max_delay: Duration,\n}\n\nimpl Default for ConnectionOptions {\n    fn default() -> Self {\n        Self {\n            max_retries: 3,\n            retry_delay: Duration::from_millis(1000),\n            backoff_factor: 1.5,\n            max_delay: Duration::from_millis(10000),\n        }\n    }\n}\n```\n\n### open_with_retry Method\n```rust\nimpl Device {\n    #[instrument(skip(self), fields(serial = ?serial, max_retries = %opts.max_retries))]\n    pub fn open_with_retry(\n        serial: Option<&str>,\n        opts: &ConnectionOptions,\n    ) -> Result<Self, DeviceError> {\n        let mut delay = opts.retry_delay;\n        \n        for attempt in 1..=opts.max_retries {\n            let span = span!(Level::DEBUG, \"connection_attempt\", attempt = %attempt);\n            let _enter = span.enter();\n            \n            match Self::open(serial) {\n                Ok(device) => {\n                    info!(attempt = %attempt, \"Device connected successfully\");\n                    return Ok(device);\n                }\n                Err(e) if e.is_connection_error() && attempt < opts.max_retries => {\n                    warn!(\n                        attempt = %attempt,\n                        max = %opts.max_retries,\n                        error = %e,\n                        delay_ms = %delay.as_millis(),\n                        \"Connection failed, retrying\"\n                    );\n                    std::thread::sleep(delay);\n                    delay = Duration::from_secs_f32(\n                        (delay.as_secs_f32() * opts.backoff_factor)\n                            .min(opts.max_delay.as_secs_f32())\n                    );\n                }\n                Err(e) => {\n                    error!(\n                        attempt = %attempt,\n                        error = %e,\n                        \"Connection failed, no more retries\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n        unreachable!()\n    }\n}\n```\n\n## Edge Cases\n- First attempt succeeds immediately (common case)\n- All retries exhausted → return final error with context\n- Non-connection errors (permission, etc.) → fail fast, no retry\n- Ctrl+C during sleep → propagate interrupt\n\n## Logging Requirements\n- TRACE: Entry/exit of retry loop iterations\n- DEBUG: Connection attempt start, delay calculation\n- INFO: Successful connection (with attempt count)\n- WARN: Failed attempt with retry pending\n- ERROR: Final failure after all retries exhausted\n\n## Success Criteria\n- [ ] Retries up to configured max\n- [ ] Exponential backoff applied correctly\n- [ ] Delay capped at max_delay\n- [ ] Connection errors trigger retry, others fail fast\n- [ ] Robot mode emits retry events as JSON","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.758006167Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:00.994099011Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1os","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.774281400Z","created_by":"ubuntu"}]}
{"id":"bd-1po","title":"Test on different platforms","description":"Verify text rendering:\n1. Linux (font rendering consistency)\n2. macOS (different gamma/anti-aliasing)\n3. Windows (if applicable)\n\nBundled font should ensure consistent results.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.929869687Z","created_by":"ubuntu","updated_at":"2026-01-19T18:39:13.984774287Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1po","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.940706621Z","created_by":"ubuntu"},{"issue_id":"bd-1po","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:13.984739381Z","created_by":"ubuntu"}]}
{"id":"bd-1q4","title":"EPIC: Export to Shell Script","description":"## Overview\n**Rank: #10 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Medium**\n\nGenerate a shell script that recreates the current configuration.\n\n## Problem Statement\nUsers want to:\n- Share their Stream Deck setup with others\n- Back up their configuration in a portable format\n- Reproduce their setup on a new machine\n- Understand exactly what commands created their current state\n\nCurrently theres no way to export the configuration in a reproducible format.\n\n## Solution\nExport command that generates a self-contained shell script:\n```bash\nsd export-script > setup.sh\n# Generates:\n#!/bin/bash\n# Stream Deck configuration exported by sd\n# Device: Stream Deck XL (serial: ABC123)\n# Exported: 2024-01-15T10:30:00Z\n\nset -e\n\nsd brightness 80\nsd set-key 0 /absolute/path/to/chrome.png\nsd set-key 1 /absolute/path/to/slack.png\nsd fill-key 2 \"#FF5500\"\nsd set-key 3 /absolute/path/to/terminal.png\n# ... remaining keys\nsd clear-key 31\n\necho \"Configuration applied successfully\"\n```\n\nAdvanced options:\n```bash\n# Include images as base64 (self-contained)\nsd export-script --embed-images > setup.sh\n\n# Export specific profile\nsd export-script --profile work > work-setup.sh\n\n# Export as different format\nsd export-script --format makefile > Makefile.streamdeck\n```\n\n## Why This Is #10 Priority\n1. **Reproducibility**: Share and restore configurations easily\n2. **Backup strategy**: Simple text file captures everything\n3. **Debugging**: See exactly what commands create the state\n4. **Low effort**: ~60 lines if we track applied state\n5. **Complementary**: Works alongside other features\n\n## Technical Challenge: State Tracking\nLike SAVE-RESTORE, we face the challenge that Stream Deck hardware doesnt allow reading back the current state. Two approaches:\n\n### Approach A: Session History\nTrack commands applied during the current session:\n```rust\nstruct SessionHistory {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyCommand>,\n}\n\nenum KeyCommand {\n    SetImage(PathBuf),\n    FillColor(String),\n    Clear,\n}\n```\n- Pro: Accurate for current session\n- Con: Lost on restart\n\n### Approach B: Config-Based Export\nExport from declarative config or saved snapshot:\n```bash\nsd export-script --profile work  # Export from saved profile\nsd export-script --config work.yaml  # Export from config file\n```\n- Pro: Persistent, accurate\n- Con: Requires config system\n\n### Recommended: Support Both\n1. Session history for `sd export-script` (current session)\n2. Config-based for `sd export-script --profile <name>`\n\n## Implementation Approach\n\n### Phase 1: Session History Tracking\n```rust\n// In src/state.rs (new file, shared with SAVE-RESTORE)\nuse std::sync::Mutex;\nuse once_cell::sync::Lazy;\n\nstatic SESSION_STATE: Lazy<Mutex<SessionState>> = Lazy::new(|| {\n    Mutex::new(SessionState::default())\n});\n\n#[derive(Default)]\npub struct SessionState {\n    pub brightness: Option<u8>,\n    pub keys: HashMap<u8, KeyState>,\n}\n\npub enum KeyState {\n    Image(PathBuf),\n    Color(String),\n    Cleared,\n}\n\nimpl SessionState {\n    pub fn record_brightness(&mut self, level: u8) {\n        self.brightness = Some(level);\n    }\n    \n    pub fn record_set_key(&mut self, key: u8, path: PathBuf) {\n        self.keys.insert(key, KeyState::Image(path));\n    }\n    \n    pub fn record_fill_key(&mut self, key: u8, color: String) {\n        self.keys.insert(key, KeyState::Color(color));\n    }\n    \n    pub fn record_clear_key(&mut self, key: u8) {\n        self.keys.insert(key, KeyState::Cleared);\n    }\n}\n\n// Call from command handlers\npub fn track_brightness(level: u8) {\n    SESSION_STATE.lock().unwrap().record_brightness(level);\n}\n```\n\n### Phase 2: Export Command\n```rust\n// In src/cli/mod.rs\nExportScript {\n    /// Embed images as base64 (makes script self-contained)\n    #[arg(long)]\n    embed_images: bool,\n    \n    /// Export from saved profile instead of session\n    #[arg(long)]\n    profile: Option<String>,\n    \n    /// Output format\n    #[arg(long, default_value = \"bash\")]\n    format: ExportFormat,\n}\n\n#[derive(ValueEnum, Clone)]\nenum ExportFormat {\n    Bash,\n    Fish,\n    PowerShell,\n    Makefile,\n}\n\n// In main.rs\nfn cmd_export_script(opts: ExportOptions) -> Result<()> {\n    let state = if let Some(profile) = &opts.profile {\n        load_profile_state(profile)?\n    } else {\n        SESSION_STATE.lock().unwrap().clone()\n    };\n    \n    let script = generate_script(&state, &opts)?;\n    println!(\"{}\", script);\n    Ok(())\n}\n\nfn generate_script(state: &SessionState, opts: &ExportOptions) -> String {\n    let mut lines = vec![\n        \"#!/bin/bash\".to_string(),\n        format!(\"# Stream Deck configuration exported by sd\"),\n        format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()),\n        \"\".to_string(),\n        \"set -e\".to_string(),\n        \"\".to_string(),\n    ];\n    \n    if let Some(brightness) = state.brightness {\n        lines.push(format!(\"sd brightness {}\", brightness));\n    }\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => {\n                if opts.embed_images {\n                    let b64 = base64_encode_image(path)?;\n                    lines.push(format!(\n                        \"echo \\\"{}\\\" | base64 -d | sd set-key {} -\",\n                        b64, key\n                    ));\n                } else {\n                    lines.push(format!(\"sd set-key {} \\\"{}\\\"\", key, path.display()));\n                }\n            }\n            KeyState::Color(color) => {\n                lines.push(format!(\"sd fill-key {} \\\"{}\\\"\", key, color));\n            }\n            KeyState::Cleared => {\n                lines.push(format!(\"sd clear-key {}\", key));\n            }\n        }\n    }\n    \n    lines.push(\"\".to_string());\n    lines.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    lines.join(\"\\n\")\n}\n```\n\n## Key Design Decisions\n1. **Shell script default**: Most portable, universally understood\n2. **Absolute paths**: Avoid relative path confusion\n3. **Embed option**: Self-contained scripts for sharing\n4. **Multiple formats**: Bash, Fish, PowerShell for cross-platform\n5. **set -e**: Fail fast on errors\n\n## Success Criteria\n- [ ] Session commands are tracked in memory\n- [ ] `sd export-script` generates valid bash script\n- [ ] Generated script reproduces device state when run\n- [ ] `--embed-images` creates self-contained script\n- [ ] `--profile` exports from saved profile\n- [ ] Multiple output formats supported\n- [ ] Robot mode outputs structured JSON instead of script\n\n## Files to Create/Modify\n- `src/state.rs`: New session state tracking (shared with SAVE-RESTORE)\n- `src/cli/mod.rs`: Add ExportScript command\n- `src/main.rs`: Add state tracking calls, implement export\n- All command handlers: Add state tracking calls\n\n## Dependencies\n- Shares state tracking with SAVE-RESTORE epic\n- Benefits from DECLARATIVE-CONFIG for profile-based export\n\n## Estimated Subtasks\n1. Implement SessionState struct\n2. Add state tracking to all mutating commands\n3. Implement basic bash export\n4. Add --embed-images with base64 encoding\n5. Add --profile support (requires saved profiles)\n6. Add Fish output format\n7. Add PowerShell output format\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:57.831756849Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.230684166Z","compaction_level":0,"original_size":0,"labels":["backup","priority-10","reproducibility","sharing"],"dependencies":[{"issue_id":"bd-1q4","depends_on_id":"bd-34i","type":"blocks","created_at":"2026-01-19T18:23:22.230653178Z","created_by":"ubuntu"}]}
{"id":"bd-1q8","title":"Implement batch application loop","description":"Implement the main loop that:\n1. Iterates over matched key-file pairs\n2. Calls existing set_key_image for each\n3. Collects results (success/failure per key)\n4. Respects continue_on_error flag\n\nReuse existing image loading and device communication code.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.335879502Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.356993646Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1q8","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.356950264Z","created_by":"ubuntu"}]}
{"id":"bd-1r4","title":"EPIC: Declarative YAML/TOML Configuration","description":"## Overview\n**Rank: #7 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDefine device state in human-readable configuration files instead of imperative commands.\n\n## Problem Statement\nThe current CLI is imperative: users run commands to change state. This has limitations:\n- No single source of truth for desired configuration\n- Cant version control device setup\n- Cant easily share configurations\n- Cant diff or merge configurations\n- No way to declare \"this is what I want\" and have the tool figure out how to get there\n\n## Solution\nDeclarative configuration files in YAML or TOML:\n```yaml\n# ~/.config/sd/profiles/work.yaml\nname: Work Mode\nbrightness: 80\n\nkeys:\n  # Individual keys\n  0:\n    image: ~/icons/chrome.png\n    label: Browser  # Optional text overlay (future)\n  \n  1:\n    image: ~/icons/slack.png\n  \n  2:\n    color: \"#FF5500\"\n  \n  # Ranges with patterns\n  8-15:\n    pattern: ~/icons/apps/{index}.png\n  \n  # Rows\n  row-3:\n    color: \"#333333\"  # Fill entire row with color\n```\n\nUsage:\n```bash\nsd apply work.yaml           # Apply configuration\nsd apply work                # Apply from ~/.config/sd/profiles/work.yaml\nsd diff work.yaml            # Show what would change\nsd validate work.yaml        # Check configuration is valid\n```\n\n## Why This Is #7 Priority\n1. **Desired-state model**: Declare what you want, not how to get there\n2. **Version controllable**: Check your config into git\n3. **Composable**: Layer configs, override specific keys\n4. **Human-readable**: YAML/TOML are familiar and editable\n5. **Foundation for other features**: Hot-reload, profiles, etc.\n\n## Configuration Schema Design\n\n### YAML Format (Preferred for Readability)\n```yaml\n# Profile metadata\nname: My Profile\ndescription: Optional description\nbrightness: 80\n\n# Key definitions\nkeys:\n  # Explicit key index\n  0:\n    image: /absolute/path/to/image.png\n  \n  # Relative path (resolved from config file location)\n  1:\n    image: ./icons/slack.png\n  \n  # Home directory expansion\n  2:\n    image: ~/stream-deck/chrome.png\n  \n  # Solid color (hex)\n  3:\n    color: \"#FF5500\"\n  \n  # RGB color\n  4:\n    color: [255, 85, 0]\n  \n  # Clear key explicitly\n  5:\n    clear: true\n  \n  # Range with pattern\n  8-15:\n    pattern: ~/icons/row2/{index}.png\n    # Expands to: row2/08.png, row2/09.png, etc.\n  \n  # Named row (device-specific mapping)\n  row-0:\n    color: \"#222222\"  # Fill entire row\n  \n  # All remaining keys\n  default:\n    color: \"#000000\"  # Black background for unspecified keys\n\n# Optional: Device targeting\ndevice:\n  model: StreamDeckXL  # Only apply to this model\n  serial: ABC123       # Only apply to this serial\n```\n\n### TOML Format (Alternative)\n```toml\nname = \"My Profile\"\nbrightness = 80\n\n[keys.0]\nimage = \"~/icons/chrome.png\"\n\n[keys.1]\ncolor = \"#FF5500\"\n\n[keys.\"8-15\"]\npattern = \"~/icons/row2/{index}.png\"\n```\n\n## Implementation Approach\n\n### Phase 1: Schema Definition and Parsing\n```rust\n// In src/config/declarative.rs (new file)\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ProfileConfig {\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub brightness: Option<u8>,\n    pub keys: HashMap<KeySelector, KeyConfig>,\n    pub device: Option<DeviceFilter>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum KeySelector {\n    Single(u8),           // \"0\", \"15\"\n    Range(u8, u8),        // \"8-15\"\n    Row(u8),              // \"row-0\"\n    Default,              // \"default\"\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum KeyConfig {\n    Image { image: PathBuf },\n    Pattern { pattern: String },\n    Color { color: ColorSpec },\n    Clear { clear: bool },\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum ColorSpec {\n    Hex(String),          // \"#FF5500\"\n    Rgb([u8; 3]),         // [255, 85, 0]\n}\n```\n\n### Phase 2: Config Resolution\n```rust\nimpl ProfileConfig {\n    /// Resolve all selectors and patterns to concrete key assignments\n    pub fn resolve(&self, device: &DeviceInfo) -> Result<ResolvedProfile> {\n        let mut keys = HashMap::new();\n        \n        for (selector, config) in &self.keys {\n            let indices = selector.resolve(device)?;\n            for index in indices {\n                let resolved = config.resolve_for_key(index)?;\n                keys.insert(index, resolved);\n            }\n        }\n        \n        Ok(ResolvedProfile {\n            brightness: self.brightness,\n            keys,\n        })\n    }\n}\n```\n\n### Phase 3: Apply Logic\n```rust\nfn cmd_apply(device: &Device, config_path: &Path) -> Result<()> {\n    let config = load_config(config_path)?;\n    let resolved = config.resolve(device.info())?;\n    \n    // Apply brightness if specified\n    if let Some(brightness) = resolved.brightness {\n        device.set_brightness(brightness)?;\n    }\n    \n    // Apply keys\n    for (index, key_config) in &resolved.keys {\n        match key_config {\n            ResolvedKey::Image(path) => set_key_image(device, *index, path)?,\n            ResolvedKey::Color(color) => fill_key_color(device, *index, color)?,\n            ResolvedKey::Clear => clear_key(device, *index)?,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **YAML primary, TOML supported**: YAML is more readable for this use case\n2. **Flexible selectors**: Support individual keys, ranges, rows, and defaults\n3. **Pattern expansion**: `{index}` placeholder for batch definitions\n4. **Path resolution**: Support absolute, relative, and ~ paths\n5. **Device filtering**: Configs can target specific devices\n6. **Additive application**: Only touch keys that are specified\n\n## Diff and Validate Commands\n```bash\nsd diff work.yaml\n# Output:\n# Key 0: (empty) → ~/icons/chrome.png\n# Key 1: ~/icons/old.png → ~/icons/slack.png\n# Key 2: (no change)\n# Brightness: 50 → 80\n\nsd validate work.yaml\n# Output:\n# ✓ Valid YAML syntax\n# ✓ All image paths exist\n# ✓ All color values valid\n# ✓ Key indices within device range\n# ⚠ Key 33 out of range for Stream Deck XL (0-31)\n```\n\n## Success Criteria\n- [ ] YAML configuration files parsed correctly\n- [ ] TOML configuration files parsed correctly\n- [ ] Key selectors (single, range, row) resolve correctly\n- [ ] Pattern expansion works with {index} placeholder\n- [ ] Path expansion (~, relative) works correctly\n- [ ] `sd apply <config>` applies configuration to device\n- [ ] `sd validate <config>` checks configuration validity\n- [ ] `sd diff <config>` shows what would change\n- [ ] Robot mode returns structured JSON\n\n## Files to Create/Modify\n- `src/config/declarative.rs`: New module for declarative config\n- `src/cli/mod.rs`: Add Apply, Validate, Diff commands\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- Soft: ELGATO-IMPORT can generate declarative configs\n- Soft: SAVE-RESTORE can use declarative configs as storage format\n\n## Estimated Subtasks\n1. Design and document config schema\n2. Implement KeySelector parsing and resolution\n3. Implement KeyConfig parsing\n4. Implement path resolution (absolute, relative, ~)\n5. Implement pattern expansion\n6. Implement config loading (YAML + TOML)\n7. Implement apply command\n8. Implement validate command\n9. Implement diff command\n10. Write comprehensive tests","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:43.071432352Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:43.111176112Z","compaction_level":0,"original_size":0,"labels":["config","declarative","priority-7","user-experience"]}
{"id":"bd-1rhq","title":"Phase 3: Main.rs Integration and Wiring","description":"# Phase 3: Main.rs Integration and Wiring\n\n## Purpose\nWire up the new output system into main.rs, replacing scattered output logic with unified trait-based dispatch. This is the culmination of the architectural work - where everything comes together.\n\n## Background\nAfter Phase 1 (infrastructure) and Phase 2 (command implementations), we have:\n- Output trait with RobotOutput and HumanOutput implementations\n- Detailed formatting for all output types\n- Theme system for consistent styling\n\nPhase 3 connects these pieces to the actual CLI command dispatch.\n\n## Deliverables\n1. Refactored main.rs using OutputMode and Output trait\n2. Each command function updated to accept &dyn Output\n3. Removal of direct println! calls for output\n4. Removal of colored crate dependency\n\n## Architecture After Integration\n```\nmain() \n  → parse CLI args\n  → create OutputMode (robot or human)\n  → get Box<dyn Output>\n  → run(cli, output)\n      → match command\n          → cmd_list(cli, args, output)\n          → cmd_info(cli, output)\n          → cmd_brightness(cli, args, output)\n          → ...\n      → output.error(e) on failure\n```\n\n## Success Criteria\n- [ ] All output flows through Output trait\n- [ ] Robot mode produces identical JSON to before\n- [ ] Human mode produces beautiful styled output\n- [ ] No direct println! for user-facing output\n- [ ] colored crate removed from Cargo.toml\n- [ ] All tests pass\n- [ ] cargo clippy clean","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:08:31.378087425Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:31.417017362Z","compaction_level":0,"original_size":0,"labels":["integration","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-1rhq","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:08:31.411390127Z","created_by":"ubuntu"},{"issue_id":"bd-1rhq","depends_on_id":"bd-533","type":"blocks","created_at":"2026-01-19T21:08:31.416984520Z","created_by":"ubuntu"}]}
{"id":"bd-1rm","title":"Integrate hook execution into watch loop","description":"Modify watch command handler:\n1. Load keymap if specified\n2. On each event, resolve command\n3. Substitute placeholders\n4. Execute if command found\n5. Continue watching\n\nPriority: keymap > on-press/on-release > exec","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.736317029Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.751530874Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1rm","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.751477624Z","created_by":"ubuntu"}]}
{"id":"bd-1sb","title":"Add multi-line support","description":"Handle newlines in text:\n- Split on \\\\n\n- Calculate line height (font_size * 1.2)\n- Render each line\n- Adjust vertical positioning\n\nExample: sd text-key 0 \"Line 1\\\\nLine 2\"","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.397910630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:17.408254937Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1sb","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.408193742Z","created_by":"ubuntu"}]}
{"id":"bd-1sl","title":"EPIC: Dynamic Text Overlay on Images","description":"## Overview\n**Rank: #15 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nGenerate key images with text labels programmatically, without external image editing.\n\n## Problem Statement\nMost Stream Deck keys need labels. Currently users must:\n- Create images externally with text baked in\n- Use image editing software for simple text\n- Maintain separate image files for each variation\n- Manually update when text needs to change\n\nThis is especially painful for:\n- Dynamic content (build status, counters, time)\n- Localization (different languages)\n- AI agents that can generate text but not images\n\n## Solution\nText rendering commands and options:\n```bash\n# Text-only key (auto-generated background)\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n\n# Text overlay on existing image\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n\n# Multi-line text\nsd text-key 0 \"Line 1\\nLine 2\" --font-size 18\n\n# Dynamic text in declarative config\nkeys:\n  0:\n    image: ~/icons/cpu.png\n    text: \"${CPU_USAGE}%\"\n    text_position: center\n    text_color: white\n```\n\n## Why This Is #15 Priority\n1. **Font complexity**: Text rendering requires font handling\n2. **Platform differences**: Font availability varies by OS\n3. **Scope creep risk**: Leads toward full image editor\n4. **Medium effort**: ~150 lines plus dependencies\n5. **Workaround exists**: External image editing works today\n\n## Implementation Approach\n\n### Font Handling Strategy\nOptions:\n1. **Bundled font**: Include a single font (e.g., Inter, Roboto) in binary\n2. **System fonts**: Use fontconfig to find system fonts\n3. **User-specified**: `--font /path/to/font.ttf`\n\nRecommended: Bundle one good font, allow override.\n\n### Text Rendering with imageproc\n```rust\n// Add to Cargo.toml\n[dependencies]\nimageproc = \"0.23\"\nrusttype = \"0.9\"\n\n// Or use ab_glyph (more modern)\nab_glyph = \"0.2\"\n\n// In src/text.rs (new file)\nuse ab_glyph::{FontRef, PxScale};\nuse image::{Rgba, RgbaImage};\nuse imageproc::drawing::draw_text_mut;\n\npub struct TextOverlay {\n    pub text: String,\n    pub font_size: f32,\n    pub color: Rgba<u8>,\n    pub position: TextPosition,\n    pub font: Option<PathBuf>,\n}\n\npub enum TextPosition {\n    Top,\n    Center,\n    Bottom,\n    Custom { x: i32, y: i32 },\n}\n\n// Bundled font (embedded in binary)\nconst BUNDLED_FONT: &[u8] = include_bytes\\!(\"../assets/Inter-Regular.ttf\");\n\npub fn render_text_key(\n    width: u32,\n    height: u32,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = RgbaImage::from_pixel(width, height, opts.background);\n    \n    let font_data = opts.font\n        .as_ref()\n        .map(|p| std::fs::read(p).unwrap())\n        .unwrap_or_else(|| BUNDLED_FONT.to_vec());\n    \n    let font = FontRef::try_from_slice(&font_data).unwrap();\n    let scale = PxScale::from(opts.font_size);\n    \n    let (text_width, text_height) = measure_text(&font, scale, text);\n    let (x, y) = calculate_position(\n        width, height, \n        text_width, text_height, \n        &opts.position\n    );\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\npub fn overlay_text_on_image(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = base.clone();\n    \n    // Similar to render_text_key but overlays on existing image\n    let font = load_font(&opts.font)?;\n    let scale = PxScale::from(opts.font_size);\n    \n    let (x, y) = calculate_position(\n        img.width(), img.height(),\n        measure_text(&font, scale, text),\n        &opts.position\n    );\n    \n    // Optional: draw background rectangle for readability\n    if opts.text_background {\n        draw_filled_rect_mut(&mut img, text_rect, opts.text_bg_color);\n    }\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\nfn calculate_position(\n    img_w: u32, img_h: u32,\n    text_w: u32, text_h: u32,\n    position: &TextPosition,\n) -> (i32, i32) {\n    match position {\n        TextPosition::Top => ((img_w - text_w) / 2, 2),\n        TextPosition::Center => ((img_w - text_w) / 2, (img_h - text_h) / 2),\n        TextPosition::Bottom => ((img_w - text_w) / 2, img_h - text_h - 2),\n        TextPosition::Custom { x, y } => (*x, *y),\n    }\n}\n```\n\n### CLI Integration\n```rust\n// In src/cli/mod.rs\nTextKey {\n    /// Key index (0-31)\n    key: u8,\n    /// Text to display\n    text: String,\n    /// Font size in pixels\n    #[arg(long, default_value = \"24\")]\n    font_size: f32,\n    /// Text color (hex)\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n    /// Background color (hex)\n    #[arg(long, default_value = \"#333333\")]\n    bg_color: String,\n    /// Text position (top, center, bottom)\n    #[arg(long, default_value = \"center\")]\n    position: TextPosition,\n    /// Custom font file path\n    #[arg(long)]\n    font: Option<PathBuf>,\n}\n\n// Add --text flag to SetKey\nSetKey {\n    key: u8,\n    image: PathBuf,\n    /// Overlay text on image\n    #[arg(long)]\n    text: Option<String>,\n    /// Text position for overlay\n    #[arg(long, default_value = \"bottom\")]\n    text_position: TextPosition,\n    /// Text color for overlay\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n}\n```\n\n## Key Design Decisions\n1. **Bundle one font**: Guaranteed availability, no system dependency\n2. **Allow font override**: Power users can specify custom fonts\n3. **Simple positioning**: Top/center/bottom covers 95% of use cases\n4. **Optional background**: Text background for readability on busy images\n5. **Hex colors**: Consistent with fill-key command\n\n## Multi-Line Text Support\n```rust\nfn render_multiline(text: &str, opts: &TextOverlay) -> RgbaImage {\n    let lines: Vec<&str> = text.split(n).collect();\n    let line_height = opts.font_size * 1.2;  // 120% line height\n    \n    // Calculate total height\n    let total_height = lines.len() as f32 * line_height;\n    \n    // Render each line\n    for (i, line) in lines.iter().enumerate() {\n        let y = start_y + (i as f32 * line_height);\n        draw_text_mut(&mut img, opts.color, x, y as i32, scale, &font, line);\n    }\n}\n```\n\n## Success Criteria\n- [ ] `sd text-key` creates text-only key images\n- [ ] `sd set-key --text` overlays text on images\n- [ ] Bundled font works on all platforms\n- [ ] Custom font via --font flag\n- [ ] Text positioning (top, center, bottom)\n- [ ] Hex color support for text and background\n- [ ] Multi-line text support\n- [ ] Robot mode reports text rendering details\n\n## Files to Create/Modify\n- `Cargo.toml`: Add ab_glyph, imageproc dependencies\n- `assets/Inter-Regular.ttf`: Bundled font file\n- `src/text.rs`: New text rendering module\n- `src/cli/mod.rs`: Add TextKey command, --text flag to SetKey\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- None (standalone feature)\n\n## Estimated Subtasks\n1. Add font rendering dependencies\n2. Obtain and bundle Inter font (OFL licensed)\n3. Implement basic text rendering\n4. Implement text positioning\n5. Implement text overlay on images\n6. Add text-key command\n7. Add --text flag to set-key\n8. Add multi-line support\n9. Test on different platforms\n10. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:55.996344390Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:56.029651662Z","compaction_level":0,"original_size":0,"labels":["generation","images","priority-15","text"]}
{"id":"bd-1ur","title":"Design and document config schema","description":"Create formal schema documentation:\n- YAML structure with all supported fields\n- Key selector syntax (single, range, row, default)\n- Color formats (hex, RGB array)\n- Path resolution rules (absolute, relative, ~)\n- Pattern expansion ({index} placeholder)\n\nThis is a DESIGN task - produces documentation.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.473608969Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:55.487887883Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ur","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.487834763Z","created_by":"ubuntu"}]}
{"id":"bd-1uz","title":"Add global --dry-run flag to CLI","description":"## Add Global CLI Flags\n\n### Complete Global Flags (src/cli/mod.rs)\n\n```rust\n#[derive(Parser, Debug)]\n#[command(name = \"sd\", version, about = \"Stream Deck CLI\")]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Command,\n\n    // === Output Control ===\n    \n    /// Output format: human or json\n    #[arg(long, short = 'f', global = true, value_enum, default_value = \"human\")]\n    pub format: OutputFormat,\n\n    /// Alias for --format=json (machine-readable output)\n    #[arg(long, short = 'r', global = true)]\n    pub robot: bool,\n\n    /// Preview what would happen without making changes\n    #[arg(long, short = 'n', global = true)]\n    pub dry_run: bool,\n\n    // === Verbosity ===\n    \n    /// Increase logging verbosity (-v = debug, -vv = trace)\n    #[arg(long, short = 'v', global = true, action = ArgAction::Count)]\n    pub verbose: u8,\n\n    /// Suppress non-error output\n    #[arg(long, short = 'q', global = true)]\n    pub quiet: bool,\n\n    // === Color Control ===\n    \n    /// Control color output: auto, always, never\n    #[arg(long, global = true, value_enum, default_value = \"auto\")]\n    pub color: ColorChoice,\n\n    // === Device Selection ===\n    \n    /// Select device by serial number\n    #[arg(long, short = 's', global = true)]\n    pub serial: Option<String>,\n\n    /// Select device by index (if multiple connected)\n    #[arg(long, short = 'd', global = true)]\n    pub device: Option<usize>,\n\n    // === Configuration ===\n    \n    /// Config directory (default: ~/.config/sd)\n    #[arg(long, global = true, env = \"SD_CONFIG_DIR\")]\n    pub config_dir: Option<PathBuf>,\n\n    /// Cache directory (default: ~/.cache/sd)\n    #[arg(long, global = true, env = \"SD_CACHE_DIR\")]\n    pub cache_dir: Option<PathBuf>,\n}\n\n#[derive(ValueEnum, Clone, Debug, Default)]\npub enum OutputFormat {\n    #[default]\n    Human,\n    Json,\n}\n\n#[derive(ValueEnum, Clone, Debug, Default)]\npub enum ColorChoice {\n    #[default]\n    Auto,\n    Always,\n    Never,\n}\n```\n\n### Flag Validation\n\n```rust\nimpl Cli {\n    pub fn validate(&self) -> Result<()> {\n        // Can't be quiet and verbose at the same time\n        if self.quiet && self.verbose > 0 {\n            return Err(CliError::ConflictingFlags(\"--quiet and --verbose\"));\n        }\n        \n        // Robot mode implies JSON format\n        // (handled by merging robot into format)\n        \n        Ok(())\n    }\n    \n    pub fn effective_format(&self) -> OutputFormat {\n        if self.robot {\n            OutputFormat::Json\n        } else {\n            self.format.clone()\n        }\n    }\n    \n    pub fn should_use_color(&self) -> bool {\n        match self.color {\n            ColorChoice::Always => true,\n            ColorChoice::Never => false,\n            ColorChoice::Auto => {\n                std::io::stdout().is_terminal() && \n                std::env::var(\"NO_COLOR\").is_err()\n            }\n        }\n    }\n}\n```\n\n### Environment Variable Support\n\n| Flag | Environment Variable | Description |\n|------|---------------------|-------------|\n| `--config-dir` | `SD_CONFIG_DIR` | Config directory |\n| `--cache-dir` | `SD_CACHE_DIR` | Cache directory |\n| `--color` | `NO_COLOR` | Disable color (if set) |\n| N/A | `RUST_LOG` | Logging level |\n\n### Help Text Integration\n\n```\nsd 0.1.0\nStream Deck CLI - Control your Elgato Stream Deck\n\nUSAGE:\n    sd [OPTIONS] <COMMAND>\n\nOPTIONS:\n    -f, --format <FORMAT>    Output format [default: human] [values: human, json]\n    -r, --robot              Machine-readable JSON output (same as --format=json)\n    -n, --dry-run            Preview changes without applying\n    -v, --verbose            Increase verbosity (-v, -vv)\n    -q, --quiet              Suppress non-error output\n        --color <WHEN>       Color output [default: auto] [values: auto, always, never]\n    -s, --serial <SERIAL>    Select device by serial number\n    -d, --device <INDEX>     Select device by index\n        --config-dir <DIR>   Config directory\n        --cache-dir <DIR>    Cache directory\n    -h, --help               Print help\n    -V, --version            Print version\n\nCOMMANDS:\n    list        List connected Stream Deck devices\n    info        Show device information\n    brightness  Set display brightness\n    ...\n```\n\n### Implementation Notes\n\n1. All global flags must be accessible in every command handler\n2. Robot mode (-r) should be shorthand for --format=json\n3. Verbose/quiet affect logging level via tracing initialization\n4. Color choice affects `colored` crate output\n5. Config/cache dirs should have XDG-compliant defaults","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.771173494Z","created_by":"ubuntu","updated_at":"2026-01-19T20:42:18.924419277Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1uz","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.800752005Z","created_by":"ubuntu"}]}
{"id":"bd-1v8","title":"EPIC: Gesture Support (Long-Press, Double-Tap)","description":"## Overview\n**Rank: #12 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nDetect and report gesture events beyond simple press/release: long-press, double-tap, and hold.\n\n## Problem Statement\nStream Deck has 32 keys (on XL model). Currently each key can only do one thing: trigger on press. Users want more actions without more keys:\n- Tap for quick action, long-press for settings\n- Double-tap for alternate action\n- Hold for continuous/repeated action\n\n## Solution\nEnhanced event detection in watch mode:\n```bash\nsd watch --gestures\n\n# Output includes gesture classification:\n{\"key\": 5, \"gesture\": \"tap\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"long_press\", \"duration_ms\": 1200}\n{\"key\": 5, \"gesture\": \"double_tap\", \"interval_ms\": 150}\n{\"key\": 5, \"gesture\": \"hold_start\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"hold_tick\", \"held_ms\": 500}\n{\"key\": 5, \"gesture\": \"hold_end\", \"total_ms\": 2500}\n```\n\nConfigurable thresholds:\n```bash\nsd watch --gestures \\\n  --long-press-ms 800 \\\n  --double-tap-ms 300 \\\n  --hold-tick-ms 100\n```\n\nIntegration with scripting hooks:\n```bash\nsd watch --gestures --keymap gestures.yaml\n```\n\n```yaml\n# gestures.yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: osascript -e \"tell Chrome to make new window\"\n  1:\n    tap: ~/scripts/toggle-mic.sh\n    hold: ~/scripts/push-to-talk.sh  # Runs while held\n```\n\n## Why This Is #12 Priority\n1. **Expressiveness**: 32 keys become 96+ possible actions\n2. **Standard UX pattern**: Users expect gesture support\n3. **Differentiator**: Most Stream Deck tools lack this\n4. **Moderate complexity**: State machine logic is fiddly\n5. **Subjective tuning**: \"Long press\" timing is personal preference\n\n## Implementation Approach\n\n### Gesture State Machine\n```rust\n// In src/gestures.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct GestureConfig {\n    pub long_press_threshold: Duration,   // Default: 800ms\n    pub double_tap_window: Duration,      // Default: 300ms\n    pub hold_tick_interval: Duration,     // Default: 100ms\n}\n\npub struct GestureDetector {\n    config: GestureConfig,\n    key_states: HashMap<u8, KeyGestureState>,\n}\n\nstruct KeyGestureState {\n    press_time: Option<Instant>,\n    last_tap_time: Option<Instant>,\n    is_held: bool,\n    last_tick: Option<Instant>,\n}\n\npub enum Gesture {\n    Tap { key: u8 },\n    DoubleTap { key: u8, interval: Duration },\n    LongPress { key: u8, duration: Duration },\n    HoldStart { key: u8 },\n    HoldTick { key: u8, held_for: Duration },\n    HoldEnd { key: u8, total: Duration },\n}\n\nimpl GestureDetector {\n    pub fn process_event(&mut self, event: &RawKeyEvent) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        let state = self.key_states.entry(event.key).or_default();\n        \n        match event.pressed {\n            true => {\n                // Key pressed\n                state.press_time = Some(Instant::now());\n                state.is_held = false;\n            }\n            false => {\n                // Key released\n                if let Some(press_time) = state.press_time.take() {\n                    let duration = press_time.elapsed();\n                    \n                    if duration >= self.config.long_press_threshold {\n                        // Long press\n                        gestures.push(Gesture::LongPress { \n                            key: event.key, \n                            duration \n                        });\n                    } else if state.is_held {\n                        // End of hold\n                        gestures.push(Gesture::HoldEnd {\n                            key: event.key,\n                            total: duration,\n                        });\n                    } else {\n                        // Potential tap or double-tap\n                        if let Some(last_tap) = state.last_tap_time {\n                            if last_tap.elapsed() < self.config.double_tap_window {\n                                gestures.push(Gesture::DoubleTap {\n                                    key: event.key,\n                                    interval: last_tap.elapsed(),\n                                });\n                                state.last_tap_time = None;\n                            } else {\n                                gestures.push(Gesture::Tap { key: event.key });\n                                state.last_tap_time = Some(Instant::now());\n                            }\n                        } else {\n                            state.last_tap_time = Some(Instant::now());\n                            // Defer tap emission until we know it is not double-tap\n                        }\n                    }\n                }\n                state.is_held = false;\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Call periodically to emit hold ticks and detect long-press during hold\n    pub fn tick(&mut self) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        \n        for (key, state) in &mut self.key_states {\n            if let Some(press_time) = state.press_time {\n                let held_for = press_time.elapsed();\n                \n                // Detect transition to hold\n                if !state.is_held && held_for >= self.config.long_press_threshold {\n                    state.is_held = true;\n                    gestures.push(Gesture::HoldStart { key: *key });\n                }\n                \n                // Emit hold ticks\n                if state.is_held {\n                    if state.last_tick.map(|t| t.elapsed() >= self.config.hold_tick_interval).unwrap_or(true) {\n                        gestures.push(Gesture::HoldTick { key: *key, held_for });\n                        state.last_tick = Some(Instant::now());\n                    }\n                }\n            }\n            \n            // Emit deferred taps (after double-tap window expires)\n            if let Some(last_tap) = state.last_tap_time {\n                if last_tap.elapsed() >= self.config.double_tap_window && state.press_time.is_none() {\n                    gestures.push(Gesture::Tap { key: *key });\n                    state.last_tap_time = None;\n                }\n            }\n        }\n        \n        gestures\n    }\n}\n```\n\n### Integration with Watch Loop\n```rust\nfn cmd_watch_with_gestures(device: &Device, opts: WatchOptions) -> Result<()> {\n    let mut detector = GestureDetector::new(GestureConfig {\n        long_press_threshold: Duration::from_millis(opts.long_press_ms),\n        double_tap_window: Duration::from_millis(opts.double_tap_ms),\n        hold_tick_interval: Duration::from_millis(opts.hold_tick_ms),\n    });\n    \n    loop {\n        // Check for raw events (short timeout)\n        if let Some(event) = device.read_input(Duration::from_millis(50))? {\n            let gestures = detector.process_event(&event);\n            for g in gestures {\n                emit_gesture(&g, opts.robot);\n            }\n        }\n        \n        // Process ticks for held keys and deferred events\n        let tick_gestures = detector.tick();\n        for g in tick_gestures {\n            emit_gesture(&g, opts.robot);\n        }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Deferred tap emission**: Wait for double-tap window before emitting tap\n2. **Hold distinct from long-press**: Long-press = released after threshold, Hold = still pressed\n3. **Configurable thresholds**: Personal preference varies widely\n4. **Tick-based detection**: Periodic polling for held key events\n5. **Backward compatible**: Without --gestures, behavior unchanged\n\n## Success Criteria\n- [ ] `--gestures` flag enables gesture detection\n- [ ] Tap events emitted after double-tap window\n- [ ] Double-tap detected within configurable window\n- [ ] Long-press detected on release after threshold\n- [ ] Hold events with periodic ticks while pressed\n- [ ] Threshold flags allow customization\n- [ ] Robot mode outputs structured gesture events\n- [ ] Keymap supports gesture-specific actions\n\n## Files to Create/Modify\n- `src/gestures.rs`: New gesture detection module\n- `src/cli/mod.rs`: Add gesture flags to Watch command\n- `src/main.rs`: Integrate gesture detector\n- `src/config/keymap.rs`: Add gesture-specific actions\n\n## Dependencies\n- Soft: Benefits from SCRIPTING-HOOKS (#8) for gesture-specific actions\n\n## Estimated Subtasks\n1. Design gesture state machine\n2. Implement GestureDetector struct\n3. Implement tap/double-tap detection with deferral\n4. Implement long-press detection\n5. Implement hold start/tick/end\n6. Add CLI flags for thresholds\n7. Integrate with watch loop\n8. Add keymap gesture support\n9. Write tests for edge cases","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:11.972191367Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.327002495Z","compaction_level":0,"original_size":0,"labels":["expressiveness","input","priority-12","watch"],"dependencies":[{"issue_id":"bd-1v8","depends_on_id":"bd-156","type":"blocks","created_at":"2026-01-19T18:23:22.326971206Z","created_by":"ubuntu"}]}
{"id":"bd-1vw","title":"Phase 1: Foundation Infrastructure","description":"# Phase 1: Foundation Infrastructure\n\n## Purpose\nEstablish the core architectural foundation for the rich_rust integration. This phase creates the abstraction layers that enable clean separation between robot mode (JSON) and human mode (styled output).\n\n## Why This Phase Comes First\nAll subsequent work depends on having:\n1. The rich_rust dependency available\n2. The Output trait abstraction in place\n3. The theme system for consistent styling\n4. The basic RobotOutput and HumanOutput implementations\n\nWithout this foundation, command implementations would have no consistent API to target.\n\n## Deliverables\n1. Cargo.toml updated with rich_rust dependency\n2. src/output/mod.rs with OutputMode enum and Output trait\n3. src/output/robot.rs with RobotOutput (refactored existing logic)\n4. src/output/human.rs with HumanOutput skeleton\n5. src/theme/mod.rs with SdTheme and color constants\n\n## Architectural Context\n\n### Output Trait\nThe Output trait defines a common interface for all output operations:\n- success(message) - Success messages\n- error(SdError) - Error display with suggestions\n- warning(message) - Warning messages\n- info(message) - Informational messages\n- device_list(devices) - Device listing\n- device_info(info) - Single device details\n- button_event(event) - Button press/release events\n- brightness_set(level) - Brightness confirmation\n- key_set(key, image) - Key image set confirmation\n- key_cleared(key) - Key clear confirmation\n- all_cleared() - All keys cleared confirmation\n- version_info(info) - Version display\n- rule(title) - Horizontal divider\n\n### OutputMode Enum\n```rust\npub enum OutputMode {\n    Robot(RobotFormat),\n    Human(Console),\n}\n```\n\nThis enum is created from CLI flags and passed to command handlers.\n\n### Theme System\nThe SdTheme struct provides consistent colors and styles:\n- Brand colors (accent, success, error, warning, muted)\n- Component styles (header, label, value, key_index, etc.)\n- Box style selection\n\n## Success Criteria\n- Output module compiles without errors\n- Existing robot mode behavior unchanged\n- Theme colors render correctly in 24-bit terminals\n- Foundation ready for command implementations","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-19T21:02:13.251951751Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:13.294044223Z","compaction_level":0,"original_size":0,"labels":["infrastructure","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-1vw","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:02:13.293964082Z","created_by":"ubuntu"}]}
{"id":"bd-1xd","title":"Implement RobotOutput for JSON output (refactor existing)","description":"# Implement RobotOutput for JSON output (refactor existing)\n\n## Purpose\nRefactor existing JSON output logic into a dedicated RobotOutput struct that implements the Output trait. This is a CRITICAL task because robot mode must remain UNCHANGED - AI agents depend on the exact JSON format.\n\n## Background\n\n### Why This Matters\nThe primary users of sd are AI coding agents. They parse JSON output programmatically. ANY change to the JSON structure could break agent workflows. This refactor must be behavior-preserving.\n\n### Current State\nThe current main.rs has JSON output scattered through match arms:\n```rust\nif cli.use_json() {\n    println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n} else {\n    // human output\n}\n```\n\n### Target State\n```rust\n// In command function\noutput.device_list(&devices);  // Output trait method\n\n// RobotOutput implementation\nfn device_list(&self, devices: &[DeviceInfo]) {\n    self.output_json(devices);\n}\n```\n\n## Technical Details\n\n### RobotOutput Struct (src/output/robot.rs)\n```rust\nuse serde::Serialize;\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse super::{Output, RobotFormat};\nuse std::path::Path;\n\n/// JSON output implementation for AI agents and scripting\n/// \n/// CRITICAL: This implementation must produce IDENTICAL output to the\n/// current behavior. Any changes to JSON structure will break agents.\npub struct RobotOutput {\n    format: RobotFormat,\n}\n\nimpl RobotOutput {\n    pub fn new(format: RobotFormat) -> Self {\n        Self { format }\n    }\n    \n    /// Internal helper to output any serializable data as JSON\n    fn output_json<T: Serialize>(&self, data: &T) {\n        let json = match self.format {\n            RobotFormat::Json => serde_json::to_string_pretty(data)\n                .expect(\"serialization failed\"),\n            RobotFormat::JsonCompact => serde_json::to_string(data)\n                .expect(\"serialization failed\"),\n        };\n        println!(\"{json}\");\n    }\n    \n    /// Output single-line JSON (for streaming events)\n    fn output_json_line<T: Serialize>(&self, data: &T) {\n        let json = serde_json::to_string(data).expect(\"serialization failed\");\n        println!(\"{json}\");\n    }\n}\n```\n\n### Error Response Structure\n```rust\n/// JSON structure for error responses\n/// MUST match current format exactly\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: bool,\n    message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    suggestion: Option<String>,\n    recoverable: bool,\n}\n```\n\n### Output Trait Implementation\n```rust\nimpl Output for RobotOutput {\n    fn success(&self, message: &str) {\n        self.output_json(&serde_json::json!({\n            \"success\": true,\n            \"message\": message\n        }));\n    }\n    \n    fn error(&self, error: &SdError) {\n        self.output_json(&ErrorResponse {\n            error: true,\n            message: error.to_string(),\n            suggestion: error.suggestion().map(String::from),\n            recoverable: error.is_user_recoverable(),\n        });\n    }\n    \n    fn warning(&self, message: &str) {\n        self.output_json(&serde_json::json!({\n            \"warning\": true,\n            \"message\": message\n        }));\n    }\n    \n    fn info(&self, message: &str) {\n        self.output_json(&serde_json::json!({\n            \"info\": true,\n            \"message\": message\n        }));\n    }\n    \n    fn device_list(&self, devices: &[DeviceInfo]) {\n        // Direct serialization - DeviceInfo already derives Serialize\n        self.output_json(devices);\n    }\n    \n    fn device_info(&self, info: &DeviceInfo) {\n        self.output_json(info);\n    }\n    \n    fn button_event(&self, event: &ButtonEvent) {\n        // Single-line JSON for streaming (important for pipe consumers)\n        self.output_json_line(event);\n    }\n    \n    fn button_states(&self, states: &[bool]) {\n        self.output_json(states);\n    }\n    \n    fn brightness_set(&self, level: u8) {\n        self.output_json(&serde_json::json!({\n            \"brightness\": level,\n            \"ok\": true\n        }));\n    }\n    \n    fn key_set(&self, key: u8, image: &Path) {\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"image\": image.display().to_string(),\n            \"ok\": true\n        }));\n    }\n    \n    fn key_cleared(&self, key: u8) {\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"cleared\": true,\n            \"ok\": true\n        }));\n    }\n    \n    fn key_filled(&self, key: u8, color: &str) {\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"color\": color,\n            \"ok\": true\n        }));\n    }\n    \n    fn all_cleared(&self) {\n        self.output_json(&serde_json::json!({\n            \"all_cleared\": true,\n            \"ok\": true\n        }));\n    }\n    \n    fn all_filled(&self, color: &str) {\n        self.output_json(&serde_json::json!({\n            \"all_filled\": true,\n            \"color\": color,\n            \"ok\": true\n        }));\n    }\n    \n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n        self.output_json(&serde_json::json!({\n            \"version\": version,\n            \"git_sha\": git_sha,\n            \"build_time\": build_time\n        }));\n    }\n    \n    // Visual separators are no-ops in robot mode\n    fn rule(&self, _title: Option<&str>) {\n        // No-op: rules are visual-only\n    }\n    \n    fn newline(&self) {\n        // No-op: whitespace is visual-only\n    }\n}\n```\n\n## Verification Strategy\n\n### Before Refactor\nCapture current output for each command:\n```bash\nsd list --robot > /tmp/before_list.json\nsd info --robot > /tmp/before_info.json\n# ... etc\n```\n\n### After Refactor\nCompare output:\n```bash\nsd list --robot > /tmp/after_list.json\ndiff /tmp/before_list.json /tmp/after_list.json\n# Must be empty (no differences)\n```\n\n### Automated Tests\n```rust\n#[test]\nfn robot_device_list_format() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let devices = vec![mock_device_info()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    let parsed: Vec<DeviceInfo> = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed.len(), 1);\n    assert_eq!(parsed[0].serial, \"TEST123\");\n}\n\n#[test]\nfn robot_error_format() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let error = SdError::NoDevicesFound;\n    \n    let captured = capture_stdout(|| output.error(&error));\n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"error\"], true);\n    assert!(parsed[\"message\"].as_str().unwrap().contains(\"No\"));\n    assert!(parsed[\"suggestion\"].is_string());\n}\n```\n\n## Implementation Steps\n1. Create src/output/robot.rs\n2. Define RobotOutput struct with format field\n3. Define ErrorResponse and other helper structs\n4. Implement Output trait for RobotOutput\n5. Add regression tests comparing old vs new output\n6. Verify all JSON formats match exactly\n\n## Acceptance Criteria\n- [ ] RobotOutput implements all Output trait methods\n- [ ] JSON output is byte-for-byte identical to current behavior\n- [ ] Streaming events (button_event) use single-line JSON\n- [ ] Rule and newline are silent no-ops\n- [ ] Unit tests verify JSON structure\n- [ ] No ANSI codes ever appear in robot mode output","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:04.135537208Z","created_by":"ubuntu","updated_at":"2026-01-19T21:04:04.174069767Z","compaction_level":0,"original_size":0,"labels":["json","phase-1","rich-rust","robot-mode"],"dependencies":[{"issue_id":"bd-1xd","depends_on_id":"bd-1es","type":"blocks","created_at":"2026-01-19T21:04:04.174049018Z","created_by":"ubuntu"},{"issue_id":"bd-1xd","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:04:04.169371622Z","created_by":"ubuntu"}]}
{"id":"bd-1xp","title":"Add connection event emission for robot mode","description":"Emit JSON events for connection state changes:\n```json\n{\"event\": \"disconnected\", \"timestamp\": \"...\", \"reason\": \"usb_error\"}\n{\"event\": \"reconnecting\", \"attempt\": 1, \"delay_ms\": 2000}\n{\"event\": \"reconnected\", \"timestamp\": \"...\", \"downtime_ms\": 4500}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:25.780621064Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.792861450Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.792821745Z","created_by":"ubuntu"}]}
{"id":"bd-1xs","title":"Add --text flag to set-key","description":"Extend set-key command:\n```\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n```\n\nOverlays text on the provided image.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.841788169Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.852442359Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xs","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.852367277Z","created_by":"ubuntu"}]}
{"id":"bd-1xy","title":"Create E2E test harness with CLI helpers","description":"## Purpose\nBuild comprehensive infrastructure for end-to-end CLI testing with full output verification, timing assertions, and test isolation.\n\n## Implementation\n\n### Core CLI Runner\n```rust\n// tests/common/cli.rs\nuse std::process::{Command, Output, Stdio};\nuse std::time::{Duration, Instant};\nuse std::path::PathBuf;\nuse serde_json::Value;\nuse tempfile::TempDir;\n\n/// Configuration for CLI test runs\npub struct CliConfig {\n    pub timeout: Duration,\n    pub env_vars: Vec<(String, String)>,\n    pub working_dir: Option<PathBuf>,\n    pub stdin: Option<String>,\n}\n\nimpl Default for CliConfig {\n    fn default() -> Self {\n        Self {\n            timeout: Duration::from_secs(30),\n            env_vars: vec![],\n            working_dir: None,\n            stdin: None,\n        }\n    }\n}\n\n/// Main test runner for sd CLI\npub struct CliRunner {\n    binary_path: PathBuf,\n    config: CliConfig,\n}\n\nimpl CliRunner {\n    pub fn new() -> Self {\n        let binary = env!(\"CARGO_BIN_EXE_sd\");\n        Self {\n            binary_path: PathBuf::from(binary),\n            config: CliConfig::default(),\n        }\n    }\n    \n    pub fn with_timeout(mut self, timeout: Duration) -> Self {\n        self.config.timeout = timeout;\n        self\n    }\n    \n    pub fn with_env(mut self, key: &str, value: &str) -> Self {\n        self.config.env_vars.push((key.to_string(), value.to_string()));\n        self\n    }\n    \n    pub fn with_working_dir(mut self, dir: PathBuf) -> Self {\n        self.config.working_dir = Some(dir);\n        self\n    }\n    \n    /// Execute command and capture output\n    pub fn run(&self, args: &[&str]) -> CliResult {\n        let start = Instant::now();\n        \n        let mut cmd = Command::new(&self.binary_path);\n        cmd.args(args)\n           .stdout(Stdio::piped())\n           .stderr(Stdio::piped());\n        \n        // Apply environment variables\n        for (key, value) in &self.config.env_vars {\n            cmd.env(key, value);\n        }\n        \n        // Apply working directory\n        if let Some(ref dir) = self.config.working_dir {\n            cmd.current_dir(dir);\n        }\n        \n        let output = cmd.output().expect(\"Failed to execute command\");\n        let duration = start.elapsed();\n        \n        CliResult {\n            stdout: String::from_utf8_lossy(&output.stdout).to_string(),\n            stderr: String::from_utf8_lossy(&output.stderr).to_string(),\n            exit_code: output.status.code().unwrap_or(-1),\n            duration,\n            args: args.iter().map(|s| s.to_string()).collect(),\n        }\n    }\n    \n    /// Execute with --robot flag for JSON output\n    pub fn run_robot(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--robot\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n    \n    /// Execute with --dry-run flag\n    pub fn run_dry_run(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--dry-run\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n    \n    /// Execute with both --robot and --dry-run\n    pub fn run_robot_dry_run(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--robot\", \"--dry-run\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n}\n```\n\n### CLI Result with Fluent Assertions\n```rust\n/// Captured output from CLI execution\npub struct CliResult {\n    pub stdout: String,\n    pub stderr: String,\n    pub exit_code: i32,\n    pub duration: Duration,\n    pub args: Vec<String>,\n}\n\nimpl CliResult {\n    // Basic checks\n    pub fn success(&self) -> bool { self.exit_code == 0 }\n    \n    // Fluent assertions - all return &Self for chaining\n    pub fn assert_success(&self) -> &Self {\n        assert!(self.success(), \n            \"Command {:?} failed with exit code {}: {}\", \n            self.args, self.exit_code, self.stderr);\n        self\n    }\n    \n    pub fn assert_failure(&self) -> &Self {\n        assert!(!self.success(), \n            \"Command {:?} unexpectedly succeeded\", self.args);\n        self\n    }\n    \n    pub fn assert_exit_code(&self, expected: i32) -> &Self {\n        assert_eq!(self.exit_code, expected,\n            \"Expected exit code {}, got {} for {:?}\", \n            expected, self.exit_code, self.args);\n        self\n    }\n    \n    // Stdout assertions\n    pub fn assert_stdout_contains(&self, text: &str) -> &Self {\n        assert!(self.stdout.contains(text), \n            \"stdout does not contain \\\"{}\\\"\\nActual stdout:\\n{}\", \n            text, self.stdout);\n        self\n    }\n    \n    pub fn assert_stdout_not_contains(&self, text: &str) -> &Self {\n        assert!(!self.stdout.contains(text), \n            \"stdout unexpectedly contains \\\"{}\\\"\", text);\n        self\n    }\n    \n    pub fn assert_stdout_matches(&self, pattern: &str) -> &Self {\n        let re = regex::Regex::new(pattern).unwrap();\n        assert!(re.is_match(&self.stdout),\n            \"stdout does not match pattern \\\"{}\\\"\\nActual stdout:\\n{}\",\n            pattern, self.stdout);\n        self\n    }\n    \n    pub fn assert_stdout_is_empty(&self) -> &Self {\n        assert!(self.stdout.is_empty(),\n            \"Expected empty stdout, got: {}\", self.stdout);\n        self\n    }\n    \n    // Stderr assertions\n    pub fn assert_stderr_contains(&self, text: &str) -> &Self {\n        assert!(self.stderr.contains(text),\n            \"stderr does not contain \\\"{}\\\"\\nActual stderr:\\n{}\",\n            text, self.stderr);\n        self\n    }\n    \n    pub fn assert_stderr_is_empty(&self) -> &Self {\n        assert!(self.stderr.trim().is_empty(),\n            \"Expected empty stderr, got: {}\", self.stderr);\n        self\n    }\n    \n    // JSON assertions (for robot mode)\n    pub fn json(&self) -> Value {\n        serde_json::from_str(&self.stdout)\n            .expect(&format!(\"Failed to parse JSON from stdout:\\n{}\", self.stdout))\n    }\n    \n    pub fn assert_json_field(&self, json_pointer: &str, expected: &Value) -> &Self {\n        let json = self.json();\n        let actual = json.pointer(json_pointer)\n            .expect(&format!(\"JSON path {} not found in:\\n{}\", \n                json_pointer, serde_json::to_string_pretty(&json).unwrap()));\n        assert_eq!(actual, expected,\n            \"JSON field {} mismatch\", json_pointer);\n        self\n    }\n    \n    pub fn assert_json_field_exists(&self, json_pointer: &str) -> &Self {\n        let json = self.json();\n        assert!(json.pointer(json_pointer).is_some(),\n            \"JSON path {} not found\", json_pointer);\n        self\n    }\n    \n    pub fn assert_json_array_len(&self, json_pointer: &str, expected_len: usize) -> &Self {\n        let json = self.json();\n        let arr = json.pointer(json_pointer)\n            .expect(&format!(\"JSON path {} not found\", json_pointer))\n            .as_array()\n            .expect(&format!(\"JSON path {} is not an array\", json_pointer));\n        assert_eq!(arr.len(), expected_len,\n            \"Array at {} has {} elements, expected {}\", \n            json_pointer, arr.len(), expected_len);\n        self\n    }\n    \n    // Timing assertions\n    pub fn assert_duration_under(&self, max: Duration) -> &Self {\n        assert!(self.duration < max,\n            \"Command took {:?}, expected under {:?}\", self.duration, max);\n        self\n    }\n    \n    pub fn assert_duration_over(&self, min: Duration) -> &Self {\n        assert!(self.duration > min,\n            \"Command took {:?}, expected over {:?}\", self.duration, min);\n        self\n    }\n}\n```\n\n### Test Fixture Helpers\n```rust\n// tests/common/fixtures.rs\nuse tempfile::TempDir;\nuse std::path::PathBuf;\n\n/// Get path to test fixtures directory\npub fn fixtures_path(subpath: &str) -> PathBuf {\n    PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n        .join(\"tests\")\n        .join(\"fixtures\")\n        .join(subpath)\n}\n\n/// Create a temporary directory with test images\npub struct TestImages {\n    pub dir: TempDir,\n}\n\nimpl TestImages {\n    /// Create temp dir with N solid-color test images\n    pub fn create_batch(count: u8, size: u32) -> Self {\n        let dir = TempDir::new().unwrap();\n        \n        for i in 0..count {\n            let color = image::Rgb([\n                (i * 8) % 256,\n                (i * 16) % 256,\n                (i * 24) % 256,\n            ]);\n            let img = image::RgbImage::from_pixel(size, size, color);\n            let path = dir.path().join(format!(\"key-{}.png\", i));\n            img.save(&path).unwrap();\n        }\n        \n        Self { dir }\n    }\n    \n    /// Create numbered images matching key-{N}.png pattern\n    pub fn create_numbered(keys: &[u8], size: u32) -> Self {\n        let dir = TempDir::new().unwrap();\n        \n        for &key in keys {\n            let img = image::RgbImage::from_pixel(size, size, \n                image::Rgb([key * 8, 128, 255 - key * 8]));\n            let path = dir.path().join(format!(\"key-{}.png\", key));\n            img.save(&path).unwrap();\n        }\n        \n        Self { dir }\n    }\n    \n    pub fn path(&self) -> &std::path::Path {\n        self.dir.path()\n    }\n}\n\n/// Create a temporary config file\npub struct TestConfig {\n    pub dir: TempDir,\n    pub config_path: PathBuf,\n}\n\nimpl TestConfig {\n    pub fn yaml(content: &str) -> Self {\n        let dir = TempDir::new().unwrap();\n        let config_path = dir.path().join(\"config.yaml\");\n        std::fs::write(&config_path, content).unwrap();\n        Self { dir, config_path }\n    }\n    \n    pub fn toml(content: &str) -> Self {\n        let dir = TempDir::new().unwrap();\n        let config_path = dir.path().join(\"config.toml\");\n        std::fs::write(&config_path, content).unwrap();\n        Self { dir, config_path }\n    }\n}\n```\n\n### Logging Verification Helpers\n```rust\n// tests/common/logging.rs\n\n/// Verify log output contains expected entries\npub struct LogVerifier {\n    log_lines: Vec<String>,\n}\n\nimpl LogVerifier {\n    pub fn from_stderr(stderr: &str) -> Self {\n        Self {\n            log_lines: stderr.lines().map(String::from).collect(),\n        }\n    }\n    \n    pub fn assert_contains_level(&self, level: &str, message: &str) -> &Self {\n        let found = self.log_lines.iter().any(|line| {\n            line.contains(level) && line.contains(message)\n        });\n        assert!(found, \"No {} log containing \\\"{}\\\" found in:\\n{}\", \n            level, message, self.log_lines.join(\"\\n\"));\n        self\n    }\n    \n    pub fn assert_trace(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"TRACE\", message)\n    }\n    \n    pub fn assert_debug(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"DEBUG\", message)\n    }\n    \n    pub fn assert_info(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"INFO\", message)\n    }\n    \n    pub fn assert_warn(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"WARN\", message)\n    }\n    \n    pub fn assert_error(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"ERROR\", message)\n    }\n    \n    pub fn assert_no_errors(&self) -> &Self {\n        let errors: Vec<_> = self.log_lines.iter()\n            .filter(|l| l.contains(\"ERROR\"))\n            .collect();\n        assert!(errors.is_empty(), \"Found unexpected errors:\\n{}\", \n            errors.join(\"\\n\"));\n        self\n    }\n    \n    pub fn assert_no_warnings(&self) -> &Self {\n        let warnings: Vec<_> = self.log_lines.iter()\n            .filter(|l| l.contains(\"WARN\"))\n            .collect();\n        assert!(warnings.is_empty(), \"Found unexpected warnings:\\n{}\", \n            warnings.join(\"\\n\"));\n        self\n    }\n}\n```\n\n## E2E Test Examples\n```rust\n// tests/e2e/batch_operations.rs\nuse common::{cli::CliRunner, fixtures::TestImages, logging::LogVerifier};\n\n#[test]\nfn test_set_keys_full_batch() {\n    let images = TestImages::create_batch(32, 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot(&[\"set-keys\", images.path().to_str().unwrap()]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/summary/success\", &json!(32))\n        .assert_json_field(\"/summary/failed\", &json!(0));\n}\n\n#[test]\nfn test_set_keys_partial_with_continue() {\n    let images = TestImages::create_numbered(&[0, 2, 5, 10, 31], 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot(&[\n        \"set-keys\", \n        images.path().to_str().unwrap(),\n        \"--continue-on-error\"\n    ]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/summary/success\", &json!(5))\n        .assert_json_field(\"/summary/skipped\", &json!(27));\n}\n\n#[test]\nfn test_dry_run_shows_plan_no_device_changes() {\n    let images = TestImages::create_batch(8, 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot_dry_run(&[\n        \"set-keys\",\n        images.path().to_str().unwrap()\n    ]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/dry_run\", &json!(true))\n        .assert_json_field_exists(\"/plan/keys\");\n}\n\n#[test]\nfn test_verbose_logging_output() {\n    let images = TestImages::create_batch(4, 72);\n    let cli = CliRunner::new()\n        .with_env(\"RUST_LOG\", \"sd=trace\");\n    \n    let result = cli.run(&[\n        \"-vvv\",  // Very verbose\n        \"set-keys\",\n        images.path().to_str().unwrap()\n    ]);\n    \n    let logs = LogVerifier::from_stderr(&result.stderr);\n    logs.assert_trace(\"scanning directory\")\n        .assert_debug(\"loading image\")\n        .assert_info(\"set-keys operation complete\");\n}\n```\n\n## Success Criteria\n- [ ] CliRunner can execute sd binary with configurable timeout\n- [ ] Environment variable injection works\n- [ ] Working directory can be overridden\n- [ ] Output capture works for stdout and stderr\n- [ ] Exit code assertions work correctly\n- [ ] JSON parsing and pointer assertions work for robot mode\n- [ ] Timing assertions can verify performance\n- [ ] TestImages helper can create temp directories with test images\n- [ ] TestConfig helper can create temp config files\n- [ ] LogVerifier can parse and assert on log output\n- [ ] Tests can run in parallel safely (no shared state)\n- [ ] Temp directories are cleaned up automatically\n\n## Logging Requirements\n- TRACE: CLI argument parsing details\n- DEBUG: Test setup and teardown steps\n- INFO: Test execution summaries\n- WARN: Test resource cleanup issues\n- ERROR: Assertion failures with full context","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:51.556676964Z","created_by":"ubuntu","updated_at":"2026-01-19T20:48:22.048157675Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xy","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:51.566910552Z","created_by":"ubuntu"}]}
{"id":"bd-1zf","title":"EPIC: Hot-Reload Configuration Files","description":"## Overview\n**Rank: #11 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium-High**\n\nMonitor configuration files and automatically apply changes when files are modified.\n\n## Problem Statement\nWhen designing a Stream Deck layout, users must:\n1. Edit configuration file\n2. Save file\n3. Run `sd apply config.yaml`\n4. See result on device\n5. Repeat\n\nThis edit-save-run-check cycle is slow and breaks flow. Users want to see changes instantly.\n\n## Solution\nWatch mode for configuration files:\n```bash\n# Watch a single config file\nsd watch-config ~/.config/sd/current.yaml\n\n# Watch with debounce (avoid rapid re-applies)\nsd watch-config work.yaml --debounce 500\n\n# Watch entire config directory\nsd watch-config ~/.config/sd/profiles/ --active work.yaml\n```\n\nWhen the file changes:\n```\n[2024-01-15 10:30:15] Detected change in work.yaml\n[2024-01-15 10:30:15] Applying configuration...\n[2024-01-15 10:30:15] ✓ Applied 5 key changes, brightness unchanged\n```\n\n## Why This Is #11 Priority\n1. **Developer experience**: Real-time feedback during design\n2. **Natural extension**: Builds on DECLARATIVE-CONFIG (#7)\n3. **Live editing workflow**: Edit in VSCode, see on device instantly\n4. **Moderate effort**: File watching is well-supported in Rust\n5. **Dependent feature**: Requires declarative config to be useful\n\n## Implementation Approach\n\n### Phase 1: File Watcher Setup\n```rust\n// Add to Cargo.toml\n[dependencies]\nnotify = \"6\"\n\n// In src/watch_config.rs (new file)\nuse notify::{Watcher, RecursiveMode, watcher};\nuse std::sync::mpsc::channel;\nuse std::time::Duration;\n\npub fn watch_config(\n    device: &Device,\n    config_path: &Path,\n    debounce_ms: u64,\n) -> Result<()> {\n    let (tx, rx) = channel();\n    \n    let mut watcher = notify::recommended_watcher(move |res| {\n        if let Ok(event) = res {\n            let _ = tx.send(event);\n        }\n    })?;\n    \n    watcher.watch(config_path, RecursiveMode::NonRecursive)?;\n    \n    println!(\"Watching {} for changes...\", config_path.display());\n    println!(\"Press Ctrl+C to stop\");\n    \n    // Apply initial configuration\n    apply_config(device, config_path)?;\n    \n    let mut last_apply = std::time::Instant::now();\n    \n    loop {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(event) => {\n                // Debounce: ignore events too close together\n                if last_apply.elapsed() < Duration::from_millis(debounce_ms) {\n                    continue;\n                }\n                \n                if is_modify_event(&event) {\n                    println!(\"[{}] Detected change\", timestamp());\n                    match apply_config(device, config_path) {\n                        Ok(changes) => {\n                            println!(\"[{}] ✓ Applied {} changes\", timestamp(), changes);\n                        }\n                        Err(e) => {\n                            eprintln!(\"[{}] ✗ Error: {}\", timestamp(), e);\n                        }\n                    }\n                    last_apply = std::time::Instant::now();\n                }\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => continue,\n            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => break,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n### Phase 2: Intelligent Diff-Apply\nInstead of re-applying everything, track what changed:\n```rust\npub struct ConfigState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyConfig>,\n}\n\nimpl ConfigState {\n    pub fn diff(&self, new: &ConfigState) -> ConfigDiff {\n        let mut changes = Vec::new();\n        \n        if self.brightness != new.brightness {\n            changes.push(Change::Brightness(new.brightness));\n        }\n        \n        for (key, new_config) in &new.keys {\n            match self.keys.get(key) {\n                Some(old_config) if old_config != new_config => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                None => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                _ => {}\n            }\n        }\n        \n        ConfigDiff { changes }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Debouncing**: Prevent rapid re-applies during multi-file saves\n2. **Error resilience**: Invalid config shows error, keeps watching\n3. **Diff-based apply**: Only change what actually changed\n4. **Initial apply**: Apply config once when watch starts\n5. **Graceful shutdown**: Ctrl+C stops cleanly\n\n## Robot Mode Output\n```json\n{\"event\": \"watching\", \"path\": \"/home/user/.config/sd/work.yaml\"}\n{\"event\": \"change_detected\", \"timestamp\": \"...\"}\n{\"event\": \"applying\", \"changes\": 5}\n{\"event\": \"applied\", \"success\": true, \"changes\": 5, \"duration_ms\": 150}\n{\"event\": \"error\", \"message\": \"Invalid YAML on line 15\"}\n```\n\n## Success Criteria\n- [ ] `sd watch-config <file>` monitors for changes\n- [ ] Changes auto-applied within debounce window\n- [ ] Syntax errors reported without crashing\n- [ ] Diff-based apply only changes modified keys\n- [ ] Debounce prevents rapid re-applies\n- [ ] Robot mode outputs structured events\n- [ ] Ctrl+C stops cleanly\n\n## Files to Create/Modify\n- `Cargo.toml`: Add notify dependency\n- `src/watch_config.rs`: New file watcher module\n- `src/cli/mod.rs`: Add WatchConfig command\n- `src/main.rs`: Implement command handler\n\n## Dependencies\n- **Hard dependency on DECLARATIVE-CONFIG (#7)**: Requires config files to watch\n\n## Estimated Subtasks\n1. Add notify dependency\n2. Implement basic file watcher\n3. Add debouncing logic\n4. Implement diff-based apply\n5. Add error handling for invalid configs\n6. Add robot mode output\n7. Test with various editors (VSCode, vim, etc.)\n8. Handle edge cases (file deletion, rename)","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:20:34.580206020Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.116619464Z","compaction_level":0,"original_size":0,"labels":["config","developer-experience","priority-11","watch"],"dependencies":[{"issue_id":"bd-1zf","depends_on_id":"bd-1r4","type":"blocks","created_at":"2026-01-19T18:23:22.116589698Z","created_by":"ubuntu"}]}
{"id":"bd-20s","title":"Handle command errors gracefully","description":"Command failures should not crash watch:\n- Log error to stderr\n- Report in robot mode\n- Continue watching\n- Track failure counts for diagnostics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.803142096Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.816837942Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-20s","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.816778210Z","created_by":"ubuntu"}]}
{"id":"bd-21c","title":"Add clap_complete to Cargo.toml","description":"Add dependency:\n```toml\n[dependencies]\nclap_complete = \"4\"\n```\n\nThis is the standard completion generation crate for clap.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.238271755Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.266803876Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21c","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.266752779Z","created_by":"ubuntu"}]}
{"id":"bd-21i","title":"Set up tracing-based structured logging","description":"## Purpose\nAdd comprehensive logging infrastructure using the tracing ecosystem for debugging, observability, and robot-mode structured output.\n\n## Dependencies\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\", \"json\"] }\n```\n\n## Implementation\n\n### Initialization (src/logging.rs)\n```rust\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter, Layer};\nuse std::io::IsTerminal;\n\npub fn init_logging(robot_mode: bool, verbose: u8) {\n    let default_level = match verbose {\n        0 => \"sd=info\",\n        1 => \"sd=debug\",\n        _ => \"sd=trace\",\n    };\n    \n    let filter = EnvFilter::try_from_default_env()\n        .unwrap_or_else(|_| EnvFilter::new(default_level));\n    \n    if robot_mode {\n        // JSON output for machine parsing\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .json()\n                .with_timer(fmt::time::UtcTime::rfc_3339())\n                .with_current_span(true))\n            .init();\n    } else if std::io::stderr().is_terminal() {\n        // Pretty output for interactive terminal\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .pretty()\n                .with_target(false)\n                .with_ansi(true))\n            .init();\n    } else {\n        // Compact output for piped/redirected stderr\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .compact()\n                .with_ansi(false))\n            .init();\n    }\n}\n```\n\n### Instrumentation Pattern\n```rust\nuse tracing::{info, warn, error, debug, trace, instrument, span, Level};\n\n#[instrument(skip(device), fields(device_model = %device.info().model))]\npub fn cmd_set_key(device: &mut dyn DeviceOperations, key: u8, path: &Path) -> Result<()> {\n    info!(key, path = %path.display(), \"Setting key image\");\n    \n    // Timing span for performance analysis\n    let process_span = span!(Level::DEBUG, \"image_processing\", key);\n    let _guard = process_span.enter();\n    \n    let img = image::open(path).map_err(|e| {\n        error!(path = %path.display(), error = %e, \"Failed to open image\");\n        e\n    })?;\n    \n    debug!(width = img.width(), height = img.height(), format = ?img.color(), \"Image loaded\");\n    \n    // ... resize and send to device\n    \n    info!(key, duration_ms = elapsed.as_millis(), \"Key image set successfully\");\n    Ok(())\n}\n```\n\n## Log Level Guidelines\n\n### ERROR\n- Device communication failures\n- Unrecoverable file I/O errors\n- Parse errors that abort operation\n- Include: error cause, affected resource, recovery suggestion\n\n### WARN\n- Recoverable issues (fallback used)\n- Deprecation notices\n- Missing optional files\n- Include: what happened, what was done instead\n\n### INFO\n- Command start/complete\n- High-level operation flow\n- Summary statistics\n- Include: operation name, key parameters, outcome\n\n### DEBUG\n- Detailed operation steps\n- Timing information\n- Cache hit/miss\n- Configuration decisions\n- Include: all relevant parameters, durations\n\n### TRACE\n- Very detailed flow\n- Data values (truncated if large)\n- Loop iterations\n- Include: raw values, intermediate states\n\n## Log Format (Robot Mode JSON)\n```json\n{\n  \"timestamp\": \"2024-01-15T10:30:00.123456Z\",\n  \"level\": \"INFO\",\n  \"target\": \"sd::cmd::set_key\",\n  \"span\": {\n    \"name\": \"cmd_set_key\",\n    \"key\": 5,\n    \"device_model\": \"Stream Deck XL\"\n  },\n  \"fields\": {\n    \"message\": \"Key image set successfully\",\n    \"duration_ms\": 45\n  }\n}\n```\n\n## Environment Variables\n- `RUST_LOG=sd=debug` - Set log level\n- `RUST_LOG=sd::device=trace` - Trace specific module\n- `RUST_LOG_STYLE=never` - Disable colors\n- `NO_COLOR=1` - Disable colors (standard)\n\n## CLI Flags Integration\n- `--verbose` / `-v`: Set DEBUG level\n- `--verbose --verbose` / `-vv`: Set TRACE level\n- `--quiet` / `-q`: Suppress INFO, show WARN+ERROR only\n- `--robot`: Force JSON format\n\n## Success Criteria\n- [ ] Logging initialized based on robot mode and verbosity\n- [ ] RUST_LOG environment variable respected\n- [ ] TTY detection for automatic color handling\n- [ ] All commands have INFO-level start/complete logs\n- [ ] All errors have ERROR-level logs with context and suggestions\n- [ ] Performance-critical paths have DEBUG timing spans\n- [ ] JSON output is valid and includes spans/fields\n- [ ] Quiet mode suppresses non-error output","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:51.017515647Z","created_by":"ubuntu","updated_at":"2026-01-19T20:41:11.626586779Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21i","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:51.028264695Z","created_by":"ubuntu"}]}
{"id":"bd-21o","title":"Extract Device trait from concrete implementation","description":"## Purpose\nCreate a Device trait that abstracts over real and mock implementations, enabling testability.\n\n## Current State\n`src/device.rs` directly wraps `elgato-streamdeck::StreamDeck`. This makes unit testing impossible without real hardware.\n\n## Target Architecture\n```rust\n// src/device/mod.rs\npub trait DeviceOperations {\n    fn info(&self) -> &DeviceInfo;\n    fn set_brightness(&mut self, level: u8) -> Result<()>;\n    fn set_key_image(&mut self, key: u8, image: &[u8]) -> Result<()>;\n    fn clear_key(&mut self, key: u8) -> Result<()>;\n    fn read_input(&mut self, timeout: Duration) -> Result<Option<KeyEvent>>;\n    fn flush(&mut self) -> Result<()>;\n}\n\npub struct DeviceInfo {\n    pub model: String,\n    pub serial: String,\n    pub firmware: String,\n    pub key_count: u8,\n    pub key_width: u32,\n    pub key_height: u32,\n}\n```\n\n## Implementation Steps\n1. Create `src/device/mod.rs` with trait definition\n2. Move existing code to `src/device/real.rs`\n3. Implement trait for real device\n4. Export both trait and real implementation\n5. Update all call sites to use trait\n\n## Success Criteria\n- [ ] Device trait defined with all necessary methods\n- [ ] Real device implements trait\n- [ ] All existing functionality preserved\n- [ ] No changes to CLI interface\n- [ ] Compiles and passes existing tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:49.366767185Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:49.396965102Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21o","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:49.396905409Z","created_by":"ubuntu"}]}
{"id":"bd-227","title":"Handle image copying and storage","description":"When importing profiles:\n1. Extract images from ZIP to temp\n2. Copy to ~/.local/share/sd/images/\n3. Use content-addressable naming (SHA256)\n4. Update database with new paths\n5. Handle duplicates (same image, different keys)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.340162210Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.349396096Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-227","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.349355890Z","created_by":"ubuntu"}]}
{"id":"bd-22s","title":"Implement dry-run for clear-key/clear-all","description":"When dry_run=true:\n- clear-key: Show which key would be cleared\n- clear-all: Show total key count that would be cleared\n- Include device info in output","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.569143769Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.578920226Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-22s","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.578880340Z","created_by":"ubuntu"}]}
{"id":"bd-248","title":"Implement HumanOutput skeleton with rich_rust Console","description":"# Implement HumanOutput skeleton with rich_rust Console\n\n## Purpose\nCreate the HumanOutput struct that implements the Output trait using rich_rust for beautiful terminal rendering. This task creates the skeleton with basic implementations; detailed formatting for each command will be added in Phase 2.\n\n## Background\nHumanOutput is the counterpart to RobotOutput. While RobotOutput produces raw JSON, HumanOutput produces styled terminal output using rich_rust features:\n- Panels with box drawing characters\n- Tables with auto-sizing columns\n- Styled text with colors and attributes\n- Progress bars for brightness\n- Rules for visual separation\n\n## Technical Details\n\n### HumanOutput Struct (src/output/human.rs)\n```rust\nuse rich_rust::prelude::*;\nuse crate::theme::SdTheme;\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse super::Output;\nuse std::path::Path;\n\n/// Styled terminal output implementation for human users\n/// \n/// Uses rich_rust for beautiful, consistent formatting with:\n/// - Panels for grouped information\n/// - Tables for structured data\n/// - Styled text for emphasis\n/// - Progress bars for numeric values\n/// - Automatic terminal capability detection\npub struct HumanOutput {\n    console: Console,\n    theme: SdTheme,\n}\n\nimpl HumanOutput {\n    pub fn new(console: Console) -> Self {\n        Self {\n            console,\n            theme: SdTheme::default(),\n        }\n    }\n    \n    /// Get terminal width for layout calculations\n    fn width(&self) -> usize {\n        self.console.width()\n    }\n    \n    /// Create a styled panel with the theme's accent border\n    fn accent_panel(&self, content: &str, title: Option<&str>) -> Panel {\n        let mut panel = Panel::from_text(content)\n            .border_style(Style::new().color(self.theme.accent.clone()));\n        if let Some(t) = title {\n            panel = panel.title(t);\n        }\n        panel.rounded()\n    }\n    \n    /// Create a styled panel for errors\n    fn error_panel(&self, content: Text, title: Option<&str>) -> Panel {\n        let width = self.width().saturating_sub(4);\n        let mut panel = Panel::from_rich_text(content, width)\n            .border_style(Style::new().color(self.theme.error.clone()));\n        if let Some(t) = title {\n            panel = panel.title(t);\n        }\n        panel.rounded()\n    }\n    \n    /// Create a styled panel for success\n    fn success_panel(&self, content: &str) -> Panel {\n        Panel::from_text(content)\n            .border_style(Style::new().color(self.theme.success.clone()))\n            .rounded()\n    }\n}\n```\n\n### Output Trait Implementation (Skeleton)\n```rust\nimpl Output for HumanOutput {\n    fn success(&self, message: &str) {\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    fn error(&self, error: &SdError) {\n        let mut content = Text::new(\"\");\n        content.append_styled(\"  ✗ \", Style::new().bold().color(self.theme.error.clone()));\n        content.append_styled(&error.to_string(), Style::new().bold());\n        content.append(\"\\n\");\n        \n        if let Some(suggestion) = error.suggestion() {\n            content.append(\"\\n\");\n            content.append_styled(\"  Suggestion:\\n\", self.theme.label.clone());\n            content.append_styled(&format!(\"  {}\", suggestion), self.theme.muted.clone());\n            content.append(\"\\n\");\n        }\n        \n        let panel = self.error_panel(content, Some(\"Error\"));\n        self.console.print_renderable(&panel);\n    }\n    \n    fn warning(&self, message: &str) {\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ⚠ \", Style::new().bold().color(self.theme.warning.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    fn info(&self, message: &str) {\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ℹ \", Style::new().color(self.theme.accent.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    fn device_list(&self, devices: &[DeviceInfo]) {\n        // Skeleton: Basic implementation\n        // Detailed table/panel formatting added in Phase 2 task\n        if devices.is_empty() {\n            self.warning(\"No Stream Deck devices found\");\n            return;\n        }\n        \n        self.console.print(\"[bold]Connected Devices:[/]\");\n        for device in devices {\n            self.console.print(&format!(\n                \"  {} ({})\",\n                device.product_name,\n                device.serial\n            ));\n        }\n    }\n    \n    fn device_info(&self, info: &DeviceInfo) {\n        // Skeleton: Basic implementation\n        // Detailed table/panel formatting added in Phase 2 task\n        self.console.print(&format!(\"[bold]{}[/]\", info.product_name));\n        self.console.print(&format!(\"  Serial: {}\", info.serial));\n        self.console.print(&format!(\"  Firmware: {}\", info.firmware_version));\n        self.console.print(&format!(\"  Keys: {} ({}x{})\", \n            info.key_count, info.cols, info.rows));\n    }\n    \n    fn button_event(&self, event: &ButtonEvent) {\n        // Skeleton: Basic implementation\n        // Enhanced formatting in Phase 2\n        let (icon, action) = if event.pressed {\n            (\"●\", \"pressed\")\n        } else {\n            (\"○\", \"released\")\n        };\n        self.console.print(&format!(\"  {} Key {} {}\", icon, event.key, action));\n    }\n    \n    fn button_states(&self, states: &[bool]) {\n        // Skeleton: Will be enhanced with grid visualization\n        let pressed: Vec<_> = states.iter()\n            .enumerate()\n            .filter(|(_, &pressed)| pressed)\n            .map(|(i, _)| i.to_string())\n            .collect();\n        \n        if pressed.is_empty() {\n            self.console.print(\"  No keys pressed\");\n        } else {\n            self.console.print(&format!(\"  Keys pressed: {}\", pressed.join(\", \")));\n        }\n    }\n    \n    fn brightness_set(&self, level: u8) {\n        // Skeleton: Will be enhanced with progress bar\n        self.success(&format!(\"Brightness set to {}%\", level));\n    }\n    \n    fn key_set(&self, key: u8, image: &Path) {\n        let filename = image.file_name()\n            .map(|n| n.to_string_lossy().to_string())\n            .unwrap_or_else(|| image.display().to_string());\n        self.success(&format!(\"Key {} set to {}\", key, filename));\n    }\n    \n    fn key_cleared(&self, key: u8) {\n        self.success(&format!(\"Key {} cleared\", key));\n    }\n    \n    fn key_filled(&self, key: u8, color: &str) {\n        self.success(&format!(\"Key {} filled with {}\", key, color));\n    }\n    \n    fn all_cleared(&self) {\n        self.success(\"All keys cleared\");\n    }\n    \n    fn all_filled(&self, color: &str) {\n        self.success(&format!(\"All keys filled with {}\", color));\n    }\n    \n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n        // Skeleton: Will be enhanced with panel in Phase 2\n        self.console.print(&format!(\"[bold]sd[/] version {}\", version));\n        if let Some(sha) = git_sha {\n            self.console.print(&format!(\"  Git: {}\", sha));\n        }\n        if let Some(time) = build_time {\n            self.console.print(&format!(\"  Built: {}\", time));\n        }\n    }\n    \n    fn rule(&self, title: Option<&str>) {\n        self.console.rule(title);\n    }\n    \n    fn newline(&self) {\n        self.console.print(\"\");\n    }\n}\n```\n\n## Design Decisions\n\n### Why Skeleton First?\n1. Validates the Output trait design with real implementations\n2. Allows main.rs integration to proceed (Phase 3)\n3. Detailed formatting can be refined iteratively\n4. Basic functionality works while polish is added\n\n### Theme Ownership\nHumanOutput owns a SdTheme instance rather than borrowing it. This avoids lifetime complexity and themes are cheap to clone.\n\n### Console Clone\nrich_rust Console is designed to be cloned (internal state is Rc-wrapped). HumanOutput owns its Console for simplicity.\n\n### Unicode Symbols\nUsing Unicode for icons (✓, ✗, ⚠, ℹ, ●, ○) because:\n- rich_rust handles terminal capability detection\n- Fallback to ASCII can be added later if needed\n- Modern terminals universally support these\n\n## Implementation Steps\n1. Create src/output/human.rs\n2. Define HumanOutput struct with console and theme\n3. Implement helper methods (accent_panel, error_panel, etc.)\n4. Implement Output trait with skeleton formatting\n5. Test basic output in terminal\n\n## Acceptance Criteria\n- [ ] HumanOutput implements all Output trait methods\n- [ ] Basic output appears correctly in terminal\n- [ ] Theme colors are applied to styled text\n- [ ] Console.rule() works for visual separation\n- [ ] Error output shows suggestion when available\n- [ ] No panics or crashes in any method","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:40.879633532Z","created_by":"ubuntu","updated_at":"2026-01-19T21:04:40.922437313Z","compaction_level":0,"original_size":0,"labels":["human-mode","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-248","depends_on_id":"bd-1es","type":"blocks","created_at":"2026-01-19T21:04:40.916158120Z","created_by":"ubuntu"},{"issue_id":"bd-248","depends_on_id":"bd-1lk","type":"blocks","created_at":"2026-01-19T21:04:40.922396977Z","created_by":"ubuntu"},{"issue_id":"bd-248","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:04:40.910289401Z","created_by":"ubuntu"}]}
{"id":"bd-24m","title":"Implement basic text rendering","description":"Create src/text.rs:\n```rust\npub fn render_text_image(\n    width: u32, height: u32,\n    text: &str,\n    font_size: f32,\n    text_color: Rgba<u8>,\n    bg_color: Rgba<u8>,\n) -> RgbaImage\n```\n\nUses ab_glyph for text rasterization.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.796958819Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.808425628Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-24m","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.808361998Z","created_by":"ubuntu"}]}
{"id":"bd-254","title":"Write tests for scripting hooks","description":"## Test Coverage for Scripting Hooks\n\n### Unit Tests\n\n1. **Template Substitution Tests**\n   - `{key}` replaced with key index\n   - `{key:02d}` formats with padding\n   - `{pressed}` replaced with \"press\" or \"release\"\n   - `{timestamp}` replaced with ISO timestamp\n   - Escaped `{{` becomes literal `{`\n   - Unknown placeholders returned unchanged (warn logged)\n   - Empty command after substitution → skip (no error)\n\n2. **Command Resolution Tests**\n   - --exec applies to all keys\n   - --on-press only fires on press\n   - --on-release only fires on release\n   - --keymap overrides inline flags\n   - Keymap range selectors match correctly\n   - First matching rule wins (specificity)\n\n3. **Keymap Parsing Tests**\n   - Valid YAML parses correctly\n   - Invalid YAML returns clear error\n   - Missing file returns clear error\n   - Empty keymap valid (no hooks)\n   - Key patterns: single, range, row\n\n4. **Execution Tests (mocked)**\n   - Command spawned via sh -c\n   - Non-blocking: doesn't wait for completion\n   - Environment variables passed correctly\n   - Working directory set correctly\n   - stdin closed immediately\n\n5. **Timeout Tests**\n   - Timeout kills long-running process\n   - Timeout emits warning/event\n   - Process tree killed (not just parent)\n   - Configurable timeout per command\n\n### Integration Tests (require MockDevice)\n\n1. **Watch Mode with Hooks**\n   - Start watch with --exec \"echo {key}\"\n   - Simulate key press via MockDevice\n   - Verify command executed\n   - Verify event emitted\n\n2. **Keymap File Integration**\n   - Load keymap from file\n   - Verify correct command for each key\n   - Verify range patterns work\n   - Verify row patterns work\n\n3. **Press/Release Distinction**\n   - --on-press fires only on press\n   - --on-release fires only on release\n   - Both can be specified simultaneously\n   - Simulate full press-release cycle\n\n4. **Robot Mode Hook Reporting**\n   - Hook start event emitted\n   - Hook completion event emitted\n   - Exit code included in completion\n   - Duration included in completion\n\n### E2E Tests (require E2E harness)\n\n1. **Basic Hook Execution**\n   ```bash\n   # Create test script that writes to file\n   echo '#!/bin/bash\\necho $1 >> /tmp/sd-test' > /tmp/hook.sh\n   chmod +x /tmp/hook.sh\n   \n   # Start watch with hook\n   sd watch --exec \"/tmp/hook.sh {key}\" &\n   \n   # Simulate key press (may need device or mock)\n   # ...\n   \n   # Verify hook executed\n   cat /tmp/sd-test  # Should contain key number\n   ```\n\n2. **Keymap File Test**\n   ```yaml\n   # tests/fixtures/keymaps/test.yaml\n   keys:\n     0:\n       press: \"echo 'key 0 pressed'\"\n     1-7:\n       press: \"notify-send 'Key {key}'\"\n       release: \"echo 'released {key}'\"\n   ```\n   \n   ```bash\n   sd watch --keymap tests/fixtures/keymaps/test.yaml\n   ```\n\n3. **Error Resilience Test**\n   - Hook that exits non-zero\n   - Hook that times out\n   - Hook that doesn't exist\n   - Watch mode continues despite hook failures\n\n4. **Security Test**\n   - Command injection via key index not possible (numeric only)\n   - Shell metacharacters in keymap commands work as expected\n   - No unintended environment leakage\n\n### Test Fixtures (tests/fixtures/keymaps/)\n\n```\nkeymaps/\n├── basic.yaml           # Simple echo commands\n├── all-keys.yaml        # Command for every key\n├── ranges.yaml          # Range patterns (0-7, 8-15)\n├── press-release.yaml   # Different press/release commands\n├── timeout-test.yaml    # Commands that will timeout\n├── error-test.yaml      # Commands that fail\n└── invalid.yaml         # Parse error for testing\n```\n\n### Logging Requirements\n- DEBUG: Command being executed, template substitution\n- INFO: Hook started for key N\n- WARN: Hook timeout, hook non-zero exit\n- ERROR: Hook spawn failure, keymap parse error\n\n### Security Considerations in Tests\n- Verify no shell injection possible\n- Verify hooks run as current user\n- Verify working directory is safe\n- Verify environment is sanitized","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:22.353005212Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:10.454551639Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-254","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:22.367692125Z","created_by":"ubuntu"},{"issue_id":"bd-254","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:53.712324794Z","created_by":"ubuntu"},{"issue_id":"bd-254","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:10.454508237Z","created_by":"ubuntu"}]}
{"id":"bd-26w","title":"Implement color fill endpoint","description":"PUT /api/keys/:id/color { \"color\": \"#FF5500\" }\n- Parse color\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:45.404624395Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:45.421082954Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26w","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:45.421027660Z","created_by":"ubuntu"}]}
{"id":"bd-26y","title":"Add robot mode output for watch-config","description":"Emit JSON events:\n```json\n{\"event\": \"watching\", \"path\": \"...\"}\n{\"event\": \"change_detected\", \"timestamp\": \"...\"}\n{\"event\": \"applying\", \"changes\": 5}\n{\"event\": \"applied\", \"success\": true, \"changes\": 5}\n{\"event\": \"error\", \"message\": \"...\"}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.466745652Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.477125535Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26y","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.477087133Z","created_by":"ubuntu"}]}
{"id":"bd-271","title":"EPIC: Web Dashboard (Complete serve Command)","description":"## Overview\n**Rank: #14 of 15** | **Impact: High** | **Effort: High** | **Confidence: Medium**\n\nVisual browser-based interface for configuring Stream Deck, completing the stubbed `sd serve` command.\n\n## Problem Statement\nNot everyone wants a CLI. Visual editing is more intuitive for:\n- Designing key layouts\n- Previewing images before applying\n- Drag-and-drop configuration\n- Non-technical users\n- Quick experimentation\n\nThe official Elgato software provides this, but is closed-source and limited to official features.\n\n## Solution\nLocal web server with visual editor:\n```bash\nsd serve --port 8420\n# Opens http://localhost:8420\n\n# With specific device\nsd serve --serial ABC123 --port 8420\n\n# Headless mode (no browser auto-open)\nsd serve --no-open --port 8420\n```\n\nWeb interface features:\n- Visual grid of keys matching device layout\n- Drag-and-drop images onto keys\n- Color picker for fill colors\n- Brightness slider\n- Live preview (changes apply immediately)\n- Configuration save/load\n- Device status display\n\n## Why This Is #14 Priority\n1. **High effort**: Full web frontend + API = significant work\n2. **Competes with Elgato**: Official software already does this\n3. **Different audience**: CLI users may not want web UI\n4. **Already stubbed**: The serve command exists in code\n5. **Nice to have**: Not essential for CLI-first users\n\n## Architecture\n```\nBrowser (React/Preact/Vanilla JS)\n    ↓ HTTP/WebSocket\nsd serve (axum)\n    ↓ \nDevice Module\n    ↓\nStream Deck Hardware\n```\n\n## Implementation Approach\n\n### Phase 1: REST API\n```rust\n// In src/server/mod.rs (new)\nuse axum::{Router, Json, extract::State};\n\npub fn create_router(device: Arc<Mutex<Device>>) -> Router {\n    Router::new()\n        .route(\"/api/device\", get(get_device_info))\n        .route(\"/api/brightness\", get(get_brightness).put(set_brightness))\n        .route(\"/api/keys\", get(get_keys))\n        .route(\"/api/keys/:id\", put(set_key).delete(clear_key))\n        .route(\"/api/keys/:id/image\", post(upload_image))\n        .route(\"/api/keys/:id/color\", put(set_color))\n        .route(\"/api/config\", get(get_config).post(save_config))\n        .nest_service(\"/\", ServeDir::new(\"static\"))\n        .with_state(AppState { device })\n}\n\n// API handlers\nasync fn get_device_info(State(state): State<AppState>) -> Json<DeviceInfo> {\n    let device = state.device.lock().unwrap();\n    Json(device.info().clone())\n}\n\nasync fn set_brightness(\n    State(state): State<AppState>,\n    Json(req): Json<BrightnessRequest>,\n) -> Result<Json<()>, ApiError> {\n    let device = state.device.lock().unwrap();\n    device.set_brightness(req.level)?;\n    Ok(Json(()))\n}\n\nasync fn set_key(\n    State(state): State<AppState>,\n    Path(key): Path<u8>,\n    mut multipart: Multipart,\n) -> Result<Json<()>, ApiError> {\n    // Handle image upload\n    while let Some(field) = multipart.next_field().await? {\n        if field.name() == Some(\"image\") {\n            let data = field.bytes().await?;\n            let device = state.device.lock().unwrap();\n            set_key_from_bytes(&device, key, &data)?;\n        }\n    }\n    Ok(Json(()))\n}\n```\n\n### Phase 2: WebSocket for Live Updates\n```rust\n// Real-time key press events\nasync fn ws_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<AppState>,\n) -> impl IntoResponse {\n    ws.on_upgrade(|socket| handle_websocket(socket, state))\n}\n\nasync fn handle_websocket(mut socket: WebSocket, state: AppState) {\n    // Send key events as they happen\n    loop {\n        if let Some(event) = state.event_rx.recv().await {\n            let msg = serde_json::to_string(&event).unwrap();\n            if socket.send(Message::Text(msg)).await.is_err() {\n                break;\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Frontend (Embedded Static Files)\n```rust\n// Embed static files in binary\nuse rust_embed::RustEmbed;\n\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n\n// Or serve from filesystem in dev mode\n#[cfg(debug_assertions)]\nfn static_handler() -> ServeDir {\n    ServeDir::new(\"static\")\n}\n\n#[cfg(not(debug_assertions))]\nfn static_handler() -> EmbeddedAssets {\n    EmbeddedAssets::new()\n}\n```\n\nFrontend stack options (keep simple):\n- **Vanilla JS + HTML**: Zero build step, ~2KB\n- **Preact**: Small React-like library, ~4KB\n- **Alpine.js**: Declarative, ~15KB\n\nRecommended: Vanilla JS with modern features for simplicity.\n\n## API Specification\n```yaml\n# OpenAPI-style specification\npaths:\n  /api/device:\n    get:\n      summary: Get device information\n      response: { model, serial, key_count, key_size, firmware }\n  \n  /api/brightness:\n    get:\n      summary: Get current brightness\n      response: { level: 0-100 }\n    put:\n      summary: Set brightness\n      body: { level: 0-100 }\n  \n  /api/keys:\n    get:\n      summary: Get all key states (if tracked)\n      response: [{ index, source, type }]\n  \n  /api/keys/{id}:\n    put:\n      summary: Set key image (multipart form)\n    delete:\n      summary: Clear key\n  \n  /api/keys/{id}/color:\n    put:\n      summary: Fill key with color\n      body: { color: \"#RRGGBB\" }\n  \n  /api/config:\n    get:\n      summary: Export current config as YAML\n    post:\n      summary: Import and apply config\n```\n\n## Key Design Decisions\n1. **Local only**: No authentication needed (localhost)\n2. **Single device**: Serve manages one device at a time\n3. **Embedded assets**: Single binary deployment\n4. **REST + WebSocket**: REST for actions, WS for events\n5. **Minimal frontend**: Avoid heavy frameworks\n\n## Success Criteria\n- [ ] `sd serve` starts web server on configurable port\n- [ ] Device info displayed in browser\n- [ ] Brightness slider works\n- [ ] Can set key images via drag-and-drop\n- [ ] Can fill keys with colors via picker\n- [ ] Can clear keys\n- [ ] Live key press events via WebSocket\n- [ ] Configuration export/import\n\n## Files to Create/Modify\n- `src/server/mod.rs`: New web server module\n- `src/server/api.rs`: REST API handlers\n- `src/server/ws.rs`: WebSocket handler\n- `static/index.html`: Frontend HTML\n- `static/app.js`: Frontend JavaScript\n- `static/style.css`: Frontend styles\n- `Cargo.toml`: Add axum, tower, rust-embed dependencies\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for import/export\n\n## Estimated Subtasks\n1. Set up axum server skeleton\n2. Implement device info endpoint\n3. Implement brightness endpoint\n4. Implement key image upload endpoint\n5. Implement color fill endpoint\n6. Implement clear key endpoint\n7. Add WebSocket for key events\n8. Build frontend HTML structure\n9. Build frontend JavaScript logic\n10. Add configuration export/import\n11. Embed static files in binary\n12. Add --no-open flag\n13. Write integration tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:15.417798563Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:15.457603949Z","compaction_level":0,"original_size":0,"labels":["priority-14","serve","visual","web"]}
{"id":"bd-28r","title":"Add WebSocket for key events","description":"WS /api/events:\n- Stream key press/release events\n- Allow real-time UI updates\n- Handle multiple clients","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.083855094Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:47.101776507Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-28r","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.101714961Z","created_by":"ubuntu"}]}
{"id":"bd-298","title":"Implement clear key endpoint","description":"DELETE /api/keys/:id\n- Clear specified key\n- Return success","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:46.247930850Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:46.263618777Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-298","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:46.263574033Z","created_by":"ubuntu"}]}
{"id":"bd-2a1","title":"Update single commands to use retry logic","description":"Modify command dispatch in main.rs:\n1. Parse retry options from CLI\n2. Use open_with_retry instead of Device::open\n3. Ensure all device-using commands benefit","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.244590391Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.256786624Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2a1","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.256753532Z","created_by":"ubuntu"}]}
{"id":"bd-2ag","title":"Implement TokenBucket for burst scenarios","description":"Advanced rate limiter with burst capacity:\n```rust\npub struct TokenBucket {\n    capacity: usize,\n    tokens: f64,\n    refill_rate: f64,\n    last_refill: Instant,\n}\n```\n\nAllows bursts up to capacity, then rate-limits.\nUseful for future daemon mode.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.947415931Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:18.965877150Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ag","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.965819181Z","created_by":"ubuntu"}]}
{"id":"bd-2gt","title":"Add cache stats command","description":"Implement sd cache stats:\n- Location: ~/.cache/sd/images/\n- Entry count\n- Total size (bytes, formatted)\n- Optional: hit rate if tracked\n\nRobot mode: JSON object with stats","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.398978560Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.408353431Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2gt","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.408310671Z","created_by":"ubuntu"}]}
{"id":"bd-2hia","title":"Implement key operation confirmations (set, clear, fill)","description":"# Implement key operation confirmations (set, clear, fill)\n\n## Purpose\nProvide clear, consistent confirmation messages for all key operations. Users should immediately know their command succeeded and what changed.\n\n## Target Outputs\n\n### key_set (sd set-key 5 icon.png)\n```\n  ✓ Key 5 set to icon.png\n```\n\n### key_cleared (sd clear-key 5)\n```\n  ✓ Key 5 cleared\n```\n\n### key_filled (sd fill-key 5 #FF0000)\n```\n  ✓ Key 5 filled with #FF0000\n```\n\n### all_cleared (sd clear-all)\n```\n  ✓ All 32 keys cleared\n```\n\n### all_filled (sd fill-all #0080FF)\n```\n  ✓ All 32 keys filled with #0080FF\n```\n\n## Implementation\n\n### key_set Method\n```rust\nfn key_set(&self, key: u8, image: &Path) {\n    let filename = image.file_name()\n        .map(|n| n.to_string_lossy().to_string())\n        .unwrap_or_else(|| image.display().to_string());\n    \n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" set to \", self.theme.label.clone());\n    text.append_styled(&filename, self.theme.value.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### key_cleared Method\n```rust\nfn key_cleared(&self, key: u8) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" cleared\", self.theme.label.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### key_filled Method\n```rust\nfn key_filled(&self, key: u8, color: &str) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" filled with \", self.theme.label.clone());\n    \n    // Try to display color with actual color if valid hex\n    if let Some(parsed_color) = parse_hex_color(color) {\n        text.append_styled(color, Style::new().color(parsed_color));\n    } else {\n        text.append_styled(color, self.theme.value.clone());\n    }\n    \n    self.console.print_text(&text);\n}\n\n/// Parse hex color string to rich_rust Color\nfn parse_hex_color(hex: &str) -> Option<Color> {\n    Color::parse(hex).ok()\n}\n```\n\n### all_cleared Method\n```rust\nfn all_cleared(&self) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"All keys cleared\", self.theme.label.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### all_filled Method  \n```rust\nfn all_filled(&self, color: &str) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"All keys filled with \", self.theme.label.clone());\n    \n    if let Some(parsed_color) = parse_hex_color(color) {\n        text.append_styled(color, Style::new().color(parsed_color));\n    } else {\n        text.append_styled(color, self.theme.value.clone());\n    }\n    \n    self.console.print_text(&text);\n}\n```\n\n## Design Decisions\n\n### Checkmark Icon (✓)\n- Universal success symbol\n- Green and bold for emphasis\n- Consistent with error (✗) and other indicators\n\n### Simple Line Format\n- No panel needed (these are quick confirmations)\n- Single line is sufficient for success\n- Errors get panels for more information\n\n### Key Index Highlighting\n- Amber color makes key number pop\n- Essential when setting multiple keys in sequence\n- Consistent with button events display\n\n### Color Preview\n- When filling with a color, show it in that color if possible\n- Adds visual confirmation that color was understood\n- Falls back to regular value styling if color parsing fails\n\n### Filename Display\n- Show just filename, not full path (cleaner)\n- Fall back to full path if filename extraction fails\n- Quoted or styled to distinguish from surrounding text\n\n## Multiple Key Operations\nWhen setting multiple keys (future batch operation), these can be called in sequence:\n```\n  ✓ Key 0 set to icon1.png\n  ✓ Key 1 set to icon2.png\n  ✓ Key 2 set to icon3.png\n```\n\n## Testing\n```rust\n#[test]\nfn key_set_shows_filename() {\n    let output = HumanOutput::new(test_console());\n    let path = Path::new(\"/path/to/icons/my_icon.png\");\n    \n    let captured = capture_output(|| output.key_set(5, path));\n    \n    assert!(captured.contains(\"✓\"));\n    assert!(captured.contains(\"Key 5\"));\n    assert!(captured.contains(\"my_icon.png\"));\n    assert!(!captured.contains(\"/path/to\")); // No full path\n}\n\n#[test]\nfn key_filled_with_valid_hex() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| output.key_filled(5, \"#FF0000\"));\n    \n    assert!(captured.contains(\"✓\"));\n    assert!(captured.contains(\"#FF0000\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] key_set shows checkmark, key number, and filename\n- [ ] key_cleared shows checkmark and key number\n- [ ] key_filled shows checkmark, key number, and color\n- [ ] all_cleared confirms all keys\n- [ ] all_filled confirms all keys with color\n- [ ] Key numbers are highlighted in amber\n- [ ] Hex colors display in their actual color when possible\n- [ ] Success checkmark is green and bold","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:47.681747536Z","created_by":"ubuntu","updated_at":"2026-01-19T21:07:47.729868599Z","compaction_level":0,"original_size":0,"labels":["confirmation","keys","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-2hia","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:07:47.729833272Z","created_by":"ubuntu"},{"issue_id":"bd-2hia","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:07:47.723598473Z","created_by":"ubuntu"}]}
{"id":"bd-2j9","title":"Implement error output with styled Error panel and suggestions","description":"# Implement error output with styled Error panel and suggestions\n\n## Purpose\nCreate a visually distinct, helpful error display that not only shows what went wrong but also provides actionable suggestions for recovery. Errors should be attention-grabbing but not alarming.\n\n## Target Output\n```\n╭──────────────────────── Error ────────────────────────╮\n│                                                       │\n│  ✗ No Stream Deck devices found                       │\n│                                                       │\n│  Suggestion:                                          │\n│  Ensure Stream Deck is connected via USB              │\n│                                                       │\n╰───────────────────────────────────────────────────────╯\n```\n\n## Multi-Device Error\n```\n╭──────────────────────── Error ────────────────────────╮\n│                                                       │\n│  ✗ Multiple Stream Deck devices found                 │\n│                                                       │\n│  Available devices:                                   │\n│    • AL12U1E1234                                      │\n│    • AL12U1E5678                                      │\n│                                                       │\n│  Suggestion:                                          │\n│  Use --serial to specify which device                 │\n│                                                       │\n╰───────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Enhanced error Method\n```rust\nfn error(&self, error: &SdError) {\n    let mut content = Text::new(\"\");\n    content.append(\"\\n\");\n    \n    // Error icon and message\n    content.append_styled(\"  ✗ \", Style::new().bold().color(self.theme.error.clone()));\n    content.append_styled(&error.to_string(), Style::new().bold());\n    content.append(\"\\n\");\n    \n    // Special handling for MultipleDevices error\n    if let SdError::MultipleDevices { serials } = error {\n        content.append(\"\\n\");\n        content.append_styled(\"  Available devices:\\n\", self.theme.label.clone());\n        for serial in serials {\n            content.append_styled(&format!(\"    • {}\\n\", serial), \n                self.theme.device_serial.clone());\n        }\n    }\n    \n    // Suggestion section\n    if let Some(suggestion) = error.suggestion() {\n        content.append(\"\\n\");\n        content.append_styled(\"  Suggestion:\\n\", self.theme.label.clone());\n        content.append_styled(&format!(\"  {}\\n\", suggestion), \n            self.theme.muted.clone());\n    }\n    \n    content.append(\"\\n\");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"Error\")\n        .border_style(Style::new().color(self.theme.error.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Red Border, Not Background\n- Red background can be overwhelming and hard to read\n- Red border draws attention without impairing readability\n- White/default text on terminal background stays readable\n\n### Error Icon (✗)\n- Unicode multiply sign is universally understood\n- Bold and colored for emphasis\n- Consistent with success checkmark (✓)\n\n### Suggestion Section\n- Separated visually from error message\n- Muted color indicates it's supplementary info\n- Actionable: tells user what to DO, not just what's wrong\n\n### Special Cases\n- MultipleDevices gets list of serials (actionable information)\n- Other errors can have custom handling added similarly\n- Pattern match on SdError variants for special formatting\n\n### Panel Title\n- Simple \"Error\" title (not the error type)\n- Error details are in the body\n- Keeps title short and scannable\n\n## Error Types and Their Display\n\n| Error | Display | Suggestion |\n|-------|---------|------------|\n| NoDevicesFound | \"No Stream Deck devices found\" | \"Ensure Stream Deck is connected via USB\" |\n| MultipleDevices | \"Multiple devices found\" + list | \"Use --serial to specify which device\" |\n| DeviceNotFound | \"Device 'XXX' not found\" | \"Check serial with 'sd list'\" |\n| InvalidKeyIndex | \"Invalid key 32\" | \"Use key index 0-31\" |\n| InvalidBrightness | \"Invalid brightness 150\" | \"Use value between 0 and 100\" |\n| ImageNotFound | \"Image file not found\" | \"Check path exists\" |\n\n## Testing\n```rust\n#[test]\nfn error_with_suggestion_displays_both() {\n    let output = HumanOutput::new(test_console());\n    let error = SdError::NoDevicesFound;\n    \n    // Capture output\n    output.error(&error);\n    \n    // Verify error message and suggestion both appear\n}\n\n#[test]\nfn multiple_devices_error_lists_serials() {\n    let output = HumanOutput::new(test_console());\n    let error = SdError::MultipleDevices { \n        serials: vec![\"AAA\".into(), \"BBB\".into()] \n    };\n    \n    output.error(&error);\n    \n    // Verify both serials appear in output\n}\n```\n\n## Acceptance Criteria\n- [ ] Error panel has red border\n- [ ] Error icon (✗) is bold and red\n- [ ] Error message is prominent\n- [ ] Suggestion appears when available\n- [ ] MultipleDevices lists all serial numbers\n- [ ] Panel uses rounded style\n- [ ] Readable on both light and dark terminals","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:06:24.185475508Z","created_by":"ubuntu","updated_at":"2026-01-19T21:06:24.245614287Z","compaction_level":0,"original_size":0,"labels":["error","phase-2","rich-rust","ux"],"dependencies":[{"issue_id":"bd-2j9","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:06:24.245580333Z","created_by":"ubuntu"},{"issue_id":"bd-2j9","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:06:24.240456306Z","created_by":"ubuntu"}]}
{"id":"bd-2js","title":"Implement GestureDetector struct","description":"## Purpose\nCreate the core gesture detection engine that recognizes tap, double-tap, long-press, and hold gestures from raw press/release events.\n\n## Implementation\n```rust\n// src/gestures.rs\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, info, warn, instrument, span, Level};\n\n/// Configuration for gesture timing thresholds\n#[derive(Debug, Clone)]\npub struct GestureConfig {\n    /// Time threshold for long-press detection (default: 800ms)\n    pub long_press_threshold: Duration,\n    /// Window for detecting double-tap (default: 300ms)\n    pub double_tap_window: Duration,\n    /// Interval between hold tick events (default: 100ms)\n    pub hold_tick_interval: Duration,\n}\n\nimpl Default for GestureConfig {\n    fn default() -> Self {\n        Self {\n            long_press_threshold: Duration::from_millis(800),\n            double_tap_window: Duration::from_millis(300),\n            hold_tick_interval: Duration::from_millis(100),\n        }\n    }\n}\n\n/// Raw button event from device\n#[derive(Debug, Clone)]\npub struct RawKeyEvent {\n    pub key: u8,\n    pub pressed: bool,\n    pub timestamp: Instant,\n}\n\n/// Detected gesture types\n#[derive(Debug, Clone)]\npub enum Gesture {\n    /// Quick press and release\n    Tap { key: u8 },\n    /// Two taps in quick succession\n    DoubleTap { key: u8, interval: Duration },\n    /// Press held past threshold then released\n    LongPress { key: u8, duration: Duration },\n    /// Key is being held - initial event\n    HoldStart { key: u8 },\n    /// Periodic tick while key is held\n    HoldTick { key: u8, held_for: Duration },\n    /// Key released after being held\n    HoldEnd { key: u8, total: Duration },\n}\n\nimpl Gesture {\n    pub fn key(&self) -> u8 {\n        match self {\n            Gesture::Tap { key } => *key,\n            Gesture::DoubleTap { key, .. } => *key,\n            Gesture::LongPress { key, .. } => *key,\n            Gesture::HoldStart { key } => *key,\n            Gesture::HoldTick { key, .. } => *key,\n            Gesture::HoldEnd { key, .. } => *key,\n        }\n    }\n    \n    pub fn gesture_type(&self) -> &'static str {\n        match self {\n            Gesture::Tap { .. } => \"tap\",\n            Gesture::DoubleTap { .. } => \"double_tap\",\n            Gesture::LongPress { .. } => \"long_press\",\n            Gesture::HoldStart { .. } => \"hold_start\",\n            Gesture::HoldTick { .. } => \"hold_tick\",\n            Gesture::HoldEnd { .. } => \"hold_end\",\n        }\n    }\n}\n\n/// Per-key state for gesture detection\n#[derive(Debug, Default)]\nstruct KeyGestureState {\n    /// When the current press started (None if released)\n    press_time: Option<Instant>,\n    /// When the last potential tap occurred (for double-tap detection)\n    pending_tap_time: Option<Instant>,\n    /// Whether we've transitioned to \"held\" state\n    is_held: bool,\n    /// Last time we emitted a hold tick\n    last_tick_time: Option<Instant>,\n}\n\n/// Main gesture detection engine\npub struct GestureDetector {\n    config: GestureConfig,\n    key_states: HashMap<u8, KeyGestureState>,\n}\n\nimpl GestureDetector {\n    pub fn new(config: GestureConfig) -> Self {\n        info!(\n            long_press_ms = %config.long_press_threshold.as_millis(),\n            double_tap_ms = %config.double_tap_window.as_millis(),\n            tick_interval_ms = %config.hold_tick_interval.as_millis(),\n            \"Gesture detector initialized\"\n        );\n        \n        Self {\n            config,\n            key_states: HashMap::new(),\n        }\n    }\n    \n    /// Process a raw key event and return any detected gestures\n    #[instrument(skip(self), fields(key = %event.key, pressed = %event.pressed))]\n    pub fn process_event(&mut self, event: &RawKeyEvent) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        let state = self.key_states.entry(event.key).or_default();\n        \n        if event.pressed {\n            // Key pressed\n            trace!(\"Key pressed, starting timing\");\n            state.press_time = Some(event.timestamp);\n            state.is_held = false;\n            state.last_tick_time = None;\n        } else {\n            // Key released\n            if let Some(press_time) = state.press_time.take() {\n                let duration = event.timestamp.duration_since(press_time);\n                \n                if state.is_held {\n                    // Was in hold state - emit hold end\n                    debug!(\n                        duration_ms = %duration.as_millis(),\n                        \"Hold ended\"\n                    );\n                    gestures.push(Gesture::HoldEnd {\n                        key: event.key,\n                        total: duration,\n                    });\n                } else if duration >= self.config.long_press_threshold {\n                    // Long press (pressed past threshold but not ticking as hold)\n                    debug!(\n                        duration_ms = %duration.as_millis(),\n                        \"Long press detected\"\n                    );\n                    gestures.push(Gesture::LongPress {\n                        key: event.key,\n                        duration,\n                    });\n                    // Clear pending tap since this was a long press\n                    state.pending_tap_time = None;\n                } else {\n                    // Short press - check for double-tap\n                    if let Some(pending_time) = state.pending_tap_time.take() {\n                        let interval = event.timestamp.duration_since(pending_time);\n                        if interval < self.config.double_tap_window {\n                            // Double tap!\n                            debug!(\n                                interval_ms = %interval.as_millis(),\n                                \"Double tap detected\"\n                            );\n                            gestures.push(Gesture::DoubleTap {\n                                key: event.key,\n                                interval,\n                            });\n                        } else {\n                            // Too slow for double-tap, emit the pending tap\n                            // and start new pending tap\n                            trace!(\"Pending tap expired, emitting tap\");\n                            gestures.push(Gesture::Tap { key: event.key });\n                            state.pending_tap_time = Some(event.timestamp);\n                        }\n                    } else {\n                        // First potential tap - defer emission\n                        trace!(\"Starting pending tap timer\");\n                        state.pending_tap_time = Some(event.timestamp);\n                    }\n                }\n                \n                state.is_held = false;\n            } else {\n                warn!(\"Release without matching press\");\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Called periodically to emit hold ticks and finalize deferred taps\n    #[instrument(skip(self), level = \"trace\")]\n    pub fn tick(&mut self, now: Instant) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        \n        for (key, state) in &mut self.key_states {\n            // Handle held keys\n            if let Some(press_time) = state.press_time {\n                let held_for = now.duration_since(press_time);\n                \n                // Transition to held state\n                if !state.is_held && held_for >= self.config.long_press_threshold {\n                    state.is_held = true;\n                    debug!(key = %key, \"Hold started\");\n                    gestures.push(Gesture::HoldStart { key: *key });\n                }\n                \n                // Emit hold ticks\n                if state.is_held {\n                    let should_tick = state.last_tick_time\n                        .map(|t| now.duration_since(t) >= self.config.hold_tick_interval)\n                        .unwrap_or(true);\n                    \n                    if should_tick {\n                        trace!(key = %key, held_ms = %held_for.as_millis(), \"Hold tick\");\n                        gestures.push(Gesture::HoldTick { key: *key, held_for });\n                        state.last_tick_time = Some(now);\n                    }\n                }\n            }\n            \n            // Finalize pending taps after double-tap window expires\n            if let Some(pending_time) = state.pending_tap_time {\n                if state.press_time.is_none() && \n                   now.duration_since(pending_time) >= self.config.double_tap_window {\n                    trace!(key = %key, \"Pending tap finalized\");\n                    gestures.push(Gesture::Tap { key: *key });\n                    state.pending_tap_time = None;\n                }\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Reset all state (e.g., on device reconnect)\n    pub fn reset(&mut self) {\n        info!(\"Gesture detector state reset\");\n        self.key_states.clear();\n    }\n    \n    /// Get current config\n    pub fn config(&self) -> &GestureConfig {\n        &self.config\n    }\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    fn make_event(key: u8, pressed: bool, offset_ms: u64) -> RawKeyEvent {\n        RawKeyEvent {\n            key,\n            pressed,\n            timestamp: Instant::now() + Duration::from_millis(offset_ms),\n        }\n    }\n    \n    #[test]\n    fn test_single_tap() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // Press\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: true,\n            timestamp: base,\n        });\n        assert!(gestures.is_empty());\n        \n        // Quick release (100ms)\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(100),\n        });\n        assert!(gestures.is_empty()); // Tap is deferred\n        \n        // Tick after double-tap window\n        let gestures = detector.tick(base + Duration::from_millis(400));\n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::Tap { key: 0 }));\n    }\n    \n    #[test]\n    fn test_double_tap() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // First tap\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        detector.process_event(&RawKeyEvent { key: 0, pressed: false, timestamp: base + Duration::from_millis(50) });\n        \n        // Second tap within window (200ms after first release)\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base + Duration::from_millis(150) });\n        let gestures = detector.process_event(&RawKeyEvent { key: 0, pressed: false, timestamp: base + Duration::from_millis(200) });\n        \n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::DoubleTap { key: 0, .. }));\n    }\n    \n    #[test]\n    fn test_long_press() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // Press\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        \n        // Release after threshold (1 second)\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(1000),\n        });\n        \n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::LongPress { key: 0, .. }));\n    }\n    \n    #[test]\n    fn test_hold_with_ticks() {\n        let config = GestureConfig {\n            hold_tick_interval: Duration::from_millis(100),\n            ..Default::default()\n        };\n        let mut detector = GestureDetector::new(config);\n        let base = Instant::now();\n        \n        // Press\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        \n        // Tick after threshold - should get HoldStart\n        let gestures = detector.tick(base + Duration::from_millis(850));\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldStart { .. })));\n        \n        // Tick again - should get HoldTick\n        let gestures = detector.tick(base + Duration::from_millis(950));\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldTick { .. })));\n        \n        // Release - should get HoldEnd\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(1100),\n        });\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldEnd { .. })));\n    }\n}\n```\n\n## Success Criteria\n- [ ] GestureDetector correctly identifies tap gestures\n- [ ] Double-tap detected within configurable window\n- [ ] Long-press detected on release after threshold\n- [ ] Hold events emitted with periodic ticks\n- [ ] Multiple keys tracked independently\n- [ ] State reset works correctly\n\n## Logging Requirements\n- TRACE: Key pressed/released, pending tap timer start/finalize, hold tick\n- DEBUG: Double tap detected, long press detected, hold started/ended\n- INFO: Gesture detector initialized, state reset\n- WARN: Release without matching press (shouldn't happen)\n- ERROR: (none - errors bubble up)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.259522713Z","created_by":"ubuntu","updated_at":"2026-01-19T20:53:00.241917671Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2js","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.270731547Z","created_by":"ubuntu"}]}
{"id":"bd-2ks","title":"Implement SessionState struct (shared with snapshots)","description":"Create src/state.rs (if not already from SAVE-RESTORE):\n- SessionState struct with brightness, keys HashMap\n- KeyState enum: Image(PathBuf), Color(String), Cleared\n- Thread-safe global accessor\n- Record methods for each mutation type\n\nNOTE: This is SHARED with SAVE-RESTORE epic. Coordinate implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.088169255Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.119119759Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ks","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.119070255Z","created_by":"ubuntu"}]}
{"id":"bd-2kw","title":"Add support for unsupported feature warnings","description":"Elgato profiles may contain unsupported features:\n- Folders (nested profiles)\n- Multi-actions (sequences)\n- System actions (specific to Elgato software)\n- Animated GIFs\n\nLog warnings for unsupported features, continue with supported parts.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.573276189Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.582720831Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2kw","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.582677830Z","created_by":"ubuntu"}]}
{"id":"bd-2ky","title":"Create test fixtures directory with sample data","description":"## Purpose\nProvide consistent, comprehensive test data for all test scenarios across the entire codebase.\n\n## Directory Structure\n```\ntests/fixtures/\n├── images/\n│   ├── valid/\n│   │   ├── exact-72x72.png       # Exact XL key size, no resize\n│   │   ├── exact-96x96.png       # Exact MK2 key size\n│   │   ├── large-256x256.png     # Needs downscale\n│   │   ├── large-1024x1024.png   # Very large, tests memory\n│   │   ├── small-50x50.png       # Needs upscale\n│   │   ├── nonsquare-100x80.png  # Non-square aspect\n│   │   ├── transparent.png       # With alpha channel\n│   │   ├── grayscale.png         # Grayscale image\n│   │   ├── high-quality.jpg      # JPEG with high quality\n│   │   ├── low-quality.jpg       # JPEG with artifacts\n│   │   └── webp-image.webp       # WebP format\n│   ├── invalid/\n│   │   ├── corrupted.png         # Invalid PNG header\n│   │   ├── truncated.png         # Incomplete file\n│   │   ├── empty.png             # Zero bytes\n│   │   ├── not-image.txt         # Text file with .png extension\n│   │   └── fake-header.bin       # Valid PNG header, invalid data\n│   ├── batch/\n│   │   ├── complete-32/          # Full XL layout (key-00.png to key-31.png)\n│   │   ├── complete-15/          # Full MK2 layout (key-00.png to key-14.png)\n│   │   ├── complete-6/           # Full Mini layout (key-00.png to key-05.png)\n│   │   ├── partial-10/           # Sparse (key-00, key-05, key-10, etc.)\n│   │   ├── gaps/                 # key-00, key-02, key-04 (odd numbers missing)\n│   │   ├── mixed-formats/        # key-00.png, key-01.jpg, key-02.webp\n│   │   └── custom-pattern/       # icon_00.png, icon_01.png (custom naming)\n│   └── colors/\n│       ├── red.png               # Solid #FF0000\n│       ├── green.png             # Solid #00FF00\n│       ├── blue.png              # Solid #0000FF\n│       ├── white.png             # Solid #FFFFFF\n│       └── black.png             # Solid #000000\n├── profiles/\n│   ├── valid/\n│   │   ├── minimal.streamDeckProfile      # manifest + 1 key\n│   │   ├── full-xl.streamDeckProfile      # 32 keys, all types\n│   │   ├── full-mk2.streamDeckProfile     # 15 keys\n│   │   ├── full-mini.streamDeckProfile    # 6 keys\n│   │   └── with-brightness.streamDeckProfile  # brightness setting\n│   ├── unsupported/\n│   │   ├── with-folders.streamDeckProfile     # Nested folders\n│   │   ├── with-multiaction.streamDeckProfile # Multi-actions\n│   │   ├── with-animation.streamDeckProfile   # Animated GIF\n│   │   └── with-system.streamDeckProfile      # System actions\n│   └── invalid/\n│       ├── corrupted-zip.streamDeckProfile\n│       ├── missing-manifest.streamDeckProfile\n│       ├── bad-json.streamDeckProfile\n│       └── missing-images.streamDeckProfile\n├── configs/\n│   ├── valid/\n│   │   ├── brightness-only.yaml   # Just brightness setting\n│   │   ├── single-key.yaml        # One key with image\n│   │   ├── full-layout.yaml       # All 32 keys defined\n│   │   ├── with-ranges.yaml       # Range selectors (0-7, 8-15)\n│   │   ├── with-rows.yaml         # Row selectors (row-0, row-1)\n│   │   ├── with-default.yaml      # Default fallback rule\n│   │   ├── with-colors.yaml       # Color fills\n│   │   ├── mixed-types.yaml       # Images, colors, cleared\n│   │   ├── with-patterns.yaml     # Pattern expansions\n│   │   ├── device-filter.yaml     # Device-specific config\n│   │   └── equivalent.toml        # TOML version of valid config\n│   └── invalid/\n│       ├── syntax-error.yaml      # YAML parse error\n│       ├── missing-image.yaml     # References non-existent file\n│       ├── out-of-range.yaml      # Key index > 31\n│       ├── invalid-color.yaml     # Bad color format\n│       └── missing-required.yaml  # Missing required field\n├── keymaps/\n│   ├── basic.yaml                 # Simple echo hooks\n│   ├── all-keys.yaml              # Hook for every key\n│   ├── ranges.yaml                # Range patterns\n│   ├── gestures.yaml              # Gesture-specific hooks\n│   ├── press-release.yaml         # Separate press/release\n│   ├── with-timeout.yaml          # Commands that timeout\n│   └── invalid.yaml               # Parse error\n├── snapshots/\n│   ├── work-layout.json           # Sample saved snapshot\n│   ├── gaming-layout.json         # Another snapshot\n│   └── with-cached-images/        # Snapshot with image cache\n└── scripts/\n    ├── generate-images.py         # Script to regenerate fixtures\n    └── validate-fixtures.sh       # Verify all fixtures valid\n```\n\n## Image Generation Script (scripts/generate-images.py)\n```python\nfrom PIL import Image\n\n# Generate solid color images\ncolors = {\n    'red': (255, 0, 0),\n    'green': (0, 255, 0),\n    'blue': (0, 0, 255),\n    'white': (255, 255, 255),\n    'black': (0, 0, 0),\n}\n\nfor name, color in colors.items():\n    img = Image.new('RGB', (72, 72), color)\n    img.save(f'tests/fixtures/images/colors/{name}.png')\n\n# Generate batch images with key numbers\nfor i in range(32):\n    img = Image.new('RGB', (72, 72), (50, 50, 50))\n    # Add text overlay with key number\n    # ... (use ImageDraw)\n    img.save(f'tests/fixtures/images/batch/complete-32/key-{i:02d}.png')\n```\n\n## Validation Script (scripts/validate-fixtures.sh)\n```bash\n#!/bin/bash\n# Verify all fixtures are valid and present\n\n# Check images\nfor img in tests/fixtures/images/valid/*.png; do\n    file \"$img\" | grep -q \"PNG image\" || echo \"Invalid: $img\"\ndone\n\n# Check configs parse\nfor cfg in tests/fixtures/configs/valid/*.yaml; do\n    python -c \"import yaml; yaml.safe_load(open('$cfg'))\" || echo \"Invalid: $cfg\"\ndone\n\necho \"Fixture validation complete\"\n```\n\n## Success Criteria\n- [ ] All fixture files created and valid\n- [ ] Images cover all sizes, formats, and edge cases\n- [ ] Profile files are valid Elgato format (verified with tool)\n- [ ] Config files cover all schema features\n- [ ] Keymap files cover all hook scenarios\n- [ ] Generation script can recreate fixtures\n- [ ] Validation script passes\n- [ ] README.md documents each fixture purpose\n- [ ] Files are version controlled in git\n- [ ] No binary files larger than 100KB","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:50.449140586Z","created_by":"ubuntu","updated_at":"2026-01-19T20:45:07.984376312Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ky","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:50.459934398Z","created_by":"ubuntu"}]}
{"id":"bd-2mvm","title":"Refactor main.rs entry point to use OutputMode","description":"# Refactor main.rs entry point to use OutputMode\n\n## Purpose\nTransform main.rs to use the new output abstraction. The entry point creates the appropriate OutputMode based on CLI flags and passes it to command handlers.\n\n## Current State (Simplified)\n```rust\nfn main() {\n    let cli = Cli::parse();\n    \n    if let Err(e) = run(&cli) {\n        if cli.use_json() {\n            println!(\"{}\", serde_json::json!({\n                \"error\": true,\n                \"message\": e.to_string(),\n            }));\n        } else {\n            eprintln!(\"Error: {}\", e);\n        }\n        std::process::exit(1);\n    }\n}\n\nfn run(cli: &Cli) -> Result<(), SdError> {\n    match &cli.command {\n        Some(Commands::List(args)) => cmd_list(cli, args),\n        // ...\n    }\n}\n```\n\n## Target State\n```rust\nuse crate::output::{OutputMode, Output};\n\nfn main() {\n    let cli = Cli::parse();\n    \n    // Create appropriate output handler based on CLI flags\n    let output_mode = OutputMode::from_cli(&cli);\n    let output = output_mode.as_output();\n    \n    // Run with output abstraction\n    if let Err(e) = run(&cli, output.as_ref()) {\n        output.error(&e);\n        std::process::exit(1);\n    }\n}\n\nfn run(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    match &cli.command {\n        Some(Commands::List(args)) => cmd_list(cli, args, output),\n        Some(Commands::Info) => cmd_info(cli, output),\n        Some(Commands::Brightness(args)) => cmd_brightness(cli, args, output),\n        Some(Commands::SetKey(args)) => cmd_set_key(cli, args, output),\n        Some(Commands::ClearKey(args)) => cmd_clear_key(cli, args, output),\n        Some(Commands::ClearAll) => cmd_clear_all(cli, output),\n        Some(Commands::FillKey(args)) => cmd_fill_key(cli, args, output),\n        Some(Commands::FillAll(args)) => cmd_fill_all(cli, args, output),\n        Some(Commands::Watch(args)) => cmd_watch(cli, args, output),\n        Some(Commands::Read) => cmd_read(cli, output),\n        Some(Commands::Version) => cmd_version(output),\n        Some(Commands::Completions(args)) => cmd_completions(args),\n        None => cmd_default(output),\n    }\n}\n```\n\n## Implementation Steps\n\n### Step 1: Add Output Module Import\n```rust\nmod output;\n\nuse output::{OutputMode, Output};\n```\n\n### Step 2: Update main() Function\n```rust\nfn main() {\n    let cli = Cli::parse();\n    \n    // Set up color output handling\n    // (rich_rust Console handles this automatically)\n    \n    let output_mode = OutputMode::from_cli(&cli);\n    let output = output_mode.as_output();\n    \n    if let Err(e) = run(&cli, output.as_ref()) {\n        output.error(&e);\n        std::process::exit(1);\n    }\n}\n```\n\n### Step 3: Update run() Signature\n```rust\nfn run(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    // Command dispatch with output parameter\n}\n```\n\n### Step 4: Update Each Command Function\nEvery command function signature changes to accept output:\n```rust\n// Before\nfn cmd_list(cli: &Cli, args: &ListArgs) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    if cli.use_json() {\n        println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n    } else {\n        for device in &devices {\n            println!(\"{}\", device.serial);\n        }\n    }\n    Ok(())\n}\n\n// After\nfn cmd_list(cli: &Cli, args: &ListArgs, output: &dyn Output) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    output.device_list(&devices);\n    Ok(())\n}\n```\n\n### Step 5: Handle Default Command (no subcommand)\n```rust\nfn cmd_default(output: &dyn Output) -> Result<(), SdError> {\n    // Show quick-start info in human mode\n    // Show agent discovery info in robot mode\n    output.info(\"Run 'sd --help' for usage information\");\n    Ok(())\n}\n```\n\n## Design Decisions\n\n### Box<dyn Output> vs enum dispatch\n- Using trait object (dyn Output) for flexibility\n- enum dispatch would be faster but less extensible\n- Performance difference is negligible for CLI output\n\n### Error Handling Flow\n- Errors bubble up via Result\n- main() calls output.error() for final display\n- Consistent error formatting regardless of where error occurred\n\n### Completions Command Exception\n- Shell completions are pure text (generated by clap)\n- No output styling needed/wanted\n- Keeps original implementation\n\n## Verification\n```bash\n# Robot mode regression\nsd list --robot | diff - expected_list.json\nsd info --robot | diff - expected_info.json\n\n# Human mode visual check\nsd list  # Should show styled panel\nsd info  # Should show styled table with key layout\n```\n\n## Acceptance Criteria\n- [ ] OutputMode created from CLI flags\n- [ ] run() accepts &dyn Output parameter\n- [ ] All command functions updated\n- [ ] Error handling uses output.error()\n- [ ] No direct println! for user-facing output (except completions)\n- [ ] Robot mode behavior unchanged\n- [ ] Human mode shows styled output","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:08:56.747819442Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:56.801313731Z","compaction_level":0,"original_size":0,"labels":["main","phase-3","refactor","rich-rust"],"dependencies":[{"issue_id":"bd-2mvm","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:08:56.792270123Z","created_by":"ubuntu"},{"issue_id":"bd-2mvm","depends_on_id":"bd-1xd","type":"blocks","created_at":"2026-01-19T21:08:56.796791456Z","created_by":"ubuntu"},{"issue_id":"bd-2mvm","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:08:56.801287411Z","created_by":"ubuntu"}]}
{"id":"bd-2oj","title":"Add text-key command","description":"Implement sd text-key:\n```\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n```\n\nGenerates image from text and applies to key.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.314684264Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.326125375Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2oj","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.326055764Z","created_by":"ubuntu"}]}
{"id":"bd-2qo","title":"Design snapshot storage schema","description":"Design the storage schema for snapshots:\n1. SQLite table structure for snapshot metadata\n2. File storage layout for cached images\n3. Relationship between snapshot records and image files\n4. Consider: ~/.local/share/sd/snapshots/{name}/ structure\n\nKey decisions:\n- Store source paths AND cached images for resilience\n- Include device info in snapshot for compatibility checking\n- Timestamp for audit trail","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:04.945524164Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:04.973821573Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qo","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:04.973777821Z","created_by":"ubuntu"}]}
{"id":"bd-2re","title":"Write tests for snapshot system","description":"## Test Coverage for Device State Snapshots\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **Snapshot Serialization Tests**\n   - Snapshot serializes to valid JSON\n   - Snapshot deserializes correctly\n   - Handles all key states: image, color, cleared\n   - Preserves brightness value\n   - Includes device metadata (model, serial)\n\n2. **State Tracking Tests**\n   - set-key records image path\n   - fill-key records color value\n   - clear-key records cleared state\n   - brightness changes recorded\n   - Multiple operations on same key use latest\n\n3. **Snapshot Storage Tests**\n   - Saves to ~/.local/share/sd/snapshots/\n   - Creates directory if not exists\n   - Uses SQLite for metadata index\n   - Stores images in content-addressable format\n   - Handles disk full gracefully\n\n4. **Image Resolution Tests**\n   - Original path available and valid → use original\n   - Original path missing → fallback to cached\n   - Both missing → clear error with recovery hint\n   - Relative paths resolved correctly\n   - Home directory ~ expanded correctly\n\n### Integration Tests (require MockDevice)\n\n1. **Save-Restore Cycle**\n   - Apply configuration\n   - Save snapshot\n   - Clear device\n   - Restore snapshot\n   - Verify device state matches original\n\n2. **Multiple Snapshots**\n   - Save \"work\" snapshot\n   - Save \"gaming\" snapshot\n   - Restore \"work\" - verify correct\n   - Restore \"gaming\" - verify correct\n   - List shows both with metadata\n\n3. **Snapshot Operations**\n   - List shows all snapshots with dates\n   - Show displays snapshot contents\n   - Delete removes snapshot and cached images\n   - Overwrite existing with same name (with confirmation)\n\n4. **Robot Mode Output**\n   - Save returns snapshot ID and path\n   - Restore returns per-key application status\n   - List returns JSON array with metadata\n   - Errors include snapshot name and reason\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Workflow**\n   - `sd brightness 80 && sd set-key 0 icon.png`\n   - `sd save my-layout`\n   - `sd clear-all`\n   - `sd restore my-layout`\n   - Verify keys restored correctly\n\n2. **Snapshot Management**\n   - `sd snapshots` lists all snapshots\n   - `sd snapshot show my-layout` displays contents\n   - `sd snapshot delete my-layout` removes it\n   - `sd snapshot delete nonexistent` returns error\n\n3. **Edge Cases**\n   - Save with empty device state\n   - Restore when source images deleted\n   - Restore to different device model (should warn)\n   - Unicode characters in snapshot name\n\n### Logging Requirements\n- TRACE: Each key being saved/restored\n- DEBUG: Image resolution decisions, cache hits/misses\n- INFO: Snapshot save/restore complete with key count\n- WARN: Fallback to cached image, missing originals\n- ERROR: Save/restore failures with context\n\n### Test Data\n- tests/fixtures/snapshots/work.json - sample snapshot file\n- tests/fixtures/snapshots/gaming.json - another sample\n- tests/fixtures/snapshots/corrupted.json - invalid snapshot","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:05.979311207Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:42.806959662Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2re","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:38.763082225Z","created_by":"ubuntu"},{"issue_id":"bd-2re","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:42.806921039Z","created_by":"ubuntu"},{"issue_id":"bd-2re","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.988259595Z","created_by":"ubuntu"}]}
{"id":"bd-2rh7","title":"Remove colored crate dependency","description":"# Remove colored crate dependency\n\n## Purpose\nAfter the rich_rust integration is complete, remove the colored crate dependency since all styling is now handled by rich_rust. This reduces dependencies and ensures we're not accidentally using the old styling system.\n\n## Background\nThe colored crate was used for basic terminal coloring before rich_rust integration. With rich_rust now handling all styled output, colored is no longer needed.\n\n## Pre-conditions\nBefore removing colored:\n- [ ] All output flows through Output trait\n- [ ] No code imports or uses colored\n- [ ] Robot mode tests pass (unchanged JSON)\n- [ ] Human mode tests pass (styled output works)\n\n## Implementation Steps\n\n### Step 1: Search for colored Usage\n```bash\nrg \"use colored\" src/\nrg \"colored::\" src/\nrg \".red()\" src/   # Method-style coloring\nrg \".green()\" src/\nrg \".blue()\" src/\n```\n\n### Step 2: Verify No Usage\nAll results should be empty or in comments/documentation.\n\n### Step 3: Remove from Cargo.toml\n```toml\n# Before\n[dependencies]\ncolored = \"3.0\"\n\n# After\n# (line removed)\n```\n\n### Step 4: Verify Compilation\n```bash\ncargo check --all-targets\ncargo build\ncargo test\n```\n\n### Step 5: Verify No colored in Lock File\n```bash\ncargo tree | grep colored\n# Should show no results\n```\n\n## Potential Issues\n\n### Transitive Dependency\nIf another crate depends on colored, it may still appear in Cargo.lock. That's fine - we just don't want direct dependency.\n\n### Test Code\nEnsure test utilities don't use colored either.\n\n### Build Scripts\nCheck build.rs doesn't use colored (it shouldn't).\n\n## Verification\n```bash\n# Ensure no compile errors\ncargo check --all-targets\n\n# Ensure all tests pass\ncargo test\n\n# Verify binary works\ncargo run -- list\ncargo run -- list --robot\n```\n\n## Acceptance Criteria\n- [ ] colored removed from Cargo.toml [dependencies]\n- [ ] No code imports colored\n- [ ] cargo check passes\n- [ ] cargo test passes\n- [ ] CLI works correctly in both modes","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T21:09:40.401060023Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:40.445503361Z","compaction_level":0,"original_size":0,"labels":["cleanup","dependencies","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-2rh7","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:09:40.440219512Z","created_by":"ubuntu"},{"issue_id":"bd-2rh7","depends_on_id":"bd-2ui5","type":"blocks","created_at":"2026-01-19T21:09:40.445470679Z","created_by":"ubuntu"}]}
{"id":"bd-2sd","title":"Integrate gesture detector with watch loop","description":"Modify watch loop:\n1. If --gestures, use GestureDetector\n2. Pass raw events through detector\n3. Emit gesture events instead of raw events\n4. Call tick() periodically for held keys and deferred taps","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.324903187Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.334627155Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sd","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.334583503Z","created_by":"ubuntu"}]}
{"id":"bd-2sp","title":"Add timeout support for commands","description":"If --exec-timeout specified:\n1. Spawn command\n2. Wait with timeout\n3. Kill if exceeds timeout\n4. Report timeout in robot mode\n\nUse std::process::Child with wait_timeout or similar.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.671716912Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:19.687064749Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sp","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.687008323Z","created_by":"ubuntu"}]}
{"id":"bd-2t5","title":"Add configuration export/import","description":"GET /api/config → YAML configuration\nPOST /api/config with YAML → apply configuration\n\nIntegrates with declarative config system.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:49.338508012Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:49.356031806Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2t5","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:49.355979357Z","created_by":"ubuntu"}]}
{"id":"bd-2ui","title":"Implement basic file watcher","description":"## Purpose\nCreate robust file watching infrastructure for hot-reload configuration using the notify crate.\n\n## Implementation\n```rust\n// src/watch_config.rs\nuse notify::{\n    Config, Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher,\n    event::{ModifyKind, DataChange},\n};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc::{channel, Receiver};\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, info, warn, error, instrument, span, Level};\n\n/// File watcher for configuration hot-reload\npub struct ConfigWatcher {\n    watcher: RecommendedWatcher,\n    receiver: Receiver<Result<Event, notify::Error>>,\n    config_path: PathBuf,\n    debounce_duration: Duration,\n    last_event_time: Option<Instant>,\n}\n\nimpl ConfigWatcher {\n    /// Create a new config watcher for the given path\n    #[instrument(skip_all, fields(path = %config_path.display()))]\n    pub fn new(config_path: PathBuf, debounce_ms: u64) -> Result<Self, WatchError> {\n        // Verify file exists and is readable\n        if !config_path.exists() {\n            return Err(WatchError::FileNotFound(config_path.clone()));\n        }\n        \n        if !config_path.is_file() {\n            return Err(WatchError::NotAFile(config_path.clone()));\n        }\n        \n        let (tx, rx) = channel();\n        \n        // Create watcher with recommended settings\n        let watcher = RecommendedWatcher::new(\n            move |res: Result<Event, notify::Error>| {\n                let _ = tx.send(res);\n            },\n            Config::default()\n                .with_poll_interval(Duration::from_millis(500))\n                .with_compare_contents(true),  // Detect content changes, not just metadata\n        )?;\n        \n        info!(\"Config watcher initialized\");\n        \n        Ok(Self {\n            watcher,\n            receiver: rx,\n            config_path,\n            debounce_duration: Duration::from_millis(debounce_ms),\n            last_event_time: None,\n        })\n    }\n    \n    /// Start watching the config file\n    #[instrument(skip(self))]\n    pub fn start_watching(&mut self) -> Result<(), WatchError> {\n        // Watch the parent directory to handle editors that use atomic saves\n        // (write to temp, rename to target)\n        let parent = self.config_path.parent()\n            .ok_or_else(|| WatchError::NoParentDir(self.config_path.clone()))?;\n        \n        trace!(dir = %parent.display(), \"Watching parent directory\");\n        self.watcher.watch(parent, RecursiveMode::NonRecursive)?;\n        \n        info!(path = %self.config_path.display(), \"Started watching config file\");\n        Ok(())\n    }\n    \n    /// Stop watching\n    pub fn stop_watching(&mut self) -> Result<(), WatchError> {\n        if let Some(parent) = self.config_path.parent() {\n            self.watcher.unwatch(parent)?;\n        }\n        info!(\"Stopped watching config file\");\n        Ok(())\n    }\n    \n    /// Poll for file changes with timeout\n    /// Returns Some(()) if config file changed, None if timeout\n    #[instrument(skip(self), level = \"trace\")]\n    pub fn poll_change(&mut self, timeout: Duration) -> Result<Option<()>, WatchError> {\n        match self.receiver.recv_timeout(timeout) {\n            Ok(Ok(event)) => {\n                if self.is_relevant_event(&event) {\n                    // Debounce: ignore events too close together\n                    if let Some(last_time) = self.last_event_time {\n                        if last_time.elapsed() < self.debounce_duration {\n                            trace!(\n                                elapsed_ms = %last_time.elapsed().as_millis(),\n                                debounce_ms = %self.debounce_duration.as_millis(),\n                                \"Event within debounce window, skipping\"\n                            );\n                            return Ok(None);\n                        }\n                    }\n                    \n                    self.last_event_time = Some(Instant::now());\n                    debug!(kind = ?event.kind, \"Config file changed\");\n                    Ok(Some(()))\n                } else {\n                    trace!(kind = ?event.kind, \"Ignoring irrelevant event\");\n                    Ok(None)\n                }\n            }\n            Ok(Err(e)) => {\n                warn!(error = %e, \"Watch error\");\n                Err(WatchError::Notify(e))\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => {\n                Ok(None)\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => {\n                error!(\"Watch channel disconnected\");\n                Err(WatchError::ChannelDisconnected)\n            }\n        }\n    }\n    \n    /// Check if this event is relevant to our config file\n    fn is_relevant_event(&self, event: &Event) -> bool {\n        // Must involve our config file\n        let involves_config = event.paths.iter().any(|p| {\n            p == &self.config_path || \n            p.file_name() == self.config_path.file_name()\n        });\n        \n        if !involves_config {\n            return false;\n        }\n        \n        // Must be a modify or create event (handles atomic saves)\n        matches!(\n            event.kind,\n            EventKind::Modify(ModifyKind::Data(_)) |\n            EventKind::Modify(ModifyKind::Any) |\n            EventKind::Create(_)\n        )\n    }\n    \n    /// Get the path being watched\n    pub fn config_path(&self) -> &Path {\n        &self.config_path\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum WatchError {\n    #[error(\"Config file not found: {0}\")]\n    FileNotFound(PathBuf),\n    \n    #[error(\"Path is not a file: {0}\")]\n    NotAFile(PathBuf),\n    \n    #[error(\"Cannot determine parent directory: {0}\")]\n    NoParentDir(PathBuf),\n    \n    #[error(\"Notify error: {0}\")]\n    Notify(#[from] notify::Error),\n    \n    #[error(\"Watch channel disconnected\")]\n    ChannelDisconnected,\n}\n\n/// Watch loop that applies config on changes\n#[instrument(skip_all, fields(config = %config_path.display()))]\npub fn run_watch_loop<F>(\n    config_path: PathBuf,\n    debounce_ms: u64,\n    mut apply_fn: F,\n) -> Result<(), WatchError>\nwhere\n    F: FnMut(&Path) -> Result<usize, Box<dyn std::error::Error>>,\n{\n    let mut watcher = ConfigWatcher::new(config_path.clone(), debounce_ms)?;\n    watcher.start_watching()?;\n    \n    // Initial apply\n    info!(\"Applying initial configuration\");\n    match apply_fn(&config_path) {\n        Ok(changes) => info!(changes = %changes, \"Initial configuration applied\"),\n        Err(e) => error!(error = %e, \"Failed to apply initial configuration\"),\n    }\n    \n    println!(\"Watching {} for changes (Ctrl+C to stop)...\", config_path.display());\n    \n    loop {\n        match watcher.poll_change(Duration::from_millis(100)) {\n            Ok(Some(())) => {\n                info!(\"Change detected, reloading\");\n                match apply_fn(&config_path) {\n                    Ok(changes) => {\n                        info!(changes = %changes, \"Configuration reloaded\");\n                        println!(\"[{}] Applied {} changes\", \n                            chrono::Local::now().format(\"%H:%M:%S\"),\n                            changes);\n                    }\n                    Err(e) => {\n                        error!(error = %e, \"Failed to apply configuration\");\n                        eprintln!(\"[{}] Error: {}\", \n                            chrono::Local::now().format(\"%H:%M:%S\"),\n                            e);\n                    }\n                }\n            }\n            Ok(None) => {\n                // Timeout, continue loop\n            }\n            Err(WatchError::ChannelDisconnected) => {\n                info!(\"Watcher shutting down\");\n                break;\n            }\n            Err(e) => {\n                error!(error = %e, \"Watch error\");\n            }\n        }\n    }\n    \n    watcher.stop_watching()?;\n    Ok(())\n}\n```\n\n## Editor Compatibility Notes\nDifferent editors save files differently:\n- **vim/neovim**: Writes to temp file, then renames (atomic)\n- **VSCode**: Direct write to file\n- **Sublime Text**: Creates backup, writes, deletes backup\n- **IntelliJ**: Uses safe write with temp file\n\nBy watching the parent directory and handling both Modify and Create events, we handle all these cases.\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_watcher_creation() {\n        let temp = TempDir::new().unwrap();\n        let config = temp.path().join(\"config.yaml\");\n        std::fs::write(&config, \"test: true\").unwrap();\n        \n        let watcher = ConfigWatcher::new(config, 100);\n        assert!(watcher.is_ok());\n    }\n    \n    #[test]\n    fn test_watcher_file_not_found() {\n        let result = ConfigWatcher::new(PathBuf::from(\"/nonexistent/config.yaml\"), 100);\n        assert!(matches!(result, Err(WatchError::FileNotFound(_))));\n    }\n    \n    #[test]\n    fn test_debounce() {\n        let temp = TempDir::new().unwrap();\n        let config = temp.path().join(\"config.yaml\");\n        std::fs::write(&config, \"test: true\").unwrap();\n        \n        let mut watcher = ConfigWatcher::new(config.clone(), 500).unwrap();\n        watcher.start_watching().unwrap();\n        \n        // Rapid modifications should be debounced\n        for _ in 0..5 {\n            std::fs::write(&config, \"test: modified\").unwrap();\n            std::thread::sleep(Duration::from_millis(50));\n        }\n        \n        // Should only register one change due to debouncing\n        // (Test timing is tricky, this is more of a smoke test)\n    }\n}\n```\n\n## Success Criteria\n- [ ] Watcher created successfully for existing files\n- [ ] Error on non-existent or non-file paths\n- [ ] Events debounced within configured window\n- [ ] Handles vim/VSCode/Sublime atomic saves\n- [ ] Clean shutdown with stop_watching()\n- [ ] Initial config applied on start\n\n## Logging Requirements\n- TRACE: Watching parent directory, event details, debounce skips, irrelevant events\n- DEBUG: Config file changed (relevant events)\n- INFO: Watcher initialized, started/stopped watching, change detected, config reloaded\n- WARN: Watch error events\n- ERROR: Channel disconnected, failed to apply config","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.905192428Z","created_by":"ubuntu","updated_at":"2026-01-19T20:51:09.904332649Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ui","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.915490016Z","created_by":"ubuntu"}]}
{"id":"bd-2ui5","title":"Update all command functions to use Output trait","description":"# Update all command functions to use Output trait\n\n## Purpose\nTransform each command function to use the Output trait instead of direct println! calls. This is the detailed implementation work that connects commands to the new output system.\n\n## Command Functions to Update\n\n### 1. cmd_list\n```rust\n// Before\nfn cmd_list(cli: &Cli, args: &ListArgs) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    if cli.use_json() {\n        println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n    } else {\n        if args.long {\n            // detailed output\n        } else {\n            for device in &devices {\n                println!(\"{}\", device.serial);\n            }\n        }\n    }\n    Ok(())\n}\n\n// After\nfn cmd_list(cli: &Cli, args: &ListArgs, output: &dyn Output) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    output.device_list(&devices);\n    Ok(())\n}\n```\n\n### 2. cmd_info\n```rust\nfn cmd_info(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    output.device_info(&device.info);\n    Ok(())\n}\n```\n\n### 3. cmd_brightness\n```rust\nfn cmd_brightness(cli: &Cli, args: &BrightnessArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::set_brightness(&device, args.level)?;\n    output.brightness_set(args.level);\n    Ok(())\n}\n```\n\n### 4. cmd_set_key\n```rust\nfn cmd_set_key(cli: &Cli, args: &SetKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::set_key_image(&device, args.key, &args.image)?;\n    output.key_set(args.key, &args.image);\n    Ok(())\n}\n```\n\n### 5. cmd_clear_key\n```rust\nfn cmd_clear_key(cli: &Cli, args: &ClearKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::clear_key(&device, args.key)?;\n    output.key_cleared(args.key);\n    Ok(())\n}\n```\n\n### 6. cmd_clear_all\n```rust\nfn cmd_clear_all(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::clear_all_keys(&device)?;\n    output.all_cleared();\n    Ok(())\n}\n```\n\n### 7. cmd_fill_key\n```rust\nfn cmd_fill_key(cli: &Cli, args: &FillKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let color = parse_color(&args.color)?;\n    device::fill_key_color(&device, args.key, color)?;\n    output.key_filled(args.key, &args.color);\n    Ok(())\n}\n```\n\n### 8. cmd_fill_all\n```rust\nfn cmd_fill_all(cli: &Cli, args: &FillAllArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let color = parse_color(&args.color)?;\n    device::fill_all_keys_color(&device, color)?;\n    output.all_filled(&args.color);\n    Ok(())\n}\n```\n\n### 9. cmd_watch\n```rust\nfn cmd_watch(cli: &Cli, args: &WatchArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    \n    // Human mode header (no-op in robot mode)\n    output.rule(Some(\"Button Events\"));\n    \n    // Watch loop with output trait\n    device::watch_buttons_with_output(&device, output, args.once, args.timeout)?;\n    \n    Ok(())\n}\n```\n\n### 10. cmd_read\n```rust\nfn cmd_read(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let states = device::read_button_states(&device);\n    output.button_states(&states);\n    Ok(())\n}\n```\n\n### 11. cmd_version\n```rust\nfn cmd_version(output: &dyn Output) -> Result<(), SdError> {\n    let version = env!(\"CARGO_PKG_VERSION\");\n    let git_sha = option_env!(\"VERGEN_GIT_SHA\").map(|s| {\n        if option_env!(\"VERGEN_GIT_DIRTY\") == Some(\"true\") {\n            format!(\"{} (dirty)\", s)\n        } else {\n            s.to_string()\n        }\n    });\n    let build_time = option_env!(\"VERGEN_BUILD_TIMESTAMP\");\n    \n    output.version_info(version, git_sha.as_deref(), build_time);\n    Ok(())\n}\n```\n\n## Pattern: Device Operations\nMost commands follow this pattern:\n1. Open device (may error)\n2. Perform operation (may error)\n3. Output success confirmation\n\n```rust\nfn cmd_operation(cli: &Cli, args: &Args, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::do_something(&device, args.param)?;\n    output.something_done(args.param);\n    Ok(())\n}\n```\n\n## Watch Command Special Case\nThe watch command needs to stream events, so device.rs watch function needs to accept the output trait:\n\n```rust\n// In device.rs\npub fn watch_buttons_with_output(\n    device: &Device,\n    output: &dyn Output,\n    once: bool,\n    timeout_secs: u64,\n) -> Result<(), SdError> {\n    loop {\n        match device.inner.read_input(Duration::from_millis(50)) {\n            Ok(Some(StreamDeckInput::ButtonStateChange(states))) => {\n                for (key, &pressed) in states.iter().enumerate() {\n                    if pressed {\n                        let event = ButtonEvent {\n                            key: key as u8,\n                            pressed: true,\n                            timestamp_ms: current_timestamp_ms(),\n                        };\n                        output.button_event(&event);\n                        \n                        if once {\n                            return Ok(());\n                        }\n                    }\n                }\n            }\n            _ => {}\n        }\n    }\n}\n```\n\n## Verification Checklist\nFor each command:\n- [ ] Function signature updated with output: &dyn Output\n- [ ] All println! calls removed\n- [ ] Appropriate output method called\n- [ ] Robot mode JSON unchanged\n- [ ] Human mode displays styled output\n\n## Acceptance Criteria\n- [ ] All 11 command functions updated\n- [ ] No direct println! in command functions\n- [ ] Watch command streams events via output trait\n- [ ] Version command shows all metadata\n- [ ] Each command produces correct output in both modes","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:09:24.071519014Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:24.112452875Z","compaction_level":0,"original_size":0,"labels":["commands","phase-3","refactor","rich-rust"],"dependencies":[{"issue_id":"bd-2ui5","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:09:24.106899168Z","created_by":"ubuntu"},{"issue_id":"bd-2ui5","depends_on_id":"bd-2mvm","type":"blocks","created_at":"2026-01-19T21:09:24.112411787Z","created_by":"ubuntu"}]}
{"id":"bd-2vg","title":"Implement config loading (YAML + TOML)","description":"## Purpose\nLoad declarative configuration from YAML or TOML files with validation.\n\n## Implementation\n\n```rust\n// src/config/loader.rs\nuse std::path::Path;\nuse tracing::{debug, info, warn, instrument};\n\n#[derive(Debug, Clone)]\npub enum ConfigFormat {\n    Yaml,\n    Toml,\n}\n\nimpl ConfigFormat {\n    pub fn from_extension(path: &Path) -> Option<Self> {\n        match path.extension()?.to_str()? {\n            \"yaml\" | \"yml\" => Some(Self::Yaml),\n            \"toml\" => Some(Self::Toml),\n            _ => None,\n        }\n    }\n}\n\n/// Load and parse a configuration file\n#[instrument(fields(path = %path.display()))]\npub fn load_config(path: &Path) -> Result<ProfileConfig, ConfigError> {\n    info!(\"Loading configuration file\");\n    \n    // Detect format\n    let format = ConfigFormat::from_extension(path)\n        .ok_or_else(|| ConfigError::UnknownFormat(path.to_path_buf()))?;\n    debug!(format = ?format, \"Detected config format\");\n    \n    // Read file\n    let content = std::fs::read_to_string(path)\n        .map_err(|e| ConfigError::ReadError(path.to_path_buf(), e))?;\n    debug!(bytes = %content.len(), \"Read config file\");\n    \n    // Parse based on format\n    let config: ProfileConfig = match format {\n        ConfigFormat::Yaml => {\n            serde_yaml::from_str(&content)\n                .map_err(|e| ConfigError::ParseError(format!(\"YAML: {}\", e)))?\n        }\n        ConfigFormat::Toml => {\n            toml::from_str(&content)\n                .map_err(|e| ConfigError::ParseError(format!(\"TOML: {}\", e)))?\n        }\n    };\n    \n    // Validate\n    config.validate()?;\n    \n    info!(\n        keys = %config.keys.len(),\n        brightness = ?config.brightness,\n        \"Configuration loaded successfully\"\n    );\n    \n    Ok(config)\n}\n\n#[derive(Debug, Clone, serde::Deserialize)]\npub struct ProfileConfig {\n    /// Optional profile name\n    pub name: Option<String>,\n    /// Target device serial (optional)\n    pub device: Option<String>,\n    /// Brightness level (0-100)\n    pub brightness: Option<u8>,\n    /// Key configurations\n    #[serde(default)]\n    pub keys: Vec<KeyConfig>,\n}\n\nimpl ProfileConfig {\n    pub fn validate(&self) -> Result<(), ConfigError> {\n        // Validate brightness range\n        if let Some(b) = self.brightness {\n            if b > 100 {\n                return Err(ConfigError::ValidationError(\n                    format!(\"brightness {} out of range (0-100)\", b)\n                ));\n            }\n        }\n        \n        // Validate each key config\n        for key in &self.keys {\n            key.validate()?;\n        }\n        \n        Ok(())\n    }\n}\n```\n\n## Dependencies\n```toml\n# Cargo.toml additions\nserde_yaml = \"0.9\"\ntoml = \"0.8\"\n```\n\n## Edge Cases\n- File not found → clear error with path\n- Permission denied → clear error\n- Empty file → empty config (valid)\n- Duplicate keys → last wins with warning\n- Unknown fields → ignored (forward compat)\n- Invalid UTF-8 → ParseError\n\n## Logging Requirements\n- TRACE: Individual field parsing\n- DEBUG: Format detection, file read, key parsing\n- INFO: Load start/complete with summary\n- WARN: Unknown fields, duplicate keys\n- ERROR: Parse failures, validation errors\n\n## Success Criteria\n- [ ] YAML files load correctly\n- [ ] TOML files load correctly\n- [ ] Format auto-detected from extension\n- [ ] Validation catches invalid values\n- [ ] Clear errors for common issues","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.427405742Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:26.102849039Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2vg","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.441503776Z","created_by":"ubuntu"}]}
{"id":"bd-2xx","title":"Build frontend HTML structure","description":"Create static/index.html:\n- Device info display\n- Grid of keys matching device layout\n- Brightness slider\n- Drag-and-drop zones for images\n- Color picker\n\nKeep minimal - vanilla JS preferred.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.901045537Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:47.916799168Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2xx","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.916732602Z","created_by":"ubuntu"}]}
{"id":"bd-2yg","title":"Add snapshot show/delete commands","description":"Implement:\n- sd snapshot show <name>: Display snapshot contents (keys, brightness)\n- sd snapshot delete <name>: Remove snapshot with confirmation\n\nNote: deletion should be explicit, not part of normal workflow","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.566787383Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.576297149Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yg","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.576243097Z","created_by":"ubuntu"}]}
{"id":"bd-2ys","title":"Implement device_info rich output with Table and key layout grid","description":"# Implement device_info rich output with Table and key layout grid\n\n## Purpose\nCreate a comprehensive, visually stunning device information display using a Table for specifications and an ASCII art key layout grid. This command provides the detailed view when a user wants to understand their device.\n\n## Target Output\n```\n╭──────────────────── Stream Deck XL ─────────────────────╮\n│                                                         │\n│  ┌─────────────┬────────────────────────────────────┐   │\n│  │ Serial      │ AL12U1E1234                        │   │\n│  │ Firmware    │ 1.5.3                              │   │\n│  │ Keys        │ 32 (8 columns × 4 rows)            │   │\n│  │ Key Size    │ 96×96 pixels                       │   │\n│  │ Device Type │ Xl                                 │   │\n│  └─────────────┴────────────────────────────────────┘   │\n│                                                         │\n│  Key Layout:                                            │\n│  ┌──┬──┬──┬──┬──┬──┬──┬──┐                              │\n│  │ 0│ 1│ 2│ 3│ 4│ 5│ 6│ 7│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │ 8│ 9│10│11│12│13│14│15│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │16│17│18│19│20│21│22│23│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │24│25│26│27│28│29│30│31│                              │\n│  └──┴──┴──┴──┴──┴──┴──┴──┘                              │\n│                                                         │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Key Layout Grid Generator\n```rust\nimpl HumanOutput {\n    /// Generate ASCII art key layout grid\n    fn render_key_layout(&self, rows: u8, cols: u8) -> String {\n        let mut grid = String::new();\n        \n        // Calculate cell width (need room for 2-digit numbers)\n        let cell_width = 2;\n        \n        // Top border\n        grid.push_str(\"  ┌\");\n        for c in 0..cols {\n            grid.push_str(&\"─\".repeat(cell_width));\n            if c < cols - 1 { grid.push('┬'); }\n        }\n        grid.push_str(\"┐\\n\");\n        \n        // Rows with content\n        for r in 0..rows {\n            grid.push_str(\"  │\");\n            for c in 0..cols {\n                let key_num = r * cols + c;\n                grid.push_str(&format!(\"{:>2}\", key_num));\n                if c < cols - 1 { grid.push('│'); }\n            }\n            grid.push_str(\"│\\n\");\n            \n            // Row separator (except after last row)\n            if r < rows - 1 {\n                grid.push_str(\"  ├\");\n                for c in 0..cols {\n                    grid.push_str(&\"─\".repeat(cell_width));\n                    if c < cols - 1 { grid.push('┼'); }\n                }\n                grid.push_str(\"┤\\n\");\n            }\n        }\n        \n        // Bottom border\n        grid.push_str(\"  └\");\n        for c in 0..cols {\n            grid.push_str(&\"─\".repeat(cell_width));\n            if c < cols - 1 { grid.push('┴'); }\n        }\n        grid.push_str(\"┘\\n\");\n        \n        grid\n    }\n}\n```\n\n### device_info Method\n```rust\nfn device_info(&self, info: &DeviceInfo) {\n    // Build specification table\n    let mut table = Table::new()\n        .with_column(Column::new(\"\").style(self.theme.label.clone()))\n        .with_column(Column::new(\"\").style(self.theme.value.clone()))\n        .box_style(&BoxChars::ROUNDED);\n    \n    table.add_row_cells([\"Serial\", &info.serial]);\n    table.add_row_cells([\"Firmware\", &info.firmware_version]);\n    table.add_row_cells([\"Keys\", &format!(\"{} ({} columns × {} rows)\", \n        info.key_count, info.cols, info.rows)]);\n    table.add_row_cells([\"Key Size\", &format!(\"{}×{} pixels\", \n        info.key_width, info.key_height)]);\n    table.add_row_cells([\"Device Type\", &info.kind]);\n    \n    // Render table to segments\n    let table_segments = table.render(self.width().saturating_sub(6));\n    \n    // Build key layout\n    let key_layout = self.render_key_layout(info.rows, info.cols);\n    \n    // Combine into content\n    let mut content = Text::new(\"\");\n    content.append(\"\\n\");\n    \n    // Add table (need to convert segments to text)\n    for segment in table_segments {\n        content.append(&segment.text);\n    }\n    \n    content.append(\"\\n\");\n    content.append_styled(\"  Key Layout:\\n\", self.theme.label.clone());\n    content.append(&key_layout);\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(&info.product_name)\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Table for Specifications\n- Key-value pairs are perfect for table layout\n- Labels in left column, values in right\n- Consistent alignment improves scannability\n\n### Key Layout Grid\n- ASCII art provides immediate visual understanding\n- Shows key numbering convention (left-to-right, top-to-bottom)\n- Essential for users setting up key configurations\n- Uses box-drawing characters that match panel style\n\n### Panel Title\n- Uses device product name (e.g., \"Stream Deck XL\")\n- Centered in panel header for prominence\n\n### Information Selection\n- Serial: Needed for multi-device scenarios\n- Firmware: Useful for troubleshooting\n- Keys: Count and layout dimensions\n- Key Size: Important for image preparation\n- Device Type: Internal identifier\n\n## Edge Cases\n- Stream Deck Mini (6 keys, 3×2): Smaller grid\n- Stream Deck Original (15 keys, 5×3): Medium grid\n- Stream Deck XL (32 keys, 8×4): Full grid as shown\n- Stream Deck + (8 keys, 4×2): Narrow grid\n\n## Testing\n```rust\n#[test]\nfn key_layout_grid_dimensions() {\n    let output = HumanOutput::new(test_console());\n    \n    let grid = output.render_key_layout(4, 8);\n    \n    // Verify grid has correct number of rows\n    assert_eq!(grid.lines().count(), 9); // 4 data rows + 5 border rows\n    \n    // Verify key numbers are correct\n    assert!(grid.contains(\"│ 0│ 1│\"));\n    assert!(grid.contains(\"│24│25│\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] Device info renders in styled panel\n- [ ] Table shows all device specifications\n- [ ] Key layout grid is accurate for device dimensions\n- [ ] Grid uses box-drawing characters\n- [ ] Panel title shows device name\n- [ ] Works for all Stream Deck models","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:05:59.366035813Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:59.415305398Z","compaction_level":0,"original_size":0,"labels":["device","info","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-2ys","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:05:59.415277315Z","created_by":"ubuntu"},{"issue_id":"bd-2ys","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:05:59.411015120Z","created_by":"ubuntu"}]}
{"id":"bd-305","title":"Add SetKeys command struct to CLI","description":"## Add SetKeys Command Struct to CLI\n\n### Command Definition (src/cli/mod.rs)\n\n```rust\n/// Set multiple keys from a directory of images\n#[derive(Parser, Debug)]\npub struct SetKeysCommand {\n    /// Directory containing key images\n    #[arg(value_name = \"DIR\")]\n    pub dir: PathBuf,\n\n    /// Filename pattern with {index} placeholder\n    /// Examples: \"key-{index}.png\", \"icon_{index:02d}.jpg\"\n    #[arg(long, short = 'p', default_value = \"key-{index}.png\")]\n    pub pattern: String,\n\n    /// Continue setting other keys if one fails\n    #[arg(long, short = 'c')]\n    pub continue_on_error: bool,\n\n    /// Starting key index (for partial layouts)\n    #[arg(long, default_value = \"0\")]\n    pub start_key: u8,\n\n    /// Only process keys in this range (e.g., \"0-7\" for first row)\n    #[arg(long)]\n    pub key_range: Option<String>,\n\n    /// Dry run - show what would happen without applying\n    /// (Note: This is covered by global --dry-run flag, but explicit here for discoverability)\n    #[arg(long, short = 'n')]\n    pub dry_run: bool,\n\n    /// Clear keys that don't have matching images\n    #[arg(long)]\n    pub clear_missing: bool,\n\n    /// Skip keys that already have the same image (compare by hash)\n    #[arg(long)]\n    pub skip_unchanged: bool,\n\n    /// Maximum concurrent key sets (for performance tuning)\n    #[arg(long, default_value = \"1\")]\n    pub concurrency: u8,\n}\n```\n\n### Command Registration\n\n```rust\n#[derive(Subcommand, Debug)]\npub enum Command {\n    // ... existing commands\n    \n    /// Set multiple keys from a directory of images\n    #[command(visible_alias = \"batch\")]\n    SetKeys(SetKeysCommand),\n}\n```\n\n### Help Text\n\n```\nUSAGE:\n    sd set-keys [OPTIONS] <DIR>\n\nARGS:\n    <DIR>    Directory containing key images\n\nOPTIONS:\n    -p, --pattern <PATTERN>     Filename pattern [default: key-{index}.png]\n    -c, --continue-on-error     Continue if individual keys fail\n        --start-key <N>         Starting key index [default: 0]\n        --key-range <RANGE>     Only process keys in range (e.g., \"0-7\")\n    -n, --dry-run               Preview without applying changes\n        --clear-missing         Clear keys without matching images\n        --skip-unchanged        Skip keys with identical images\n        --concurrency <N>       Parallel key operations [default: 1]\n    -h, --help                  Print help\n\nEXAMPLES:\n    # Set all keys from directory\n    sd set-keys ~/my-layout/\n\n    # Use custom naming pattern\n    sd set-keys ~/icons/ --pattern \"icon-{index:02d}.png\"\n\n    # Only set first row (keys 0-7 on XL)\n    sd set-keys ~/row1/ --key-range 0-7\n\n    # Preview changes first\n    sd set-keys ~/layout/ --dry-run\n```\n\n### Pattern Syntax Documentation\n\nThe pattern supports these placeholders:\n- `{index}` - Key index as decimal (0, 1, 2, ...)\n- `{index:02d}` - Key index with zero-padding (00, 01, 02, ...)\n- `{index:X}` - Key index as uppercase hex (0, 1, ..., A, B, ...)\n- `{row}` - Row number (0-3 for XL)\n- `{col}` - Column number (0-7 for XL)","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:41.964096116Z","created_by":"ubuntu","updated_at":"2026-01-19T20:41:36.704105072Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-305","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:41.982464199Z","created_by":"ubuntu"}]}
{"id":"bd-319","title":"Add --profile support for saved profiles","description":"With --profile <name>:\n- Load profile from snapshot/config storage\n- Generate script from stored state instead of session\n- Allows exporting saved configurations\n\nRequires: SAVE-RESTORE or DECLARATIVE-CONFIG to be implemented.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:02.945280338Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:02.961325127Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-319","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.961283929Z","created_by":"ubuntu"}]}
{"id":"bd-31u","title":"EPIC: Testing & Observability Infrastructure","description":"## Overview\n**FOUNDATIONAL EPIC** - Must be implemented early as other epics depend on this infrastructure.\n\nThis epic establishes the testing and observability foundation that enables comprehensive quality assurance across all features.\n\n## Problem Statement\nWithout proper testing infrastructure:\n- Unit tests cannot mock device interactions\n- Integration tests have no way to simulate USB devices\n- E2E tests lack consistent harness and reporting\n- Debugging production issues is difficult without logging\n- CI/CD cannot run device-dependent tests\n\n## Components\n\n### 1. Mock Device Layer\nA mock implementation of the Stream Deck device interface that:\n- Simulates all device operations (set_key, brightness, etc.)\n- Records all operations for assertion\n- Can simulate errors and edge cases\n- Supports configurable device models (XL, MK2, Mini)\n\n### 2. Test Harness\nConsistent test infrastructure including:\n- Test fixtures for common scenarios\n- Sample images in various formats\n- Sample profile files (Elgato format)\n- Declarative config test files\n- Snapshot comparison utilities\n\n### 3. Logging Infrastructure\nStructured logging using tracing crate:\n- Configurable log levels via RUST_LOG\n- Structured JSON output for robot mode\n- Human-readable output for terminal\n- Performance timing spans\n- Error context capture\n\n### 4. E2E Test Framework\nEnd-to-end testing infrastructure:\n- CLI invocation helpers\n- Output capture and parsing\n- Robot mode JSON validation\n- Exit code assertions\n- Timeout handling\n\n## Why This Is Foundational\nEvery feature epic needs:\n- Unit tests → requires mock device\n- Integration tests → requires test harness\n- E2E tests → requires CLI test framework\n- Debugging → requires logging\n\nImplementing this first enables parallel development of other features with proper testing.\n\n## Success Criteria\n- [ ] Mock device passes all unit tests without real hardware\n- [ ] Test harness provides fixtures for all test scenarios\n- [ ] Logging captures all operations with context\n- [ ] E2E framework can test any CLI command\n- [ ] CI can run full test suite without Stream Deck hardware\n\n## Architecture\n```\n┌─────────────────────────────────────────────┐\n│                 CLI Layer                    │\n├─────────────────────────────────────────────┤\n│              Device Trait                    │\n├──────────────────┬──────────────────────────┤\n│   Real Device    │      Mock Device          │\n│ (elgato-streamdeck)│  (testing only)         │\n└──────────────────┴──────────────────────────┘\n```\n\n## Files to Create\n- `src/device/mod.rs`: Device trait extraction\n- `src/device/real.rs`: Real device implementation\n- `src/device/mock.rs`: Mock device for testing\n- `src/logging.rs`: Tracing setup\n- `tests/common/mod.rs`: Test utilities\n- `tests/fixtures/`: Test data files\n- `tests/e2e/`: E2E test modules","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:35:36.861992209Z","created_by":"ubuntu","updated_at":"2026-01-19T18:35:36.903036908Z","compaction_level":0,"original_size":0,"labels":["foundation","infrastructure","logging","testing"]}
{"id":"bd-326","title":"Implement auto-reconnect for watch command","description":"## Purpose\nAdd automatic reconnection to the watch command for robust long-running operation.\n\n## Implementation\n\n```rust\n// In src/cli/watch.rs\nuse std::time::Duration;\nuse tracing::{debug, info, warn, error, instrument};\n\nconst MAX_RECONNECT_DELAY: Duration = Duration::from_secs(30);\nconst INITIAL_RECONNECT_DELAY: Duration = Duration::from_secs(1);\nconst BACKOFF_FACTOR: f32 = 1.5;\n\n#[derive(Debug, Clone)]\npub struct WatchOptions {\n    pub reconnect: bool,\n    pub reconnect_delay: Duration,\n    pub max_reconnect_attempts: Option<u32>,\n}\n\n#[instrument(skip(device, opts))]\npub async fn watch_events(\n    mut device: Device,\n    opts: &WatchOptions,\n) -> Result<(), WatchError> {\n    let mut reconnect_delay = INITIAL_RECONNECT_DELAY;\n    let mut reconnect_attempts = 0;\n    \n    loop {\n        info!(\"Starting event watch loop\");\n        \n        match watch_loop(&device).await {\n            Ok(()) => {\n                // Normal exit (e.g., Ctrl+C)\n                info!(\"Watch loop exited normally\");\n                return Ok(());\n            }\n            Err(e) if e.is_connection_error() && opts.reconnect => {\n                reconnect_attempts += 1;\n                \n                // Check max attempts\n                if let Some(max) = opts.max_reconnect_attempts {\n                    if reconnect_attempts > max {\n                        error!(\n                            attempts = %reconnect_attempts,\n                            \"Max reconnection attempts exceeded\"\n                        );\n                        return Err(e);\n                    }\n                }\n                \n                warn!(\n                    error = %e,\n                    attempt = %reconnect_attempts,\n                    delay_secs = %reconnect_delay.as_secs_f32(),\n                    \"Connection lost, reconnecting\"\n                );\n                \n                // Emit disconnected event (robot mode)\n                emit_event(WatchEvent::Disconnected {\n                    reason: e.to_string(),\n                    reconnecting: true,\n                });\n                \n                // Wait before reconnecting\n                tokio::time::sleep(reconnect_delay).await;\n                \n                // Try to reconnect\n                match Device::open_with_retry(device.serial(), &Default::default()) {\n                    Ok(new_device) => {\n                        info!(\"Reconnected successfully\");\n                        device = new_device;\n                        reconnect_delay = INITIAL_RECONNECT_DELAY;\n                        reconnect_attempts = 0;\n                        \n                        // Emit reconnected event\n                        emit_event(WatchEvent::Reconnected {\n                            device_serial: device.serial().map(|s| s.to_string()),\n                        });\n                    }\n                    Err(e) => {\n                        warn!(error = %e, \"Reconnection attempt failed\");\n                        // Increase backoff for next attempt\n                        reconnect_delay = Duration::from_secs_f32(\n                            (reconnect_delay.as_secs_f32() * BACKOFF_FACTOR)\n                                .min(MAX_RECONNECT_DELAY.as_secs_f32())\n                        );\n                        continue;\n                    }\n                }\n            }\n            Err(e) => {\n                error!(error = %e, \"Watch loop failed\");\n                return Err(e);\n            }\n        }\n    }\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(tag = \"type\")]\npub enum WatchEvent {\n    KeyPress { key: u8, timestamp: String },\n    KeyRelease { key: u8, timestamp: String },\n    Disconnected { reason: String, reconnecting: bool },\n    Reconnected { device_serial: Option<String> },\n}\n```\n\n## CLI Flags\n- `--reconnect`: Enable auto-reconnect (default: off)\n- `--reconnect-delay <ms>`: Initial reconnect delay (default: 1000)\n- `--max-reconnect-attempts <n>`: Limit attempts (default: unlimited)\n\n## Edge Cases\n- Device unplugged → detect, reconnect\n- USB hub reset → detect, reconnect\n- System sleep/wake → detect, reconnect\n- Device never returns → respect max attempts or run forever\n- Different device connected → warn and reconnect to same serial\n\n## Logging Requirements\n- TRACE: Individual event read\n- DEBUG: Reconnection attempt details, backoff calculation\n- INFO: Watch start, reconnection success, normal exit\n- WARN: Connection lost (with context), reconnect failure\n- ERROR: Max attempts exceeded, unrecoverable error\n\n## Success Criteria\n- [ ] Watch survives device unplug/replug\n- [ ] Backoff prevents rapid reconnection spam\n- [ ] Robot mode emits disconnect/reconnect events\n- [ ] Human mode shows status messages\n- [ ] Ctrl+C exits cleanly even during reconnection","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.492377938Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:27.093511250Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-326","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.507471676Z","created_by":"ubuntu"}]}
{"id":"bd-33c","title":"Integrate cache into set_key_image","description":"Modify image setting flow:\n1. Check cache for pre-processed image\n2. If hit: use cached data directly\n3. If miss: load, resize, encode, cache, then send\n4. Report cache hit/miss for metrics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.075313942Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.084764195Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-33c","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.084713159Z","created_by":"ubuntu"}]}
{"id":"bd-34h","title":"Test across sleep/wake cycles","description":"Manual testing checklist:\n1. Start sd watch --reconnect\n2. Put machine to sleep\n3. Wake machine\n4. Verify automatic reconnection\n5. Test on Linux and macOS if possible","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:26.463127532Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:19.560988255Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-34h","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T21:03:19.560946086Z","created_by":"ubuntu"},{"issue_id":"bd-34h","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:12.408821481Z","created_by":"ubuntu"},{"issue_id":"bd-34h","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.477954358Z","created_by":"ubuntu"}]}
{"id":"bd-34i","title":"EPIC: Device State Snapshots (Save/Restore)","description":"## Overview\n**Rank: #2 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nAdd `sd save <name>` and `sd restore <name>` commands to capture and restore complete device state (key images + brightness).\n\n## Problem Statement\nUsers typically want to switch between different configurations:\n- \"Work mode\" with productivity app shortcuts\n- \"Gaming mode\" with game-specific macros\n- \"Streaming mode\" with OBS controls\n- \"Music mode\" with DAW controls\n\nCurrently, switching requires re-running 30+ commands or maintaining external scripts. There is no way to capture the current state and restore it later.\n\n## Solution\nNamed snapshots that capture the entire device state:\n```bash\nsd save work-mode      # Capture current state\nsd save gaming-mode    # Capture another state\nsd restore work-mode   # Switch back instantly\nsd snapshots           # List available snapshots\nsd snapshot delete gaming-mode  # Remove a snapshot\n```\n\n## Why This Is #2 Priority\n1. **Workflow enabler**: Makes the CLI usable for real multi-context workflows\n2. **Builds on config infrastructure**: The `src/config/` module already has SQLite and image storage\n3. **Complements batch ops**: Import images → set-keys → save = powerful workflow\n4. **Reversibility**: Currently the CLI is one-way; this adds the ability to go back\n\n## Technical Challenge: Reading Device State\n**Critical consideration**: Stream Deck hardware does NOT allow reading back key images. We can only:\n- Read current brightness level\n- Read button press events\n\nThis means we have two implementation approaches:\n\n### Approach A: Command History Tracking (Simpler)\nTrack what commands were applied during the session:\n```rust\nstruct SessionState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyState>,  // What we set, not what device has\n}\n\nenum KeyState {\n    Image(PathBuf),    // Source image path\n    Color(String),     // Hex color\n    Cleared,\n}\n```\n- Pro: Simple, works with any command sequence\n- Con: Only tracks current session; loses state on restart\n\n### Approach B: Config-First Workflow (More Robust)\nRequire users to work through config files:\n```bash\nsd apply work.yaml    # Apply a config\nsd save work-mode     # Save the config reference, not device state\nsd restore work-mode  # Re-apply the config\n```\n- Pro: Persistent, declarative, version-controllable\n- Con: Requires config system (#7) first\n\n### Recommended: Hybrid Approach\n1. Track command history during session (immediate value)\n2. When saving, store both the history AND resolved image data\n3. Restore by replaying the history or applying stored images\n\n## Implementation Approach\n```rust\n// In src/config/snapshots.rs (new file)\npub struct Snapshot {\n    pub name: String,\n    pub created_at: DateTime<Utc>,\n    pub brightness: u8,\n    pub keys: Vec<KeySnapshot>,\n}\n\npub struct KeySnapshot {\n    pub index: u8,\n    pub source: KeySource,\n    pub image_data: Option<Vec<u8>>,  // Cached resized image\n}\n\npub enum KeySource {\n    ImageFile(PathBuf),\n    Color(String),\n    Cleared,\n}\n\n// Storage in ~/.local/share/sd/snapshots/\n// - snapshots.db (SQLite index)\n// - images/<sha256>.bin (cached resized images)\n```\n\n## Key Design Decisions\n1. **Name-based access**: Human-readable names, not UUIDs\n2. **Store source AND cached**: Keep original paths for portability, cache for speed\n3. **Graceful degradation**: If source image moved, use cached version\n4. **Atomic restore**: All-or-nothing application\n5. **Conflict handling**: Prompt before overwriting existing snapshot name\n\n## Success Criteria\n- [ ] `sd save <name>` captures current tracked state\n- [ ] `sd restore <name>` applies a saved snapshot\n- [ ] `sd snapshots` lists all saved snapshots with metadata\n- [ ] `sd snapshot show <name>` displays snapshot contents\n- [ ] `sd snapshot delete <name>` removes a snapshot\n- [ ] Robot mode returns structured JSON for all operations\n- [ ] Graceful handling when source images are missing\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Save, Restore, Snapshots commands\n- `src/main.rs`: Add command handlers\n- `src/config/snapshots.rs`: New snapshot storage module\n- `src/state.rs`: Session state tracking (new)\n\n## Dependencies\n- Soft dependency on BATCH-OPS: batch operations make saving more useful\n- Soft dependency on DECLARATIVE-CONFIG: config-first workflow is cleaner\n\n## Estimated Subtasks\n1. Design snapshot storage schema\n2. Implement session state tracking\n3. Add save command with state serialization\n4. Add restore command with state application\n5. Add snapshots list command\n6. Add snapshot show/delete commands\n7. Implement image caching for snapshots\n8. Handle missing source images gracefully\n9. Add robot mode output\n10. Write tests","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:59.040775758Z","created_by":"ubuntu","updated_at":"2026-01-19T18:09:59.079746712Z","compaction_level":0,"original_size":0,"labels":["cli","config","priority-2","workflow"]}
{"id":"bd-35a","title":"EPIC: Dry-Run Mode for All Mutating Commands","description":"## Overview\n**Rank: #4 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Very High**\n\nAdd `--dry-run` global flag that shows what would happen without making changes to the device.\n\n## Problem Statement\nUsers experimenting with the CLI (especially AI agents) have no way to preview what a command will do before it executes. This leads to:\n- Trial-and-error workflows on physical hardware\n- Difficulty debugging \"why isnt my image showing?\"\n- Agents making changes without understanding consequences\n- No way to validate commands in CI/CD pipelines without a device\n\n## Solution\nA global `--dry-run` flag that validates and previews all operations:\n```bash\nsd set-key 5 ~/icon.png --dry-run\n# Output:\n# DRY RUN: Would set key 5\n#   Source: /home/user/icon.png (256x256 PNG)\n#   Resize: 72x72 using Lanczos3\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd brightness 80 --dry-run\n# Output:\n# DRY RUN: Would set brightness to 80%\n#   Current: 50% (if readable)\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd set-keys ~/layout/ --dry-run\n# Output:\n# DRY RUN: Would set 24 keys from /home/user/layout/\n#   Key 0: key-00.png (128x128 JPG) → resize to 72x72\n#   Key 1: key-01.png (72x72 PNG) → no resize needed\n#   Key 2: (no file found, would skip)\n#   ...\n```\n\n## Why This Is #4 Priority\n1. **Safety net**: Preview before committing to physical device\n2. **Debugging aid**: See exact image processing that will occur\n3. **Agent-friendly**: Validate operations without side effects\n4. **Low effort**: Simple flag, ~50 lines of code per command\n5. **Universal pattern**: Users immediately understand what --dry-run means\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - global flag\n#[derive(Parser)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Command,\n    \n    /// Preview what would happen without making changes\n    #[arg(long, global = true)]\n    pub dry_run: bool,\n    \n    // ... existing flags\n}\n\n// In main.rs - pass through to handlers\nfn cmd_brightness(device: &Device, level: u8, dry_run: bool, robot: bool) -> Result<()> {\n    if dry_run {\n        let info = DryRunInfo {\n            action: \"set_brightness\",\n            details: BrightnessDetails { level },\n            device: device.info(),\n        };\n        if robot {\n            println\\!(\"{}\", serde_json::to_string(&info)?);\n        } else {\n            println\\!(\"DRY RUN: Would set brightness to {level}%\");\n            println\\!(\"  Device: {} (serial: {})\", \n                device.info().model, \n                device.info().serial);\n        }\n        return Ok(());\n    }\n    device.set_brightness(level)\n}\n\nfn cmd_set_key(\n    device: &Device, \n    key: u8, \n    path: &Path, \n    dry_run: bool,\n    robot: bool\n) -> Result<()> {\n    // Always validate the image (even in dry-run)\n    let img = image::open(path)?;\n    let (w, h) = img.dimensions();\n    let key_size = device.info().key_size();\n    \n    if dry_run {\n        let needs_resize = w \\!= key_size.0 || h \\!= key_size.1;\n        let info = DryRunInfo {\n            action: \"set_key\",\n            details: SetKeyDetails {\n                key,\n                source_path: path.to_path_buf(),\n                source_dimensions: (w, h),\n                target_dimensions: key_size,\n                needs_resize,\n            },\n            device: device.info(),\n        };\n        // Output appropriately\n        return Ok(());\n    }\n    \n    // Actually do it\n    set_key_image(device, key, path)\n}\n```\n\n## Key Design Decisions\n1. **Global flag**: Applies to all mutating commands uniformly\n2. **Full validation**: Dry-run still validates inputs (image exists, parseable, etc.)\n3. **Structured output**: Robot mode gets JSON with full details\n4. **Human-friendly output**: Clear formatting for terminal users\n5. **Early exit**: Dry-run returns after preview, never touches device\n\n## What Dry-Run Shows\nFor each command type:\n- **brightness**: Target level, device info\n- **set-key**: Source path, dimensions, resize behavior, target key\n- **fill-key**: Key index, color value\n- **clear-key/clear-all**: Which keys would be cleared\n- **set-keys**: Full manifest of directory contents and what would happen\n\n## Robot Mode Output Structure\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key\",\n  \"would_succeed\": true,\n  \"details\": {\n    \"key\": 5,\n    \"source\": \"/path/to/image.png\",\n    \"source_dimensions\": [256, 256],\n    \"target_dimensions\": [72, 72],\n    \"resize_required\": true,\n    \"resize_filter\": \"lanczos3\"\n  },\n  \"device\": {\n    \"model\": \"Stream Deck XL\",\n    \"serial\": \"ABC123\",\n    \"key_count\": 32\n  }\n}\n```\n\n## Success Criteria\n- [ ] `--dry-run` flag available on all mutating commands\n- [ ] Dry-run validates inputs without touching device\n- [ ] Human-readable output explains what would happen\n- [ ] Robot mode returns structured JSON with full details\n- [ ] Errors during validation are reported normally\n- [ ] Works even when no device is connected (with limitations)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add global --dry-run flag\n- `src/main.rs`: Add dry_run parameter to all mutating command handlers\n\n## Dependencies\nNone - standalone feature\n\n## Estimated Subtasks\n1. Add global --dry-run flag to CLI\n2. Implement dry-run for brightness command\n3. Implement dry-run for set-key command\n4. Implement dry-run for fill-key command\n5. Implement dry-run for clear-key/clear-all commands\n6. Implement dry-run for set-keys (batch) command\n7. Design and implement robot mode JSON structure\n8. Write tests for dry-run behavior","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:10:57.838742147Z","created_by":"ubuntu","updated_at":"2026-01-19T18:10:57.877812438Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-4","safety"]}
{"id":"bd-35j","title":"Implement robot mode JSON output for batch","description":"## Robot Mode JSON Output for Batch Operations\n\n### Output Schema\n\n```json\n{\n  \"command\": \"set_keys\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"device\": {\n    \"model\": \"Stream Deck XL\",\n    \"serial\": \"ABC123456\",\n    \"key_count\": 32,\n    \"key_size\": [72, 72]\n  },\n  \"input\": {\n    \"directory\": \"/path/to/dir\",\n    \"pattern\": \"key-{index}.png\",\n    \"continue_on_error\": true\n  },\n  \"results\": [\n    {\n      \"key\": 0,\n      \"file\": \"key-00.png\",\n      \"success\": true,\n      \"source\": {\n        \"path\": \"/path/to/dir/key-00.png\",\n        \"format\": \"PNG\",\n        \"dimensions\": [256, 256],\n        \"size_bytes\": 45678\n      },\n      \"processing\": {\n        \"resize_required\": true,\n        \"target_dimensions\": [72, 72],\n        \"filter\": \"lanczos3\",\n        \"cache_hit\": false,\n        \"duration_ms\": 45\n      }\n    },\n    {\n      \"key\": 1,\n      \"file\": \"key-01.png\", \n      \"success\": false,\n      \"error\": {\n        \"code\": \"IMAGE_CORRUPTED\",\n        \"message\": \"Failed to decode PNG: invalid header\",\n        \"suggestion\": \"Verify the image is a valid PNG file\"\n      }\n    }\n  ],\n  \"summary\": {\n    \"total_keys\": 32,\n    \"files_found\": 30,\n    \"success\": 28,\n    \"failed\": 2,\n    \"skipped\": 2,\n    \"duration_ms\": 1250\n  },\n  \"performance\": {\n    \"scan_duration_ms\": 15,\n    \"load_duration_ms\": 800,\n    \"resize_duration_ms\": 300,\n    \"transfer_duration_ms\": 135,\n    \"cache_hits\": 5,\n    \"cache_misses\": 25\n  }\n}\n```\n\n### Streaming Output (for progress)\n\nWhen `--robot --stream` is used, emit progress events:\n\n```json\n{\"event\": \"scan_complete\", \"files_found\": 30}\n{\"event\": \"key_start\", \"key\": 0, \"file\": \"key-00.png\"}\n{\"event\": \"key_complete\", \"key\": 0, \"success\": true, \"duration_ms\": 45}\n{\"event\": \"key_start\", \"key\": 1, \"file\": \"key-01.png\"}\n{\"event\": \"key_failed\", \"key\": 1, \"error\": \"IMAGE_CORRUPTED\"}\n...\n{\"event\": \"complete\", \"summary\": {...}}\n```\n\n### Error Codes\n\nStandard error codes for machine parsing:\n- `FILE_NOT_FOUND` - Image file doesn't exist\n- `PERMISSION_DENIED` - Cannot read image file\n- `IMAGE_CORRUPTED` - Image cannot be decoded\n- `IMAGE_FORMAT_UNSUPPORTED` - Format not PNG/JPG/WebP\n- `KEY_OUT_OF_RANGE` - Key index exceeds device capacity\n- `DEVICE_ERROR` - USB communication failure\n\n### Implementation Notes\n\n1. Always include `device` block for context\n2. Always include timing for performance analysis\n3. Include cache statistics for debugging\n4. Error objects always have code, message, and suggestion\n5. Summary must match sum of individual results\n6. All paths should be absolute for unambiguous references","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.744961886Z","created_by":"ubuntu","updated_at":"2026-01-19T20:40:20.369628600Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-35j","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.761750275Z","created_by":"ubuntu"}]}
{"id":"bd-35os","title":"Implement button_event styled output for watch command","description":"# Implement button_event styled output for watch command\n\n## Purpose\nCreate a visually clear, easy-to-scan event stream for the button watch command. Events should be instantly distinguishable (pressed vs released) with timestamps for correlation.\n\n## Target Output (stream)\n```\n───────────────────── Button Events ─────────────────────\n\n  ● Key 5 pressed                           00:00:01.234\n  ○ Key 5 released                          00:00:01.456\n  ● Key 12 pressed                          00:00:02.100\n  ● Key 13 pressed                          00:00:02.150\n  ○ Key 12 released                         00:00:02.300\n  ○ Key 13 released                         00:00:02.500\n\nPress Ctrl+C to stop watching...\n```\n\n## Implementation\n\n### Watch Header Method\n```rust\nimpl HumanOutput {\n    /// Print header for watch command\n    pub fn watch_header(&self) {\n        self.rule(Some(\"Button Events\"));\n        self.newline();\n    }\n    \n    /// Print footer hint for watch command\n    pub fn watch_footer(&self) {\n        self.newline();\n        self.console.print_styled(\n            \"Press Ctrl+C to stop watching...\",\n            self.theme.muted.clone()\n        );\n    }\n}\n```\n\n### button_event Method\n```rust\nfn button_event(&self, event: &ButtonEvent) {\n    let (icon, style) = if event.pressed {\n        (\"●\", self.theme.button_pressed.clone())  // Filled circle, green\n    } else {\n        (\"○\", self.theme.button_released.clone()) // Empty circle, dim\n    };\n    \n    let action = if event.pressed { \"pressed\" } else { \"released\" };\n    let timestamp = format_timestamp_ms(event.timestamp_ms);\n    \n    // Build styled line\n    let mut text = Text::new(\"\");\n    text.append_styled(&format!(\"  {} \", icon), style.clone());\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{:<2}\", event.key), self.theme.key_index.clone());\n    text.append_styled(&format!(\" {:<8}\", action), style);\n    \n    // Right-align timestamp to fixed position\n    let padding = self.width().saturating_sub(40);\n    text.append_styled(&format!(\"{:>width$}\", timestamp, width = padding), \n        self.theme.muted.clone());\n    \n    self.console.print_text(&text);\n}\n\n/// Format milliseconds as HH:MM:SS.mmm\nfn format_timestamp_ms(ms: u64) -> String {\n    let total_secs = ms / 1000;\n    let millis = ms % 1000;\n    let secs = total_secs % 60;\n    let mins = (total_secs / 60) % 60;\n    let hours = total_secs / 3600;\n    \n    format!(\"{:02}:{:02}:{:02}.{:03}\", hours, mins, secs, millis)\n}\n```\n\n## Design Decisions\n\n### Icons (● vs ○)\n- Filled circle (●) for pressed: Solid, active state\n- Empty circle (○) for released: Open, inactive state\n- Universal symbols that convey state visually\n- Color provides additional differentiation\n\n### Color Coding\n- Pressed: Green (success color) - active, happening now\n- Released: Dim/gray - past event, less important\n- Key index: Amber/warning - stands out for quick identification\n\n### Timestamp Format\n- HH:MM:SS.mmm format is standard and precise\n- Relative to session start (not wall clock) for simpler math\n- Millisecond precision for timing analysis\n- Right-aligned for visual column alignment\n\n### Line Layout\n```\n  ● Key 5  pressed                          00:00:01.234\n  │  │  │  │                                │\n  │  │  │  └─ action (left-padded)          └─ timestamp (right-aligned)\n  │  │  └─ key number (amber, 2-char width)\n  │  └─ label (dim)\n  └─ icon (green/dim)\n```\n\n### Streaming Considerations\n- Each event is a single line (no buffering issues)\n- stdout flush happens naturally after println\n- Events appear in real-time\n- No panel wrapping (would break streaming)\n\n## Watch Command Integration\nThe watch command needs to:\n1. Print header once at start\n2. Print each event as it arrives\n3. Print footer on Ctrl+C (if possible)\n\n```rust\n// In cmd_watch\nif !cli.use_json() {\n    output.watch_header();\n}\n\n// Event loop\nloop {\n    if let Some(event) = read_button_event(&device)? {\n        output.button_event(&event);\n        if args.once {\n            break;\n        }\n    }\n}\n\n// Footer (may not be reached on Ctrl+C)\nif !cli.use_json() {\n    output.watch_footer();\n}\n```\n\n## Testing\n```rust\n#[test]\nfn button_event_pressed_has_filled_icon() {\n    let output = HumanOutput::new(test_console());\n    let event = ButtonEvent { key: 5, pressed: true, timestamp_ms: 1234 };\n    \n    let captured = capture_output(|| output.button_event(&event));\n    \n    assert!(captured.contains(\"●\"));\n    assert!(captured.contains(\"pressed\"));\n}\n\n#[test]\nfn button_event_released_has_empty_icon() {\n    let output = HumanOutput::new(test_console());\n    let event = ButtonEvent { key: 5, pressed: false, timestamp_ms: 1456 };\n    \n    let captured = capture_output(|| output.button_event(&event));\n    \n    assert!(captured.contains(\"○\"));\n    assert!(captured.contains(\"released\"));\n}\n\n#[test]\nfn timestamp_format() {\n    assert_eq!(format_timestamp_ms(0), \"00:00:00.000\");\n    assert_eq!(format_timestamp_ms(1234), \"00:00:01.234\");\n    assert_eq!(format_timestamp_ms(61000), \"00:01:01.000\");\n    assert_eq!(format_timestamp_ms(3661234), \"01:01:01.234\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Pressed events show filled circle (●) in green\n- [ ] Released events show empty circle (○) in dim\n- [ ] Key index is highlighted in amber\n- [ ] Timestamp is right-aligned\n- [ ] Events stream in real-time (no buffering)\n- [ ] Header rule appears at start of watch\n- [ ] Footer hint shows how to stop","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:18.580938247Z","created_by":"ubuntu","updated_at":"2026-01-19T21:07:18.637460086Z","compaction_level":0,"original_size":0,"labels":["button","events","phase-2","rich-rust","watch"],"dependencies":[{"issue_id":"bd-35os","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:07:18.637423607Z","created_by":"ubuntu"},{"issue_id":"bd-35os","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:07:18.632431468Z","created_by":"ubuntu"}]}
{"id":"bd-36gs","title":"Phase 4: Testing and Verification","description":"# Phase 4: Testing and Verification\n\n## Purpose\nComprehensive testing to ensure the rich_rust integration works correctly and doesn't break existing functionality. This phase is CRITICAL because the primary users are AI agents who depend on consistent JSON output.\n\n## Background\nTesting has three main concerns:\n1. Robot mode regression: JSON output must be IDENTICAL to before\n2. Human mode validation: Styled output should render correctly\n3. Environment compliance: NO_COLOR, TTY detection, etc.\n\n## Test Categories\n\n### 1. Robot Mode Regression Tests\n- Verify JSON structure unchanged for all commands\n- Byte-for-byte comparison where possible\n- Schema validation for JSON responses\n\n### 2. Human Mode Visual Tests\n- Capture output and verify key elements present\n- Test theme colors are applied\n- Verify panels, tables, rules render\n\n### 3. Environment Tests\n- NO_COLOR disables all styling\n- Non-TTY output has no ANSI codes\n- FORCE_COLOR overrides detection\n\n### 4. Cross-Platform Tests\n- Works on Linux, macOS, Windows\n- ASCII fallback when Unicode not supported\n- Terminal width detection\n\n## Deliverables\n1. Unit tests for RobotOutput\n2. Unit tests for HumanOutput\n3. Integration tests for full command flow\n4. Environment variable tests\n5. Test utilities for output capture\n\n## Success Criteria\n- [ ] 100% of robot mode JSON structures verified unchanged\n- [ ] Human mode tests cover all output methods\n- [ ] NO_COLOR compliance verified\n- [ ] All tests pass in CI\n- [ ] Test coverage documented","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:09:54.852579134Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:54.894735677Z","compaction_level":0,"original_size":0,"labels":["phase-4","rich-rust","testing"],"dependencies":[{"issue_id":"bd-36gs","depends_on_id":"bd-1rhq","type":"blocks","created_at":"2026-01-19T21:09:54.894693507Z","created_by":"ubuntu"},{"issue_id":"bd-36gs","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:09:54.888469719Z","created_by":"ubuntu"}]}
{"id":"bd-37o","title":"Add snapshots list command","description":"Implement sd snapshots (list all):\n- Name, creation date, device model, key count\n- Robot mode: JSON array of snapshot objects\n- Human mode: formatted table","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.435833342Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.445532464Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37o","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.445494482Z","created_by":"ubuntu"}]}
{"id":"bd-37v","title":"Add error classification (is_connection_error)","description":"Add to src/error.rs:\n```rust\nimpl SdError {\n    pub fn is_connection_error(&self) -> bool {\n        matches\\!(self, \n            SdError::DeviceNotFound |\n            SdError::UsbError(_) |\n            SdError::DeviceDisconnected\n        )\n    }\n}\n```\n\nEnsure all USB-related errors are properly classified.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.493253348Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:24.509384690Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37v","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.509339205Z","created_by":"ubuntu"}]}
{"id":"bd-38o","title":"Test generated completions for zsh","description":"Manual testing (macOS/Linux with zsh):\n1. Generate: sd completions zsh > /tmp/_sd\n2. Add to fpath and compinit\n3. Test completion behavior\n4. Verify no errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.874093064Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:11.019910508Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38o","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:11.019858330Z","created_by":"ubuntu"},{"issue_id":"bd-38o","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.884045513Z","created_by":"ubuntu"}]}
{"id":"bd-38v","title":"Implement device_list rich output with Panel and styled cards","description":"# Implement device_list rich output with Panel and styled cards\n\n## Purpose\nTransform the device list output from plain text to a beautiful panel containing styled device cards. This is often the first command users run, so it sets the visual tone for the entire CLI.\n\n## Target Output\n```\n┌─────────────────── Stream Deck Devices ───────────────────┐\n│                                                           │\n│  1. Stream Deck XL                                        │\n│     Serial: AL12U1E1234                                   │\n│     Keys: 32 (8×4)  │  Firmware: 1.5.3                    │\n│                                                           │\n│  2. Stream Deck Mini                                      │\n│     Serial: AL12U1E5678                                   │\n│     Keys: 6 (3×2)   │  Firmware: 1.2.1                    │\n│                                                           │\n└───────────────────────────────────────────────────────────┘\n```\n\n## Empty State\n```\n┌─────────────────── Stream Deck Devices ───────────────────┐\n│                                                           │\n│  No devices found                                         │\n│                                                           │\n│  Ensure Stream Deck is connected via USB                  │\n│                                                           │\n└───────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### HumanOutput::device_list Method\n```rust\nfn device_list(&self, devices: &[DeviceInfo]) {\n    if devices.is_empty() {\n        // Empty state panel\n        let mut content = Text::new(\"\");\n        content.append_styled(\"  No devices found\\n\\n\", Style::new().italic());\n        content.append_styled(\"  Ensure Stream Deck is connected via USB\\n\", \n            self.theme.muted.clone());\n        \n        let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n            .title(\"Stream Deck Devices\")\n            .border_style(Style::new().color(self.theme.warning.clone()))\n            .rounded();\n        \n        self.console.print_renderable(&panel);\n        return;\n    }\n    \n    // Build content with device cards\n    let mut content = Text::new(\"\");\n    \n    for (i, device) in devices.iter().enumerate() {\n        // Device number and name (header style)\n        content.append_styled(\n            &format!(\"  {}. {}\\n\", i + 1, device.product_name),\n            self.theme.header.clone()\n        );\n        \n        // Serial (indented, muted)\n        content.append_styled(\"     Serial: \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", device.serial), \n            self.theme.device_serial.clone());\n        \n        // Keys and firmware on same line\n        content.append_styled(\"     Keys: \", self.theme.label.clone());\n        content.append_styled(\n            &format!(\"{} ({}×{})\", device.key_count, device.cols, device.rows),\n            self.theme.value.clone()\n        );\n        content.append_styled(\"  │  \", self.theme.muted.clone());\n        content.append_styled(\"Firmware: \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\", device.firmware_version), \n            self.theme.value.clone());\n        \n        // Add spacing between devices (except last)\n        if i < devices.len() - 1 {\n            content.append(\"\\n\\n\");\n        } else {\n            content.append(\"\\n\");\n        }\n    }\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"Stream Deck Devices\")\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Why Panel Instead of Table?\n- Devices have varying amounts of information\n- Card-style layout is more scannable for 1-3 items\n- Table would have many empty cells or awkward layout\n- Panel creates visual grouping that feels cohesive\n\n### Information Display\n- Number prefix (1., 2.) helps when multiple devices\n- Product name is most prominent (it's what users recognize)\n- Serial is secondary (needed for --serial flag)\n- Keys and firmware are tertiary but useful\n\n### Empty State\n- Proactive helpful message instead of just \"No devices\"\n- Suggests the most common fix (USB connection)\n- Uses warning color to draw attention without alarm\n\n### Spacing\n- Blank line between devices for visual separation\n- Consistent indentation (5 spaces for detail lines)\n- Trailing newline inside panel for padding\n\n## Edge Cases\n- Single device: Panel still looks good\n- Many devices (5+): Panel grows but stays readable\n- Long serial numbers: Will wrap within panel width\n- Terminal too narrow: Content will wrap gracefully\n\n## Testing\n```rust\n#[test]\nfn device_list_multiple_devices() {\n    let console = test_console();\n    let output = HumanOutput::new(console);\n    \n    let devices = vec![\n        DeviceInfo { product_name: \"Stream Deck XL\".into(), ... },\n        DeviceInfo { product_name: \"Stream Deck Mini\".into(), ... },\n    ];\n    \n    // Visual verification - capture and check key elements\n    output.device_list(&devices);\n    // Verify panel title, device names, serials appear\n}\n```\n\n## Acceptance Criteria\n- [ ] Device list renders in styled panel\n- [ ] Empty state shows helpful message\n- [ ] Multiple devices display as distinct cards\n- [ ] Colors match theme specification\n- [ ] Output adapts to terminal width\n- [ ] Border uses rounded style","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:05:28.940504592Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:28.990692797Z","compaction_level":0,"original_size":0,"labels":["device","list","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-38v","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:05:28.990654354Z","created_by":"ubuntu"},{"issue_id":"bd-38v","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:05:28.985990724Z","created_by":"ubuntu"}]}
{"id":"bd-38x","title":"Add restore command with state application","description":"Implement sd restore <name>:\n1. Load snapshot metadata\n2. Check device compatibility (key count)\n3. Apply brightness if stored\n4. Apply each key image/color/clear\n5. Report progress and any failures\n\nHandle: missing snapshot, incompatible device, missing images","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.312916003Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.322709141Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38x","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.322663555Z","created_by":"ubuntu"}]}
{"id":"bd-3a2","title":"Implement keymap file loading","description":"Support --keymap <file.yaml>:\n```yaml\nkeys:\n  0:\n    press: open -a Chrome\n    release: null\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\nReuse KeySelector from declarative config.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.205128062Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.223338890Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3a2","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.223284417Z","created_by":"ubuntu"}]}
{"id":"bd-3ab","title":"Add debouncing logic","description":"Prevent rapid re-applies:\n- Track last apply timestamp\n- Ignore events within debounce window (default 500ms)\n- Configurable via --debounce flag\n\nSome editors save multiple times (backup, then real).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.290122116Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.300511167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ab","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.300472524Z","created_by":"ubuntu"}]}
{"id":"bd-3aj","title":"Implement basic bash export","description":"## Purpose\nGenerate a valid, executable bash script that reproduces the current device state.\n\n## Implementation\n```rust\n// src/export/bash.rs\nuse std::path::Path;\nuse tracing::{debug, trace, info, instrument};\nuse crate::state::{SessionState, KeyState};\n\n/// Options for bash script generation\npub struct BashExportOptions {\n    /// Include shebang and set -e\n    pub include_header: bool,\n    /// Use absolute paths for images\n    pub absolute_paths: bool,\n    /// Include comments explaining each line\n    pub verbose_comments: bool,\n    /// Target device serial (for multi-device setups)\n    pub device_serial: Option<String>,\n}\n\nimpl Default for BashExportOptions {\n    fn default() -> Self {\n        Self {\n            include_header: true,\n            absolute_paths: true,\n            verbose_comments: false,\n            device_serial: None,\n        }\n    }\n}\n\n/// Generate a bash script from session state\n#[instrument(skip(state))]\npub fn generate_bash_script(state: &SessionState, opts: &BashExportOptions) -> String {\n    let mut lines = Vec::new();\n    \n    if opts.include_header {\n        lines.push(\"#!/bin/bash\".to_string());\n        lines.push(\"# Stream Deck configuration exported by sd\".to_string());\n        lines.push(format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()));\n        if let Some(ref serial) = opts.device_serial {\n            lines.push(format!(\"# Device serial: {}\", serial));\n        }\n        lines.push(\"\".to_string());\n        lines.push(\"set -e  # Exit on first error\".to_string());\n        lines.push(\"\".to_string());\n    }\n    \n    // Device selection (if specified)\n    let device_flag = opts.device_serial.as_ref()\n        .map(|s| format!(\" --serial \\\"{}\\\"\", s))\n        .unwrap_or_default();\n    \n    // Brightness command\n    if let Some(brightness) = state.brightness {\n        if opts.verbose_comments {\n            lines.push(format!(\"# Set display brightness to {}%\", brightness));\n        }\n        lines.push(format!(\"sd{} brightness {}\", device_flag, brightness));\n        trace!(brightness = %brightness, \"Added brightness command\");\n    }\n    \n    // Collect keys by type for organized output\n    let mut image_keys: Vec<(u8, &Path)> = Vec::new();\n    let mut color_keys: Vec<(u8, &str)> = Vec::new();\n    let mut cleared_keys: Vec<u8> = Vec::new();\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => image_keys.push((*key, path)),\n            KeyState::Color(color) => color_keys.push((*key, color)),\n            KeyState::Cleared => cleared_keys.push(*key),\n        }\n    }\n    \n    // Sort for consistent output\n    image_keys.sort_by_key(|(k, _)| *k);\n    color_keys.sort_by_key(|(k, _)| *k);\n    cleared_keys.sort();\n    \n    // Image keys\n    if !image_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Set key images\".to_string());\n        }\n        \n        for (key, path) in image_keys {\n            let path_str = if opts.absolute_paths {\n                path.canonicalize()\n                    .map(|p| p.display().to_string())\n                    .unwrap_or_else(|_| path.display().to_string())\n            } else {\n                path.display().to_string()\n            };\n            \n            // Properly escape the path for bash\n            let escaped_path = escape_bash_string(&path_str);\n            lines.push(format!(\"sd{} set-key {} {}\", device_flag, key, escaped_path));\n            trace!(key = %key, path = %path_str, \"Added set-key command\");\n        }\n    }\n    \n    // Color keys\n    if !color_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Fill keys with solid colors\".to_string());\n        }\n        \n        for (key, color) in color_keys {\n            lines.push(format!(\"sd{} fill-key {} \\\"{}\\\"\", device_flag, key, color));\n            trace!(key = %key, color = %color, \"Added fill-key command\");\n        }\n    }\n    \n    // Cleared keys\n    if !cleared_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Clear unused keys\".to_string());\n        }\n        \n        for key in cleared_keys {\n            lines.push(format!(\"sd{} clear-key {}\", device_flag, key));\n            trace!(key = %key, \"Added clear-key command\");\n        }\n    }\n    \n    // Footer\n    lines.push(\"\".to_string());\n    lines.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    info!(\n        brightness = ?state.brightness,\n        key_count = %state.keys.len(),\n        \"Generated bash script\"\n    );\n    \n    lines.join(\"\\n\")\n}\n\n/// Escape a string for safe use in bash\nfn escape_bash_string(s: &str) -> String {\n    // If no special characters, no quoting needed\n    if s.chars().all(|c| c.is_alphanumeric() || c == '/' || c == '.' || c == '-' || c == '_') {\n        return s.to_string();\n    }\n    \n    // Use double quotes and escape special chars\n    let escaped = s\n        .replace('\\\\', \"\\\\\\\\\")\n        .replace('\"', \"\\\\\\\"\")\n        .replace('$', \"\\\\$\")\n        .replace('`', \"\\\\`\")\n        .replace('!', \"\\\\!\");\n    \n    format!(\"\\\"{}\\\"\", escaped)\n}\n\n/// Robot mode output structure\n#[derive(serde::Serialize)]\npub struct ExportResult {\n    pub format: String,\n    pub script: String,\n    pub commands_count: usize,\n    pub brightness_set: bool,\n    pub keys_with_images: usize,\n    pub keys_with_colors: usize,\n    pub keys_cleared: usize,\n}\n\nimpl ExportResult {\n    pub fn from_state(state: &SessionState, script: String) -> Self {\n        let (images, colors, cleared) = state.keys.values().fold(\n            (0, 0, 0),\n            |(i, c, cl), ks| match ks {\n                KeyState::Image(_) => (i + 1, c, cl),\n                KeyState::Color(_) => (i, c + 1, cl),\n                KeyState::Cleared => (i, c, cl + 1),\n            },\n        );\n        \n        Self {\n            format: \"bash\".to_string(),\n            script,\n            commands_count: state.keys.len() + state.brightness.map(|_| 1).unwrap_or(0),\n            brightness_set: state.brightness.is_some(),\n            keys_with_images: images,\n            keys_with_colors: colors,\n            keys_cleared: cleared,\n        }\n    }\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    \n    fn sample_state() -> SessionState {\n        let mut keys = HashMap::new();\n        keys.insert(0, KeyState::Image(PathBuf::from(\"/home/user/icons/chrome.png\")));\n        keys.insert(1, KeyState::Color(\"#FF5500\".to_string()));\n        keys.insert(31, KeyState::Cleared);\n        \n        SessionState {\n            brightness: Some(80),\n            keys,\n        }\n    }\n    \n    #[test]\n    fn test_basic_export() {\n        let state = sample_state();\n        let script = generate_bash_script(&state, &BashExportOptions::default());\n        \n        assert!(script.contains(\"#!/bin/bash\"));\n        assert!(script.contains(\"set -e\"));\n        assert!(script.contains(\"sd brightness 80\"));\n        assert!(script.contains(\"sd set-key 0\"));\n        assert!(script.contains(\"sd fill-key 1 \\\"#FF5500\\\"\"));\n        assert!(script.contains(\"sd clear-key 31\"));\n    }\n    \n    #[test]\n    fn test_path_escaping() {\n        assert_eq!(escape_bash_string(\"/simple/path.png\"), \"/simple/path.png\");\n        assert_eq!(escape_bash_string(\"/path with spaces/file.png\"), \"\\\"/path with spaces/file.png\\\"\");\n        assert_eq!(escape_bash_string(\"/path\\\"with\\\"quotes.png\"), \"\\\"/path\\\\\\\"with\\\\\\\"quotes.png\\\"\");\n    }\n    \n    #[test]\n    fn test_empty_state() {\n        let state = SessionState::default();\n        let script = generate_bash_script(&state, &BashExportOptions::default());\n        \n        assert!(script.contains(\"#!/bin/bash\"));\n        assert!(script.contains(\"Configuration applied successfully\"));\n        // Should not contain any sd commands except echo\n        assert!(!script.contains(\"sd brightness\"));\n        assert!(!script.contains(\"sd set-key\"));\n    }\n    \n    #[test]\n    fn test_device_serial_flag() {\n        let mut state = SessionState::default();\n        state.brightness = Some(50);\n        \n        let opts = BashExportOptions {\n            device_serial: Some(\"ABC123\".to_string()),\n            ..Default::default()\n        };\n        \n        let script = generate_bash_script(&state, &opts);\n        assert!(script.contains(\"sd --serial \\\"ABC123\\\" brightness 50\"));\n    }\n}\n```\n\n## Success Criteria\n- [ ] Generated script has valid bash syntax\n- [ ] Shebang and set -e included by default\n- [ ] Absolute paths used by default\n- [ ] Paths properly quoted/escaped for bash\n- [ ] Keys grouped by type (images, colors, cleared)\n- [ ] Device serial flag included when specified\n- [ ] Robot mode returns structured JSON with script\n\n## Logging Requirements\n- TRACE: Each command added to script\n- DEBUG: (none - generation is straightforward)\n- INFO: Script generated with summary stats\n- WARN: (none)\n- ERROR: (none - errors bubble up)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.820883805Z","created_by":"ubuntu","updated_at":"2026-01-19T20:51:11.076670486Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3aj","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.830765861Z","created_by":"ubuntu"}]}
{"id":"bd-3av","title":"Embed static files in binary","description":"Use rust-embed crate:\n```rust\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n```\n\nSingle binary deployment with embedded frontend.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:50.191473983Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:50.204423324Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3av","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:50.204358191Z","created_by":"ubuntu"}]}
{"id":"bd-3c2","title":"Add CLI flags for gesture thresholds","description":"Add to watch command:\n- --gestures: Enable gesture detection\n- --long-press-ms <MS>: Threshold (default 800)\n- --double-tap-ms <MS>: Window (default 300)\n- --hold-tick-ms <MS>: Interval (default 100)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.896069405Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.905873064Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c2","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.905825153Z","created_by":"ubuntu"}]}
{"id":"bd-3c8","title":"Implement device info endpoint","description":"GET /api/device:\n```json\n{\n  \"model\": \"Stream Deck XL\",\n  \"serial\": \"ABC123\",\n  \"key_count\": 32,\n  \"key_width\": 72,\n  \"key_height\": 72,\n  \"firmware\": \"1.0.0\"\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.004989866Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.016076239Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c8","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.016018160Z","created_by":"ubuntu"}]}
{"id":"bd-3d5","title":"Add human-friendly progress output for batch","description":"## Human-Friendly Progress Output for Batch Operations\n\n### Visual Design\n\n**Scanning Phase:**\n```\nScanning /home/user/layout/ for images...\nFound 30 matching files (pattern: key-{index}.png)\n```\n\n**Progress Phase (with TTY):**\n```\nSetting keys [██████████████░░░░░░░░░░░░░░░░░░] 14/32\n  Key 13: key-13.png (128x128 → 72x72)\n```\n\n**Progress Phase (without TTY):**\n```\nSetting key 0/32: key-00.png\nSetting key 1/32: key-01.png\n...\n```\n\n**Completion (Success):**\n```\n✓ Set 30 keys in 1.2s\n\nSummary:\n  Applied: 30 keys\n  Skipped: 2 keys (files not found)\n  Duration: 1.25s\n```\n\n**Completion (With Errors):**\n```\n⚠ Set 28 keys with 2 errors in 1.4s\n\nSummary:\n  Applied: 28 keys\n  Failed: 2 keys\n  Skipped: 2 keys (files not found)\n\nErrors:\n  Key 5 (key-05.png): Image corrupted - invalid PNG header\n  Key 12 (key-12.png): Permission denied\n```\n\n### Color Scheme (when TTY and color enabled)\n\n- Progress bar: cyan\n- Success checkmark (✓): green\n- Warning (⚠): yellow\n- Error (✗): red\n- Key numbers: bold\n- File names: blue\n- Dimensions: dim\n\n### Implementation Requirements\n\n1. **TTY Detection**: Use `atty` or `is_terminal` crate\n2. **Color Support**: Use `colored` crate with TTY detection\n3. **Progress Bar**: Use `indicatif` crate or simple counter\n4. **Unicode Fallback**: Use ASCII if unicode not supported\n   - ✓ → [OK]\n   - ⚠ → [WARN]\n   - ✗ → [FAIL]\n   - █ → #\n\n### Quiet Mode\n\nWith `--quiet` or `-q`:\n- No progress output\n- Only final summary\n- Errors still printed to stderr\n\n### Verbose Mode\n\nWith `--verbose` or `-v`:\n- Show each file being loaded\n- Show resize operations\n- Show timing per key\n- Show cache hit/miss\n\n### Accessibility\n\n- Don't rely solely on color (use symbols too)\n- Provide machine-readable alternative (--robot)\n- Support NO_COLOR environment variable","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.949008857Z","created_by":"ubuntu","updated_at":"2026-01-19T20:40:43.917210724Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3d5","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.965774463Z","created_by":"ubuntu"}]}
{"id":"bd-3dy","title":"Implement directory scanning with pattern matching","description":"## Purpose\nScan a directory for images matching a pattern and map them to Stream Deck key indices.\n\n## Implementation\n\n```rust\n// src/batch/scanner.rs\nuse std::path::{Path, PathBuf};\nuse tracing::{debug, trace, info, warn, instrument};\n\n#[derive(Debug, Clone)]\npub struct ScanResult {\n    pub mappings: Vec<KeyMapping>,\n    pub unmatched: Vec<PathBuf>,\n    pub invalid: Vec<(PathBuf, String)>,\n}\n\n#[derive(Debug, Clone)]\npub struct KeyMapping {\n    pub key: u8,\n    pub path: PathBuf,\n    pub size_bytes: u64,\n}\n\n/// Scan a directory for files matching the pattern\n#[instrument(fields(dir = %dir.display(), pattern = %pattern))]\npub fn scan_directory(\n    dir: &Path,\n    pattern: &str,\n    key_count: u8,\n) -> Result<ScanResult, ScanError> {\n    info!(\"Starting directory scan\");\n    \n    if !dir.exists() {\n        return Err(ScanError::DirectoryNotFound(dir.to_path_buf()));\n    }\n    \n    if !dir.is_dir() {\n        return Err(ScanError::NotADirectory(dir.to_path_buf()));\n    }\n    \n    let mut mappings = Vec::new();\n    let mut unmatched = Vec::new();\n    let mut invalid = Vec::new();\n    \n    let entries = std::fs::read_dir(dir)\n        .map_err(|e| ScanError::ReadError(dir.to_path_buf(), e))?;\n    \n    for entry in entries {\n        let entry = entry.map_err(|e| ScanError::EntryError(e))?;\n        let path = entry.path();\n        \n        // Skip directories\n        if path.is_dir() {\n            trace!(path = %path.display(), \"Skipping directory\");\n            continue;\n        }\n        \n        // Try to extract key index from filename\n        match extract_key_index(&path, pattern) {\n            Some(key) if key < key_count => {\n                let metadata = std::fs::metadata(&path)?;\n                debug!(\n                    key = %key,\n                    path = %path.display(),\n                    size = %metadata.len(),\n                    \"Matched key file\"\n                );\n                mappings.push(KeyMapping {\n                    key,\n                    path,\n                    size_bytes: metadata.len(),\n                });\n            }\n            Some(key) => {\n                warn!(\n                    key = %key,\n                    max = %key_count,\n                    path = %path.display(),\n                    \"Key index out of range\"\n                );\n                invalid.push((path, format!(\"key {} out of range (max {})\", key, key_count - 1)));\n            }\n            None => {\n                trace!(path = %path.display(), \"File doesn't match pattern\");\n                unmatched.push(path);\n            }\n        }\n    }\n    \n    // Sort mappings by key index for consistent ordering\n    mappings.sort_by_key(|m| m.key);\n    \n    info!(\n        matched = %mappings.len(),\n        unmatched = %unmatched.len(),\n        invalid = %invalid.len(),\n        \"Directory scan complete\"\n    );\n    \n    Ok(ScanResult { mappings, unmatched, invalid })\n}\n\n/// Extract key index from filename based on pattern\nfn extract_key_index(path: &Path, pattern: &str) -> Option<u8> {\n    let filename = path.file_name()?.to_str()?;\n    \n    // Pattern like \"key-{index}.png\" or \"key-{index:02d}.png\"\n    // Find where {index} would be and extract the number there\n    let parts: Vec<&str> = pattern.split(\"{index\").collect();\n    if parts.len() != 2 {\n        return None;\n    }\n    \n    let prefix = parts[0];\n    let suffix = parts[1].split('}').nth(1)?;\n    \n    if !filename.starts_with(prefix) || !filename.ends_with(suffix) {\n        return None;\n    }\n    \n    let start = prefix.len();\n    let end = filename.len() - suffix.len();\n    let num_str = &filename[start..end];\n    \n    num_str.parse().ok()\n}\n```\n\n## Edge Cases\n- Empty directory → empty mappings, no error\n- No matching files → empty mappings with all in unmatched\n- Duplicate key indices → last one wins (warn logged)\n- Symlinks → followed (like regular files)\n- Permission denied on file → added to invalid with reason\n\n## Logging Requirements\n- TRACE: Each file examined (match/no-match decision)\n- DEBUG: Each matched file with key index and size\n- INFO: Scan start/complete with summary counts\n- WARN: Key index out of range, duplicates\n- ERROR: Directory access failures\n\n## Success Criteria\n- [ ] Scans flat directory correctly\n- [ ] Pattern matching works for common patterns\n- [ ] Out-of-range keys handled gracefully\n- [ ] Missing directory returns clear error\n- [ ] Empty directory returns empty result (not error)","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.150275826Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:23.367523772Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3dy","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.166727231Z","created_by":"ubuntu"}]}
{"id":"bd-3fo","title":"Implement path resolution (absolute, relative, ~)","description":"Path resolution logic:\n1. Absolute paths: use as-is\n2. Relative paths: resolve from config file directory\n3. ~ paths: expand to home directory\n4. Pattern paths: expand {index} placeholder\n\nConsider cross-platform home directory handling.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.799582382Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:56.815040156Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3fo","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.814993518Z","created_by":"ubuntu"}]}
{"id":"bd-3g6","title":"Implement config list command","description":"Implement sd config list:\n- List all imported/saved profiles\n- Show: name, creation date, device type, key count\n- Robot mode: JSON array\n- Human mode: Table format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.869558183Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.879394173Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3g6","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.879347044Z","created_by":"ubuntu"}]}
{"id":"bd-3gj","title":"Design gesture state machine","description":"Document state machine design:\n- States: Idle, Pressed, PotentialDoubleTap\n- Transitions based on press/release and timing\n- Gesture outputs: Tap, DoubleTap, LongPress, HoldStart/Tick/End\n\nCritical timing decisions:\n- Long press threshold (default 800ms)\n- Double tap window (default 300ms)\n- Hold tick interval (default 100ms)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:59.836520761Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:59.867034192Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3gj","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:27:59.866981643Z","created_by":"ubuntu"}]}
{"id":"bd-3il","title":"Implement hold start/tick/end","description":"Hold events for continuous actions:\n1. HoldStart when duration exceeds threshold while pressed\n2. HoldTick every interval while held\n3. HoldEnd on release (includes total duration)\n\nUsed for push-to-talk, volume adjustment, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.465425065Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.476661571Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3il","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.476608130Z","created_by":"ubuntu"}]}
{"id":"bd-3ix","title":"Implement validate command","description":"Implement sd validate <config.yaml>:\n- Check YAML/TOML syntax\n- Verify all image paths exist\n- Validate color formats\n- Check key indices against device range\n- Report all issues found\n\nExit code: 0 if valid, 1 if errors.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:58.360885986Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:58.375703194Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ix","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.375651196Z","created_by":"ubuntu"}]}
{"id":"bd-3j4","title":"Implement exponential backoff with cap","description":"Implement proper exponential backoff:\n- Start with configured delay (default 1s)\n- Multiply by backoff_factor each attempt (default 2.0)\n- Cap at maximum (30s) to prevent extremely long waits\n- Reset on successful connection","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:26.072744747Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:26.087364012Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j4","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.087313507Z","created_by":"ubuntu"}]}
{"id":"bd-3j5","title":"Add save command with state serialization","description":"Implement sd save <name>:\n1. Read current session state\n2. Read current device brightness (if available)\n3. Serialize to snapshot format\n4. Copy source images to snapshot storage\n5. Write metadata to SQLite\n\nHandle: name conflicts (prompt or overwrite), missing source images","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.196769381Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.205926602Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j5","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.205885675Z","created_by":"ubuntu"}]}
{"id":"bd-3ju","title":"EPIC: Batch Operations with Directory Import","description":"## Overview\n**Rank: #1 of 15** | **Impact: Very High** | **Effort: Low** | **Confidence: Very High**\n\nAdd `sd set-keys <DIR>` command that loads all images from a directory and sets them to keys based on filename pattern (e.g., `key-00.png`, `key-01.png`).\n\n## Problem Statement\nThe single biggest pain point with the current CLI is setting up a full device. For a Stream Deck XL (32 keys), users must call `sd set-key` 32 separate times. This is:\n- Tedious for humans\n- Inefficient for AI agents (32 tool calls instead of 1)\n- Error-prone (easy to miss keys or use wrong indices)\n- Not scriptable in a clean way\n\n## Solution\nA single command that atomically applies a directory of images to the device:\n```bash\nsd set-keys ~/my-deck-layout/\n# Reads key-00.png through key-31.png and applies them\n```\n\n## Why This Is #1 Priority\n1. **Immediate utility**: Solves the most common workflow pain point\n2. **Obvious accretion**: Uses existing image loading, key validation, and device communication\n3. **Robot-mode friendly**: Agents prepare a directory, apply atomically, get per-key error reporting\n4. **Low complexity**: ~50-75 lines of code, no new dependencies\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - add new command variant\nSetKeys { \n    /// Directory containing key-NN.png/jpg files\n    dir: PathBuf,\n    /// Naming pattern (default: key-{index}.png)\n    #[arg(long, default_value = \"key-{index}.png\")]\n    pattern: String,\n    /// Continue on error (report failures but keep going)\n    #[arg(long)]\n    continue_on_error: bool,\n}\n\n// In main.rs - implement command handler\nfn cmd_set_keys(device: &Device, dir: &Path, pattern: &str, continue_on_error: bool) -> Result<()> {\n    let key_count = device.info().key_count;\n    let mut results = Vec::new();\n    \n    for key in 0..key_count {\n        let filename = pattern.replace(\"{index}\", &format!(\"{key:02}\"));\n        let path = dir.join(&filename);\n        \n        if path.exists() {\n            match set_key_image(device, key, &path) {\n                Ok(()) => results.push((key, Ok(()))),\n                Err(e) if continue_on_error => results.push((key, Err(e))),\n                Err(e) => return Err(e),\n            }\n        }\n    }\n    \n    // Robot mode: return JSON array of results\n    // Human mode: print summary\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Pattern-based naming**: Flexible filename patterns support different conventions\n2. **Two-digit zero-padding**: `key-00.png` not `key-0.png` for proper sorting\n3. **Skip missing files**: Only set keys that have corresponding images\n4. **Continue-on-error option**: Batch operations should be resilient by default for agents\n5. **Detailed reporting**: Each key gets success/failure status in robot mode\n\n## Success Criteria\n- [ ] `sd set-keys <dir>` applies all matching images in one command\n- [ ] Pattern flag allows custom naming conventions\n- [ ] Robot mode returns per-key success/failure JSON\n- [ ] Human mode shows progress and summary\n- [ ] Errors include which key/file failed and why\n- [ ] Works with all Stream Deck variants (different key counts)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add SetKeys command struct\n- `src/main.rs`: Add cmd_set_keys handler and dispatch\n\n## Testing Strategy\n1. Create test directory with sample images\n2. Test with full set (32 images)\n3. Test with partial set (some keys missing)\n4. Test with invalid images (wrong format, corrupted)\n5. Test continue-on-error behavior\n6. Verify robot mode JSON output structure\n\n## Dependencies\nNone - uses existing infrastructure\n\n## Estimated Subtasks\n1. Add CLI command definition\n2. Implement directory scanning with pattern matching\n3. Implement batch application loop\n4. Add error handling and continue-on-error\n5. Implement robot mode JSON output\n6. Add human-friendly progress output\n7. Write tests\n8. Update help text and examples","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:28.552254273Z","created_by":"ubuntu","updated_at":"2026-01-19T18:09:28.568166823Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-1","user-experience"]}
{"id":"bd-3jv","title":"Add error handling for invalid configs","description":"When config file becomes invalid:\n- Parse error: show error, keep watching\n- Missing images: warn and skip those keys\n- Invalid colors: warn and skip\n- Never crash - always continue watching","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:35.076134526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.087156148Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3jv","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.087109520Z","created_by":"ubuntu"}]}
{"id":"bd-3k6","title":"Implement brightness_set with ProgressBar visualization","description":"# Implement brightness_set with ProgressBar visualization\n\n## Purpose\nDisplay brightness changes with a visual progress bar that immediately communicates the brightness level. This provides instant feedback that the command worked and shows the current state.\n\n## Target Output\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ████████████████████░░░░░░░░░░░░░░░░  50%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Low Brightness (0%)\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   0%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Max Brightness (100%)\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ████████████████████████████████████ 100%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Using rich_rust ProgressBar\n```rust\nfn brightness_set(&self, level: u8) {\n    // Calculate bar width (leave room for label and percentage)\n    // \"  Brightness: \" = 14 chars, \" XXX%\" = 5 chars, padding = 4\n    let bar_width = self.width().saturating_sub(27).min(40);\n    \n    // Create progress bar\n    let bar = ProgressBar::new()\n        .completed(level as usize)\n        .total(100)\n        .width(bar_width)\n        .style(BarStyle::Block);  // Uses █ and ░\n    \n    // Render bar to string\n    let bar_str = bar.render_to_string();\n    \n    // Build content with label and percentage\n    let mut content = Text::new(\"\");\n    content.append_styled(\"  Brightness: \", self.theme.label.clone());\n    content.append_styled(&bar_str, self.theme.brightness.clone());\n    content.append_styled(&format!(\" {:>3}%\", level), self.theme.value.clone());\n    content.append(\"  \");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .border_style(Style::new().color(self.theme.success.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n### Alternative: Custom Bar Rendering\nIf rich_rust ProgressBar doesn't fit exactly, custom render:\n```rust\nfn render_brightness_bar(&self, level: u8, width: usize) -> String {\n    let filled = (level as usize * width) / 100;\n    let empty = width - filled;\n    \n    format!(\"{}{}\", \n        \"█\".repeat(filled),\n        \"░\".repeat(empty)\n    )\n}\n```\n\n## Design Decisions\n\n### Progress Bar Style\n- Block style (█░) is universally recognized\n- High contrast between filled and empty\n- Works in most terminals with Unicode support\n\n### Green Success Border\n- Confirms the operation succeeded\n- Consistent with other success indicators\n- Not red (would imply error) or blue (informational)\n\n### Percentage Display\n- Right-aligned with fixed width (\" 50%\", \"100%\")\n- Numeric precision for exact value\n- Combined with visual bar for quick scanning\n\n### No Title\n- \"Brightness\" label is sufficient\n- Title would add visual noise\n- Simple, clean appearance\n\n### Width Calculation\n- Bar adapts to terminal width\n- Maximum 40 characters (readable at a glance)\n- Minimum ensures bar is visible\n\n## Edge Cases\n- 0%: All empty blocks, still visible\n- 100%: All filled blocks\n- Narrow terminal: Bar shrinks but stays functional\n- Very narrow (<30): May need to drop bar, show just number\n\n## Testing\n```rust\n#[test]\nfn brightness_bar_at_50_percent() {\n    let bar = render_brightness_bar(50, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '█').count(), 10);\n    assert_eq!(bar.chars().filter(|&c| c == '░').count(), 10);\n}\n\n#[test]\nfn brightness_bar_at_0_percent() {\n    let bar = render_brightness_bar(0, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '█').count(), 0);\n}\n\n#[test]\nfn brightness_bar_at_100_percent() {\n    let bar = render_brightness_bar(100, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '░').count(), 0);\n}\n```\n\n## Acceptance Criteria\n- [ ] Brightness displays with visual progress bar\n- [ ] Bar uses block characters (█░)\n- [ ] Percentage shows exact value\n- [ ] Panel has success (green) border\n- [ ] Works for all values 0-100\n- [ ] Adapts to terminal width","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:06:48.092074463Z","created_by":"ubuntu","updated_at":"2026-01-19T21:06:48.137479302Z","compaction_level":0,"original_size":0,"labels":["brightness","phase-2","progress","rich-rust"],"dependencies":[{"issue_id":"bd-3k6","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:06:48.137441090Z","created_by":"ubuntu"},{"issue_id":"bd-3k6","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:06:48.131866123Z","created_by":"ubuntu"}]}
{"id":"bd-3lf","title":"Design and implement robot mode JSON structure","description":"Define consistent JSON structure for dry-run output:\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key\",\n  \"would_succeed\": true,\n  \"details\": { ... },\n  \"device\": { ... }\n}\n```\n\nDocument structure for each command type.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.936881067Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.946974752Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lf","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.946932873Z","created_by":"ubuntu"}]}
{"id":"bd-3ln","title":"Complete ProfileLoader extraction logic","description":"Finish the ProfileLoader implementation:\n1. from_zip(): Open and validate profile ZIP\n2. extract_to(): Extract to temp directory\n3. parse(): Parse manifest.json and profile.json\n4. Map Elgato structures to our types\n\nHandle version differences in Elgato format.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.194682502Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.204058626Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ln","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.204012749Z","created_by":"ubuntu"}]}
{"id":"bd-3lp","title":"Write comprehensive tests for declarative config","description":"## Test Coverage for Declarative YAML/TOML Configuration\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **YAML Parsing Tests**\n   - Valid YAML parses without error\n   - Invalid YAML returns clear syntax error with line number\n   - Missing required fields return helpful error\n   - Unknown fields ignored (forward compatibility)\n   - Comments preserved in round-trip (if supported)\n\n2. **TOML Parsing Tests**\n   - Valid TOML parses without error\n   - Invalid TOML returns clear syntax error\n   - Equivalent to YAML (same schema)\n\n3. **KeySelector Parsing Tests**\n   - Single key: \"0\", \"15\", \"31\"\n   - Range: \"8-15\", \"0-7\"\n   - Row: \"row-0\", \"row-3\"\n   - Default: \"default\"\n   - Invalid: \"32\", \"-1\", \"row-5\", \"abc\"\n\n4. **KeyConfig Parsing Tests**\n   - Image with absolute path: `/path/to/image.png`\n   - Image with relative path: `./icons/app.png`\n   - Image with home: `~/stream-deck/icon.png`\n   - Color hex: `\"#FF5500\"`\n   - Color RGB array: `[255, 85, 0]`\n   - Clear flag: `clear: true`\n   - Pattern: `pattern: \"~/icons/row2/{index}.png\"`\n\n5. **Path Resolution Tests**\n   - Absolute paths unchanged\n   - Relative paths resolved from config file location\n   - Home directory expanded correctly\n   - Non-existent paths return error with suggestion\n   - Permission denied returns clear error\n\n6. **Pattern Expansion Tests**\n   - `{index}` replaced with key number\n   - `{index:02d}` formats with leading zeros\n   - Multiple placeholders in one pattern\n   - Escaped braces `{{` and `}}`\n\n7. **Device Filtering Tests**\n   - Config with `device.model: StreamDeckXL` only applies to XL\n   - Config with `device.serial: ABC123` only applies to that device\n   - No filter applies to any device\n   - Mismatched filter returns clear message\n\n### Integration Tests (require MockDevice)\n\n1. **Full Config Application**\n   - Load YAML config with brightness + 32 keys\n   - Apply to MockDevice\n   - Verify all keys set correctly\n   - Verify brightness set correctly\n\n2. **Partial Config Application**\n   - Config with only some keys specified\n   - Unspecified keys unchanged\n   - Default rule applies to remaining\n\n3. **Diff Command**\n   - Shows keys that would change\n   - Shows keys that would stay same\n   - Shows brightness change\n   - Robot mode returns structured diff\n\n4. **Validate Command**\n   - Reports all errors (not just first)\n   - Validates image paths exist\n   - Validates color values\n   - Validates key indices for device\n   - Returns exit 0 for valid config\n\n5. **Config Layering**\n   - Base config + override config\n   - Override wins for same keys\n   - Both merged for different keys\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Workflow**\n   - `sd apply work.yaml` applies configuration\n   - `sd apply work` finds ~/.config/sd/profiles/work.yaml\n   - `sd validate work.yaml` validates without applying\n   - `sd diff work.yaml` shows what would change\n\n2. **Error Handling**\n   - Missing config file → clear error with path\n   - Invalid YAML → syntax error with line number\n   - Missing images → list of missing files\n   - Invalid colors → which color and why\n\n3. **Config Discovery**\n   - Finds configs in ~/.config/sd/profiles/\n   - Finds configs in XDG_CONFIG_HOME/sd/profiles/\n   - Lists available profiles with `sd config list`\n\n### Logging Requirements\n- TRACE: Each key being processed\n- DEBUG: Path resolution, pattern expansion details\n- INFO: Config loaded, apply complete with key count\n- WARN: Unknown config fields, skipped keys\n- ERROR: Parse errors, missing files, invalid values\n\n### Test Data\n- tests/fixtures/config/work.yaml - complete profile\n- tests/fixtures/config/gaming.yaml - another profile\n- tests/fixtures/config/minimal.yaml - just brightness\n- tests/fixtures/config/invalid-syntax.yaml - parse error\n- tests/fixtures/config/missing-images.yaml - path errors\n- tests/fixtures/config/work.toml - TOML equivalent","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:59.218810453Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:46.857942203Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lp","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:35.958349203Z","created_by":"ubuntu"},{"issue_id":"bd-3lp","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:59.229375715Z","created_by":"ubuntu"},{"issue_id":"bd-3lp","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:46.857908801Z","created_by":"ubuntu"}]}
{"id":"bd-3mz","title":"Implement apply command for declarative config","description":"Implement sd apply <config.yaml>:\n1. Load and parse config file\n2. Resolve all selectors to concrete keys\n3. Apply brightness if specified\n4. Apply each key configuration\n5. Report results\n\nHandle: missing files, invalid configs, partial success.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.880977922Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:57.896528941Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3mz","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.896482794Z","created_by":"ubuntu"}]}
{"id":"bd-3p6","title":"EPIC: Image Caching with Content-Addressable Storage","description":"## Overview\n**Rank: #9 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: High**\n\nCache resized images by content hash so repeated operations are instant.\n\n## Problem Statement\nEvery `sd set-key` call:\n1. Opens the image file\n2. Decodes the image format (PNG, JPG, etc.)\n3. Resizes to device key dimensions (e.g., 72x72)\n4. Encodes to device format\n5. Sends to device\n\nSteps 1-4 take ~50-150ms per image depending on source size. For a 32-key device, full setup takes 2-5 seconds. Repeated applications of the same configuration waste this time.\n\n## Solution\nContent-addressable cache that stores pre-processed images:\n```\n~/.cache/sd/\n└── images/\n    ├── a1b2c3d4e5f6...72x72.bin    # Pre-resized, ready to send\n    ├── f6e5d4c3b2a1...72x72.bin\n    └── ...\n```\n\nCache key: `SHA256(file_content + target_dimensions)`\n\n```bash\n# First run: processes all images (~3s)\nsd set-keys ~/layout/\n\n# Second run: uses cache (~0.3s)\nsd set-keys ~/layout/\n\n# Cache statistics\nsd cache stats\n# Output:\n# Cache location: ~/.cache/sd/images/\n# Entries: 47\n# Size: 2.3 MB\n# Hit rate: 94%\n\n# Clear cache\nsd cache clear\n```\n\n## Why This Is #9 Priority\n1. **Performance**: 10x speedup for repeated operations\n2. **Agent efficiency**: Agents often apply same configs repeatedly\n3. **Batch speedup**: Setting 32 keys goes from ~3s to ~0.3s\n4. **Low effort**: Well-understood pattern, ~100 lines\n5. **Invisible improvement**: Users just notice things are faster\n\n## Implementation Approach\n\n### Phase 1: Cache Infrastructure\n```rust\n// In src/cache.rs (new file)\nuse sha2::{Sha256, Digest};\nuse std::path::PathBuf;\n\npub struct ImageCache {\n    cache_dir: PathBuf,\n}\n\nimpl ImageCache {\n    pub fn new() -> Result<Self> {\n        let cache_dir = dirs::cache_dir()\n            .ok_or(SdError::NoCacheDir)?\n            .join(\"sd\")\n            .join(\"images\");\n        std::fs::create_dir_all(&cache_dir)?;\n        Ok(Self { cache_dir })\n    }\n    \n    /// Generate cache key from source file and target dimensions\n    fn cache_key(source: &Path, width: u32, height: u32) -> String {\n        let content = std::fs::read(source).unwrap_or_default();\n        let mut hasher = Sha256::new();\n        hasher.update(&content);\n        hasher.update(width.to_le_bytes());\n        hasher.update(height.to_le_bytes());\n        let hash = hasher.finalize();\n        format\\!(\"{:x}-{}x{}.bin\", hash, width, height)\n    }\n    \n    /// Get cached image or None if not cached\n    pub fn get(&self, source: &Path, width: u32, height: u32) -> Option<Vec<u8>> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::read(&cache_path).ok()\n    }\n    \n    /// Store processed image in cache\n    pub fn put(&self, source: &Path, width: u32, height: u32, data: &[u8]) -> Result<()> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::write(&cache_path, data)?;\n        Ok(())\n    }\n    \n    /// Get cache statistics\n    pub fn stats(&self) -> CacheStats {\n        let entries: Vec<_> = std::fs::read_dir(&self.cache_dir)\n            .map(|rd| rd.filter_map(|e| e.ok()).collect())\n            .unwrap_or_default();\n        \n        let total_size: u64 = entries.iter()\n            .filter_map(|e| e.metadata().ok())\n            .map(|m| m.len())\n            .sum();\n        \n        CacheStats {\n            location: self.cache_dir.clone(),\n            entries: entries.len(),\n            size_bytes: total_size,\n        }\n    }\n    \n    /// Clear all cached images\n    pub fn clear(&self) -> Result<usize> {\n        let entries = std::fs::read_dir(&self.cache_dir)?;\n        let mut count = 0;\n        for entry in entries.filter_map(|e| e.ok()) {\n            if entry.path().extension().map(|e| e == \"bin\").unwrap_or(false) {\n                std::fs::remove_file(entry.path())?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }\n}\n\n#[derive(Debug)]\npub struct CacheStats {\n    pub location: PathBuf,\n    pub entries: usize,\n    pub size_bytes: u64,\n}\n```\n\n### Phase 2: Integration with set_key_image\n```rust\n// In src/main.rs or src/device.rs\nfn set_key_image_cached(\n    device: &Device,\n    key: u8,\n    path: &Path,\n    cache: &ImageCache,\n) -> Result<()> {\n    let (width, height) = device.info().key_size();\n    \n    // Check cache first\n    if let Some(data) = cache.get(path, width, height) {\n        device.set_key_raw(key, &data)?;\n        return Ok(());\n    }\n    \n    // Cache miss: process image\n    let img = image::open(path)?;\n    let resized = img.resize_exact(width, height, FilterType::Lanczos3);\n    let data = encode_for_device(&resized)?;\n    \n    // Store in cache\n    cache.put(path, width, height, &data)?;\n    \n    // Send to device\n    device.set_key_raw(key, &data)?;\n    Ok(())\n}\n```\n\n### Phase 3: Cache Commands\n```rust\n// In src/cli/mod.rs\nCache {\n    #[command(subcommand)]\n    action: CacheAction,\n}\n\n#[derive(Subcommand)]\nenum CacheAction {\n    /// Show cache statistics\n    Stats,\n    /// Clear all cached images\n    Clear,\n    /// Show cache location\n    Location,\n}\n```\n\n## Cache Invalidation Strategy\nThe content-addressable approach means:\n- If source file changes, hash changes, new cache entry created\n- Old entries become orphaned but harmless\n- Periodic cleanup can remove orphaned entries\n- No explicit invalidation needed for correctness\n\n## Key Design Decisions\n1. **Content-addressable**: Hash-based keys ensure correctness\n2. **Include dimensions in key**: Same image at different sizes = different entries\n3. **Binary format**: Store device-ready bytes, not intermediate images\n4. **Lazy population**: Only cache images that are actually used\n5. **Simple cleanup**: `sd cache clear` removes everything\n\n## Success Criteria\n- [ ] Cache directory created at ~/.cache/sd/images/\n- [ ] Repeated set-key calls use cache (measurable speedup)\n- [ ] Cache key includes source content hash and target dimensions\n- [ ] `sd cache stats` shows cache statistics\n- [ ] `sd cache clear` removes all cached entries\n- [ ] Cache miss processes and stores image\n- [ ] Robot mode reports cache hit/miss\n\n## Files to Create/Modify\n- `src/cache.rs`: New cache module\n- `src/cli/mod.rs`: Add Cache command\n- `src/main.rs`: Integrate cache into set-key operations\n- `Cargo.toml`: Add sha2 dependency\n\n## Dependencies\n- Soft: BATCH-OPS benefits most from caching (many images at once)\n\n## Estimated Subtasks\n1. Add sha2 dependency to Cargo.toml\n2. Implement ImageCache struct with get/put\n3. Implement cache key generation\n4. Integrate cache into set_key_image\n5. Add cache stats command\n6. Add cache clear command\n7. Add robot mode cache hit/miss reporting\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:23.156441630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:19:23.195793021Z","compaction_level":0,"original_size":0,"labels":["cache","optimization","performance","priority-9"]}
{"id":"bd-3pm","title":"Implement init --import command","description":"Implement sd init --import <file>:\n1. Open profile file with ProfileLoader\n2. Parse profile contents\n3. Store in config database with given name\n4. Copy images to config storage\n5. Report import summary\n\nHandle: invalid files, permission errors, existing profiles.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.417682158Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.427250363Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pm","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.427205538Z","created_by":"ubuntu"}]}
{"id":"bd-3pp","title":"Add Fish output format","description":"With --format fish:\n- Use fish shell syntax\n- Different variable handling\n- Proper path quoting for fish","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:03.698067351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:03.710521380Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pp","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:03.710482687Z","created_by":"ubuntu"}]}
{"id":"bd-3pu","title":"EPIC: Shell Completion Scripts","description":"## Overview\n**Rank: #5 of 15** | **Impact: Medium** | **Effort: Very Low** | **Confidence: Very High**\n\nFully implement the `sd completions <shell>` command to generate shell completion scripts for bash, zsh, fish, and PowerShell.\n\n## Problem Statement\nThe `sd completions` command is already stubbed in the CLI definition but the actual clap_complete integration is missing. Without shell completions:\n- Users must remember exact command names and flags\n- Tab completion shows nothing or wrong suggestions\n- The CLI feels unpolished compared to mature tools\n- Discovery of features requires reading help text\n\n## Solution\nComplete the existing stubbed command:\n```bash\n# Generate completions for your shell\nsd completions bash > ~/.local/share/bash-completion/completions/sd\nsd completions zsh > ~/.zfunc/_sd\nsd completions fish > ~/.config/fish/completions/sd.fish\nsd completions powershell > sd.ps1\n\n# Then enjoy tab completion\nsd <TAB>\n# list  info  brightness  set-key  fill-key  clear-key  ...\n\nsd set-key <TAB>\n# Shows: 0 1 2 3 4 5 ... (key indices)\n\nsd --<TAB>\n# Shows: --robot --format --serial --help --version\n```\n\n## Why This Is #5 Priority\n1. **Already stubbed**: The command exists, just needs wiring\n2. **Very low effort**: ~20 lines using clap_complete crate\n3. **High polish signal**: Completions indicate a mature, well-maintained CLI\n4. **Developer experience**: Makes daily use much more pleasant\n5. **Standard pattern**: clap_complete is the canonical solution\n\n## Implementation Approach\n```rust\n// Add to Cargo.toml\n[dependencies]\nclap_complete = \"4\"\n\n// In src/cli/mod.rs - already exists\n#[derive(Subcommand)]\npub enum Command {\n    /// Generate shell completion scripts\n    Completions {\n        /// Shell to generate completions for\n        #[arg(value_enum)]\n        shell: clap_complete::Shell,\n    },\n    // ...\n}\n\n// In main.rs - implement the handler\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n\n// In main dispatch\nCommand::Completions { shell } => cmd_completions(shell),\n```\n\n## Supported Shells\nclap_complete supports:\n- **Bash**: Most common on Linux\n- **Zsh**: Default on macOS, popular on Linux\n- **Fish**: Modern shell with excellent completion support\n- **PowerShell**: Windows default\n- **Elvish**: Niche but supported\n\n## Installation Instructions (to include in help)\n```\nINSTALLATION:\n\nBash (Linux):\n  sd completions bash > ~/.local/share/bash-completion/completions/sd\n  # Or system-wide: sudo sd completions bash > /etc/bash_completion.d/sd\n\nBash (macOS with Homebrew):\n  sd completions bash > $(brew --prefix)/etc/bash_completion.d/sd\n\nZsh:\n  sd completions zsh > ~/.zfunc/_sd\n  # Ensure ~/.zfunc is in fpath and compinit is called\n\nFish:\n  sd completions fish > ~/.config/fish/completions/sd.fish\n\nPowerShell:\n  sd completions powershell >> $PROFILE\n```\n\n## Key Design Decisions\n1. **Use clap_complete**: Standard solution, well-maintained\n2. **Output to stdout**: Let users redirect to appropriate location\n3. **Include installation help**: Show how to install for each shell\n4. **All shells supported**: Dont pick favorites, support what clap_complete offers\n\n## Success Criteria\n- [ ] `sd completions bash` generates valid bash completions\n- [ ] `sd completions zsh` generates valid zsh completions\n- [ ] `sd completions fish` generates valid fish completions\n- [ ] `sd completions powershell` generates valid PowerShell completions\n- [ ] Completions include all commands and flags\n- [ ] Help text includes installation instructions\n\n## Files to Modify\n- `Cargo.toml`: Add clap_complete dependency\n- `src/cli/mod.rs`: Ensure Shell enum is properly defined\n- `src/main.rs`: Implement cmd_completions handler\n\n## Dependencies\nNone - standalone feature, uses existing CLI structure\n\n## Estimated Subtasks\n1. Add clap_complete to Cargo.toml\n2. Implement cmd_completions handler in main.rs\n3. Test generated completions for bash\n4. Test generated completions for zsh\n5. Test generated completions for fish\n6. Add installation instructions to help text","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:11:22.364835803Z","created_by":"ubuntu","updated_at":"2026-01-19T18:11:22.403718031Z","compaction_level":0,"original_size":0,"labels":["cli","developer-experience","polish","priority-5"]}
{"id":"bd-3q3","title":"Implement image caching for snapshots","description":"When saving snapshots:\n1. Read and resize source images\n2. Store processed images in snapshot directory\n3. Use content-addressable naming (SHA256)\n4. On restore, use cached images if source missing\n\nThis provides resilience when source images are moved/deleted.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.703366526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.713034639Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3q3","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.712985466Z","created_by":"ubuntu"}]}
{"id":"bd-3qj","title":"Implement pattern expansion","description":"Pattern expansion for batch key definitions:\n- \"~/icons/row2/{index}.png\" with key 8 → \"~/icons/row2/08.png\"\n- Zero-pad to 2 digits\n- Support in both pattern: field and image: field\n\nHandle missing files gracefully.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.088705856Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:57.098791595Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3qj","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.098753924Z","created_by":"ubuntu"}]}
{"id":"bd-3ro","title":"EPIC: Integrate rich_rust for Premium Terminal Output","description":"# EPIC: Integrate rich_rust for Premium Terminal Output\n\n## Executive Summary\n\nThis epic encompasses the complete integration of the rich_rust library into the Stream Deck CLI (sd) to provide beautiful, stylish terminal output for human observers while strictly preserving the clean JSON robot mode that AI coding agents depend on.\n\n## Background & Context\n\n### The Problem\nThe current Stream Deck CLI uses the `colored` crate for basic terminal coloring. While functional, this approach has limitations:\n1. Limited styling options (just colors, no tables, panels, progress bars)\n2. No automatic terminal capability detection\n3. No consistent visual identity across commands\n4. Output looks utilitarian rather than premium\n\n### The Solution\nrich_rust is a Rust port of Python's Rich library, providing:\n- Markup syntax: [bold red]text[/]\n- Tables with auto-sizing columns\n- Panels with box drawing characters\n- Progress bars and spinners\n- Automatic terminal capability detection (4-bit, 8-bit, 24-bit color)\n- NO_COLOR environment variable compliance\n- TTY vs pipe detection (auto-disables colors when piped)\n\n### Why This Matters\nThe Stream Deck CLI has two distinct user categories:\n1. AI Agents (Primary): Use --robot mode for pure JSON output. These users must NOT be affected.\n2. Human Observers: Watch agents work or use the CLI directly. These users deserve a premium visual experience.\n\nThis integration serves the overarching goal of making sd a best-in-class CLI that is both agent-friendly AND visually impressive for humans.\n\n## Architectural Approach\n\nOutput Mode Bifurcation:\n- Robot Mode: Pure JSON via serde, no ANSI codes, unchanged from current behavior\n- Human Mode: rich_rust Console with styled panels, tables, progress bars\n\nKey Design Decisions:\n1. Output Trait Abstraction: Commands call output.device_list(), output.error(), etc. without knowing the output mode\n2. Zero Agent Impact: Robot mode produces identical JSON to current behavior\n3. Automatic Detection: rich_rust handles NO_COLOR, TTY, color capabilities\n4. Cohesive Theme: Stream Deck blue (#0080FF) accent with consistent styling\n\n## Success Criteria\n- All commands produce beautiful styled output in human mode\n- Robot mode JSON output is byte-for-byte identical to current behavior\n- NO_COLOR environment variable disables all styling\n- Piped output (non-TTY) has no ANSI codes\n- All existing tests pass\n- New visual and regression tests added\n- colored crate removed from dependencies\n\n## Implementation Phases\n1. Foundation Infrastructure (output module, theme system)\n2. Command Implementations (device list, info, errors, etc.)\n3. Main.rs Integration (wire up new output system)\n4. Testing & Verification\n5. Polish & Documentation\n\n## Risk Considerations\n- Breaking agent workflows: Mitigated by extensive robot mode regression tests\n- Terminal compatibility: Mitigated by rich_rust auto-detection and safe_box fallback\n- Binary size increase: Acceptable tradeoff for functionality\n\n## References\n- rich_rust crate: /dp/rich_rust\n- Python Rich (inspiration): https://github.com/Textualize/rich\n- NO_COLOR standard: https://no-color.org/","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T21:01:56.022368636Z","created_by":"ubuntu","updated_at":"2026-01-19T21:01:56.061179540Z","compaction_level":0,"original_size":0,"labels":["infrastructure","rich-rust","ui"]}
{"id":"bd-3w1","title":"Write tests for dry-run behavior","description":"## Test Coverage for Dry-Run Mode\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **Flag Parsing Tests**\n   - Global `--dry-run` flag recognized\n   - Works with all mutating commands\n   - Combines with `--robot` flag correctly\n   - Short form `-n` if supported\n\n2. **Validation Without Execution Tests**\n   - Image path validated (exists, readable)\n   - Image format validated (PNG, JPG)\n   - Image dimensions extracted\n   - Color values validated (#RRGGBB format)\n   - Key indices validated against device model\n\n3. **Output Format Tests**\n   - Human output shows \"DRY RUN:\" prefix\n   - Human output describes intended action\n   - Robot output includes `\"dry_run\": true`\n   - Robot output includes all details that would be used\n\n### Integration Tests (require MockDevice)\n\n1. **Brightness Dry-Run**\n   - Shows target brightness level\n   - Shows current brightness (if readable)\n   - Device brightness NOT changed\n   - MockDevice confirms no set_brightness call\n\n2. **Set-Key Dry-Run**\n   - Shows source image path and dimensions\n   - Shows target key index\n   - Shows resize details (if needed)\n   - Device key NOT changed\n   - MockDevice confirms no set_key_image call\n\n3. **Fill-Key Dry-Run**\n   - Shows target key and color\n   - Color value parsed and displayed\n   - Device key NOT changed\n\n4. **Clear-Key Dry-Run**\n   - Shows key(s) that would be cleared\n   - Device key NOT changed\n\n5. **Set-Keys (Batch) Dry-Run**\n   - Shows full manifest of directory contents\n   - Each key shows: index, source, dimensions, resize needed\n   - Missing files noted\n   - Pattern matching explained\n   - NO device operations performed\n\n6. **Error Preview**\n   - Invalid image shows error that would occur\n   - Invalid key index shows error\n   - Missing file shows error\n   - All errors include suggestions\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Verification**\n   - `sd brightness 80 --dry-run` shows preview, exit 0\n   - `sd set-key 0 icon.png --dry-run` shows preview, exit 0\n   - `sd set-key 99 icon.png --dry-run` shows error, exit 1\n   - `sd set-keys ./dir/ --dry-run` shows full manifest\n\n2. **Robot Mode Integration**\n   - `sd brightness 80 --dry-run --robot` returns valid JSON\n   - JSON includes `dry_run`, `would_succeed`, `details`\n   - CI can validate operations without hardware\n\n3. **No Side Effects Verification**\n   - Run dry-run command\n   - Verify no state files created\n   - Verify no cache files created\n   - Verify no device communication attempted\n\n### Logging Requirements\n- DEBUG: Validation steps performed\n- INFO: Dry-run summary (what would happen)\n- WARN: Potential issues that would occur\n- ERROR: Validation failures\n\n### Test Assertions\n- MockDevice operation count == 0 after all dry-run tests\n- Exit code 0 for valid dry-run operations\n- Exit code non-zero for invalid operations (even in dry-run)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:45.129502306Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:39.133671236Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3w1","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:37.325986601Z","created_by":"ubuntu"},{"issue_id":"bd-3w1","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:39.133615090Z","created_by":"ubuntu"},{"issue_id":"bd-3w1","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:45.138653376Z","created_by":"ubuntu"}]}
{"id":"bd-4zd","title":"Implement key image upload endpoint","description":"POST /api/keys/:id with multipart form:\n- Accept image file upload\n- Process and resize\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:44.553749212Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:44.570008184Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-4zd","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:44.569957699Z","created_by":"ubuntu"}]}
{"id":"bd-533","title":"Phase 2: Command Output Implementations","description":"# Phase 2: Command Output Implementations\n\n## Purpose\nImplement detailed, polished rich_rust formatting for each CLI command's human-mode output. This phase transforms the HumanOutput skeleton into production-quality visual output.\n\n## Background\nPhase 1 established the infrastructure (Output trait, RobotOutput, HumanOutput skeleton). Phase 2 fills in the skeleton with beautiful, information-rich formatting using rich_rust's full capabilities:\n- Tables for structured data (device info, key layouts)\n- Panels for grouped content (errors, version info)\n- Progress bars for numeric values (brightness)\n- Styled text for events (button presses)\n- Rules for visual separation\n\n## Deliverables\nEach command gets a dedicated task with specific visual design:\n1. Device list - Panel with device cards\n2. Device info - Table in panel with key layout grid\n3. Error output - Error panel with styled suggestion\n4. Brightness - Progress bar visualization\n5. Key operations - Checkmark confirmations\n6. Button events - Styled event stream with timestamps\n7. Version info - Styled info panel\n8. Watch header - Section divider with hint\n\n## Visual Design Guidelines\n\n### Consistency\n- All panels use rounded box style (╭─╮)\n- Accent color (#0080FF) for informational panels\n- Success color (#00D26A) for confirmations\n- Error color (#FF4757) for errors\n- Warning color (#FFA502) for key indices\n\n### Information Hierarchy\n1. Primary: Bold, accent colored (device names, section headers)\n2. Secondary: Regular weight, default color (values)\n3. Tertiary: Dim, muted color (labels, hints)\n\n### Spacing\n- Single blank line between major sections\n- Consistent padding inside panels (1 space)\n- Table cell padding for readability\n\n## Success Criteria\n- [ ] Each command produces visually appealing output\n- [ ] Consistent visual style across all commands\n- [ ] Information is easy to scan and understand\n- [ ] Output adapts to terminal width\n- [ ] ASCII fallback works when needed (safe_box mode)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:05:01.203352029Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:01.248739926Z","compaction_level":0,"original_size":0,"labels":["commands","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-533","depends_on_id":"bd-1vw","type":"blocks","created_at":"2026-01-19T21:05:01.248711212Z","created_by":"ubuntu"},{"issue_id":"bd-533","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:05:01.244967924Z","created_by":"ubuntu"}]}
{"id":"bd-53g","title":"Add --embed-images with base64 encoding","description":"With --embed-images flag:\n1. Read each source image\n2. Base64 encode\n3. Generate self-contained commands:\n```bash\necho \"BASE64DATA\" | base64 -d > /tmp/key0.png\nsd set-key 0 /tmp/key0.png\n```\n\nOr use stdin if supported: sd set-key 0 - < <(echo ... | base64 -d)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:02.311118252Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:02.327835748Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-53g","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.327718307Z","created_by":"ubuntu"}]}
{"id":"bd-5v0","title":"Implement dry-run for fill-key command","description":"When dry_run=true:\n- Parse and validate color\n- Show key index\n- Show color value (hex and RGB)\n- Return without applying","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.368495216Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.379392443Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-5v0","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.379338892Z","created_by":"ubuntu"}]}
{"id":"bd-8r8","title":"Implement apply command","description":"Implement sd apply <name>:\n1. Load profile from database\n2. Verify device compatibility\n3. Set brightness if stored\n4. Apply each key (image, color, or clear)\n5. Report results\n\nConsider: partial application, error handling.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.101462966Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.110721928Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-8r8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.110682404Z","created_by":"ubuntu"}]}
{"id":"bd-9c7","title":"Implement dry-run for set-key command","description":"When dry_run=true:\n1. Validate image exists and is readable\n2. Load image to get dimensions\n3. Calculate resize requirements\n4. Report all details without applying\n\nInclude: source path, dimensions, resize behavior, target key","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.180066411Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.190846257Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9c7","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.190801533Z","created_by":"ubuntu"}]}
{"id":"bd-9gy","title":"Test generated completions for bash","description":"Manual testing:\n1. Generate: sd completions bash > /tmp/sd.bash\n2. Source: source /tmp/sd.bash\n3. Test: sd <TAB> shows commands\n4. Test: sd --<TAB> shows flags\n5. Verify no syntax errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.664311526Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:11.702369434Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9gy","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:11.702321995Z","created_by":"ubuntu"},{"issue_id":"bd-9gy","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.674414859Z","created_by":"ubuntu"}]}
{"id":"bd-a1n","title":"Implement KeySelector parsing and resolution","description":"Implement KeySelector enum and parsing:\n- Single(u8): \"0\", \"15\"\n- Range(u8, u8): \"8-15\"\n- Row(u8): \"row-0\", \"row-3\"\n- Default: \"default\"\n\nInclude resolve() method that returns Vec<u8> of key indices.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.902317074Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:55.914106651Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-a1n","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.914061186Z","created_by":"ubuntu"}]}
{"id":"bd-aox","title":"Implement text overlay on images","description":"Add overlay function:\n```rust\npub fn overlay_text(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage\n```\n\nOptional background rectangle for readability.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.807308593Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.818600052Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-aox","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.818546131Z","created_by":"ubuntu"}]}
{"id":"bd-b14","title":"Set up axum server skeleton","description":"## Purpose\nCreate the foundational web server infrastructure using axum for the Stream Deck web dashboard.\n\n## Implementation\n```rust\n// src/server/mod.rs\npub mod api;\npub mod state;\n\nuse axum::{Router, routing::get, Extension};\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tower_http::cors::{CorsLayer, Any};\nuse tower_http::services::ServeDir;\nuse tracing::{debug, info, warn, error, instrument};\n\nuse crate::device::Device;\n\npub use state::AppState;\n\n/// Server configuration\n#[derive(Debug, Clone)]\npub struct ServerConfig {\n    pub port: u16,\n    pub host: String,\n    pub auto_open: bool,\n    pub static_dir: Option<std::path::PathBuf>,\n}\n\nimpl Default for ServerConfig {\n    fn default() -> Self {\n        Self {\n            port: 8420,\n            host: \"127.0.0.1\".to_string(),\n            auto_open: true,\n            static_dir: None,\n        }\n    }\n}\n\n/// Create the main application router\n#[instrument(skip(state))]\npub fn create_router(state: AppState, config: &ServerConfig) -> Router {\n    info!(\"Creating API router\");\n    \n    let api_routes = Router::new()\n        .route(\"/device\", get(api::get_device_info))\n        .route(\"/brightness\", get(api::get_brightness).put(api::set_brightness))\n        .route(\"/keys\", get(api::get_keys))\n        .route(\"/keys/:id\", \n            axum::routing::put(api::set_key)\n                .delete(api::clear_key))\n        .route(\"/keys/:id/color\", axum::routing::put(api::set_key_color))\n        .route(\"/health\", get(api::health_check));\n    \n    let mut router = Router::new()\n        .nest(\"/api\", api_routes)\n        .layer(CorsLayer::new()\n            .allow_origin(Any)\n            .allow_methods(Any)\n            .allow_headers(Any))\n        .with_state(state);\n    \n    // Serve static files (frontend)\n    if let Some(ref static_dir) = config.static_dir {\n        debug!(dir = %static_dir.display(), \"Serving static files\");\n        router = router.nest_service(\"/\", ServeDir::new(static_dir));\n    } else {\n        // In release builds, serve embedded assets\n        #[cfg(not(debug_assertions))]\n        {\n            use crate::server::embedded::EmbeddedAssets;\n            router = router.fallback_service(EmbeddedAssets);\n        }\n        \n        #[cfg(debug_assertions)]\n        {\n            // In debug, serve from default static directory\n            let default_static = std::path::PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n                .join(\"static\");\n            if default_static.exists() {\n                debug!(dir = %default_static.display(), \"Serving static files from default location\");\n                router = router.nest_service(\"/\", ServeDir::new(default_static));\n            }\n        }\n    }\n    \n    router\n}\n\n/// Start the web server\n#[instrument(skip(device))]\npub async fn start_server(\n    device: Device,\n    config: ServerConfig,\n) -> Result<(), ServerError> {\n    let addr: SocketAddr = format!(\"{}:{}\", config.host, config.port)\n        .parse()\n        .map_err(|e| ServerError::InvalidAddress(format!(\"{}\", e)))?;\n    \n    let state = AppState::new(device);\n    let router = create_router(state, &config);\n    \n    info!(\n        host = %config.host,\n        port = %config.port,\n        \"Starting web server\"\n    );\n    \n    // Auto-open browser\n    if config.auto_open {\n        let url = format!(\"http://{}:{}\", config.host, config.port);\n        info!(url = %url, \"Opening browser\");\n        \n        if let Err(e) = open_browser(&url) {\n            warn!(error = %e, \"Failed to open browser automatically\");\n        }\n    }\n    \n    println!(\"Stream Deck web interface running at http://{}:{}\", config.host, config.port);\n    println!(\"Press Ctrl+C to stop\");\n    \n    let listener = tokio::net::TcpListener::bind(addr).await\n        .map_err(|e| ServerError::BindFailed(e))?;\n    \n    axum::serve(listener, router)\n        .await\n        .map_err(|e| ServerError::ServerFailed(e))?;\n    \n    Ok(())\n}\n\n/// Open URL in default browser\nfn open_browser(url: &str) -> Result<(), std::io::Error> {\n    #[cfg(target_os = \"macos\")]\n    {\n        std::process::Command::new(\"open\").arg(url).spawn()?;\n    }\n    \n    #[cfg(target_os = \"linux\")]\n    {\n        std::process::Command::new(\"xdg-open\").arg(url).spawn()?;\n    }\n    \n    #[cfg(target_os = \"windows\")]\n    {\n        std::process::Command::new(\"cmd\")\n            .args([\"/C\", \"start\", url])\n            .spawn()?;\n    }\n    \n    Ok(())\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ServerError {\n    #[error(\"Invalid address: {0}\")]\n    InvalidAddress(String),\n    \n    #[error(\"Failed to bind to address: {0}\")]\n    BindFailed(std::io::Error),\n    \n    #[error(\"Server error: {0}\")]\n    ServerFailed(std::io::Error),\n}\n```\n\n### Application State\n```rust\n// src/server/state.rs\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse crate::device::Device;\n\n/// Shared application state for all handlers\n#[derive(Clone)]\npub struct AppState {\n    /// Device handle (thread-safe)\n    device: Arc<RwLock<Device>>,\n}\n\nimpl AppState {\n    pub fn new(device: Device) -> Self {\n        Self {\n            device: Arc::new(RwLock::new(device)),\n        }\n    }\n    \n    /// Get read access to device\n    pub async fn device(&self) -> tokio::sync::RwLockReadGuard<'_, Device> {\n        self.device.read().await\n    }\n    \n    /// Get write access to device\n    pub async fn device_mut(&self) -> tokio::sync::RwLockWriteGuard<'_, Device> {\n        self.device.write().await\n    }\n}\n```\n\n### Health Check Endpoint\n```rust\n// src/server/api.rs (partial)\nuse axum::Json;\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct HealthResponse {\n    pub status: String,\n    pub version: String,\n    pub device_connected: bool,\n}\n\npub async fn health_check(\n    State(state): State<AppState>,\n) -> Json<HealthResponse> {\n    let device_connected = state.device().await.is_connected();\n    \n    Json(HealthResponse {\n        status: \"ok\".to_string(),\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        device_connected,\n    })\n}\n```\n\n### CLI Integration\n```rust\n// In src/main.rs cmd_serve handler\nasync fn cmd_serve(opts: ServeOptions, device: Device) -> Result<()> {\n    let config = ServerConfig {\n        port: opts.port,\n        host: opts.host.unwrap_or_else(|| \"127.0.0.1\".to_string()),\n        auto_open: !opts.no_open,\n        static_dir: opts.static_dir,\n    };\n    \n    server::start_server(device, config).await?;\n    \n    Ok(())\n}\n```\n\n## Dependencies to Add\n```toml\n# Cargo.toml additions\n[dependencies]\naxum = \"0.8\"\ntokio = { version = \"1\", features = [\"full\"] }\ntower = \"0.5\"\ntower-http = { version = \"0.6\", features = [\"fs\", \"cors\"] }\n```\n\n## Success Criteria\n- [ ] Server starts on configurable port (default 8420)\n- [ ] CORS enabled for local development\n- [ ] Static files served from filesystem or embedded\n- [ ] Browser auto-opens on start (unless --no-open)\n- [ ] Health check endpoint returns device status\n- [ ] Graceful shutdown on Ctrl+C\n\n## Logging Requirements\n- TRACE: (none for server skeleton)\n- DEBUG: Static file directory, request routing\n- INFO: Server starting, browser opening, server address\n- WARN: Failed to open browser\n- ERROR: Bind failed, server error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:42.555773688Z","created_by":"ubuntu","updated_at":"2026-01-19T20:53:01.456137464Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-b14","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:42.584443487Z","created_by":"ubuntu"}]}
{"id":"bd-bxu","title":"Create integration test module structure","description":"## Purpose\nOrganize integration tests that test component interactions without real hardware.\n\n## Directory Structure\n```\ntests/\n├── common/\n│   ├── mod.rs\n│   ├── cli.rs        # E2E CLI helpers\n│   ├── mock.rs       # MockDevice re-export\n│   └── fixtures.rs   # Fixture path helpers\n├── fixtures/         # Test data (see other task)\n├── e2e/\n│   ├── mod.rs\n│   ├── batch.rs\n│   ├── brightness.rs\n│   ├── config.rs\n│   └── watch.rs\n└── integration/\n    ├── mod.rs\n    ├── device_operations.rs\n    ├── image_processing.rs\n    ├── config_parsing.rs\n    └── state_management.rs\n```\n\n## Integration Test Examples\n```rust\n// tests/integration/device_operations.rs\nuse sd::device::{MockDevice, DeviceModel, DeviceOperations};\n\n#[test]\nfn test_brightness_bounds() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    \n    // Valid brightness\n    device.set_brightness(50).unwrap();\n    assert_eq!(device.get_brightness(), 50);\n    \n    // Boundary values\n    device.set_brightness(0).unwrap();\n    device.set_brightness(100).unwrap();\n}\n\n#[test]\nfn test_key_image_recording() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    let image_data = vec![0u8; 72 * 72 * 3];\n    \n    device.set_key_image(0, &image_data).unwrap();\n    \n    let ops = device.get_operations();\n    assert!(matches!(ops[0], Operation::SetKeyImage { key: 0, .. }));\n    assert_eq!(device.get_key_image(0), Some(&image_data[..]));\n}\n\n#[test]\nfn test_error_injection() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    device.inject_error(SdError::DeviceDisconnected);\n    \n    let result = device.set_brightness(50);\n    assert!(matches!(result, Err(SdError::DeviceDisconnected)));\n}\n```\n\n## Success Criteria\n- [ ] Test modules organized by feature area\n- [ ] Integration tests use MockDevice\n- [ ] Tests cover happy path and error cases\n- [ ] Tests are independent and can run in parallel\n- [ ] Clear naming convention for test functions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:52.095169802Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:52.105597025Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-bxu","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:52.105542662Z","created_by":"ubuntu"}]}
{"id":"bd-df0","title":"Handle missing source images gracefully","description":"When restoring and source image is missing:\n1. Check for cached version in snapshot\n2. If cached exists, use it and warn user\n3. If no cache, skip key and report error\n4. Continue with other keys (dont fail completely)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.843973672Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.853646294Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-df0","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.853607040Z","created_by":"ubuntu"}]}
{"id":"bd-e36","title":"Implement session state tracking","description":"## Purpose\nTrack device state changes during a session for snapshots and export functionality.\n\n## Implementation\n\n```rust\n// src/state.rs\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::sync::{Arc, RwLock};\nuse tracing::{debug, trace, info, instrument};\n\n/// State of a single key\n#[derive(Debug, Clone)]\npub enum KeyState {\n    /// Key has an image set (source path)\n    Image(PathBuf),\n    /// Key filled with solid color (hex)\n    Color(String),\n    /// Key explicitly cleared\n    Cleared,\n}\n\n/// Tracked session state\n#[derive(Debug, Clone, Default)]\npub struct SessionState {\n    /// Current brightness (if set during session)\n    pub brightness: Option<u8>,\n    /// Per-key state (only keys modified during session)\n    pub keys: HashMap<u8, KeyState>,\n}\n\nimpl SessionState {\n    /// Record a brightness change\n    #[instrument(skip(self))]\n    pub fn record_brightness(&mut self, level: u8) {\n        debug!(level = %level, \"Recording brightness change\");\n        self.brightness = Some(level);\n    }\n    \n    /// Record setting a key image\n    #[instrument(skip(self), fields(key = %key, path = %path.display()))]\n    pub fn record_set_key(&mut self, key: u8, path: PathBuf) {\n        trace!(\"Recording key image\");\n        self.keys.insert(key, KeyState::Image(path));\n    }\n    \n    /// Record filling a key with color\n    #[instrument(skip(self), fields(key = %key, color = %color))]\n    pub fn record_fill_key(&mut self, key: u8, color: String) {\n        trace!(\"Recording key color\");\n        self.keys.insert(key, KeyState::Color(color));\n    }\n    \n    /// Record clearing a key\n    #[instrument(skip(self))]\n    pub fn record_clear_key(&mut self, key: u8) {\n        trace!(key = %key, \"Recording key clear\");\n        self.keys.insert(key, KeyState::Cleared);\n    }\n    \n    /// Clear all tracked state\n    pub fn reset(&mut self) {\n        info!(\"Session state reset\");\n        self.brightness = None;\n        self.keys.clear();\n    }\n    \n    /// Check if any state has been tracked\n    pub fn is_empty(&self) -> bool {\n        self.brightness.is_none() && self.keys.is_empty()\n    }\n    \n    /// Get count of tracked keys\n    pub fn key_count(&self) -> usize {\n        self.keys.len()\n    }\n}\n\n/// Global session state with thread-safe access\nstatic SESSION_STATE: once_cell::sync::Lazy<Arc<RwLock<SessionState>>> = \n    once_cell::sync::Lazy::new(|| Arc::new(RwLock::new(SessionState::default())));\n\n/// Get read access to session state\npub fn session_state() -> std::sync::RwLockReadGuard<'static, SessionState> {\n    SESSION_STATE.read().unwrap()\n}\n\n/// Get write access to session state\npub fn session_state_mut() -> std::sync::RwLockWriteGuard<'static, SessionState> {\n    SESSION_STATE.write().unwrap()\n}\n\n/// Record operations using the global state\npub mod record {\n    use super::*;\n    \n    pub fn brightness(level: u8) {\n        session_state_mut().record_brightness(level);\n    }\n    \n    pub fn set_key(key: u8, path: PathBuf) {\n        session_state_mut().record_set_key(key, path);\n    }\n    \n    pub fn fill_key(key: u8, color: String) {\n        session_state_mut().record_fill_key(key, color);\n    }\n    \n    pub fn clear_key(key: u8) {\n        session_state_mut().record_clear_key(key);\n    }\n}\n```\n\n## Integration Points\n- All mutating commands call record::* after successful device operation\n- Snapshot save serializes session_state()\n- Export iterates session_state().keys\n- New session resets state (optional, for long-running processes)\n\n## Edge Cases\n- Multiple operations on same key → latest wins\n- clear-all → iterate all keys or track separately\n- No operations → empty state (valid for empty snapshot)\n\n## Logging Requirements\n- TRACE: Each individual state change\n- DEBUG: State change with details (path, color, level)\n- INFO: State reset, summary on snapshot save\n- WARN: (none expected)\n- ERROR: (none - state changes can't fail)\n\n## Success Criteria\n- [ ] All mutating commands update state\n- [ ] State survives across commands in session\n- [ ] Thread-safe for potential concurrent access\n- [ ] Reset clears all tracked data\n- [ ] State serializes correctly for snapshots","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.077604396Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:45.292740024Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e36","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.086576789Z","created_by":"ubuntu"}]}
{"id":"bd-e3b","title":"Implement cache key generation","description":"Generate cache key from:\n- SHA256 of source file contents\n- Target dimensions (width, height)\n\nFormat: {hash}-{w}x{h}.bin\nExample: a1b2c3d4...72x72.bin","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.776692846Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.786506503Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e3b","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.786457801Z","created_by":"ubuntu"}]}
{"id":"bd-eg3r","title":"Implement version_info with styled info Panel","description":"# Implement version_info with styled info Panel\n\n## Purpose\nDisplay version and build information in a polished panel format. This is shown when users run sd version and provides useful debugging information while looking professional.\n\n## Target Output\n```\n╭───────────────────── sd ─────────────────────╮\n│                                              │\n│  Version     0.1.0                           │\n│  Git SHA     8ce48bc (dirty)                 │\n│  Built       2026-01-19T10:30:00Z            │\n│  Rust        1.85.0-nightly                  │\n│  Target      x86_64-unknown-linux-gnu        │\n│                                              │\n╰──────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### version_info Method\n```rust\nfn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n    let mut content = Text::new(\"\\n\");\n    \n    // Version (always present)\n    content.append_styled(\"  Version     \", self.theme.label.clone());\n    content.append_styled(&format!(\"{}\\n\", version), self.theme.value.clone());\n    \n    // Git SHA (from vergen, may include dirty flag)\n    if let Some(sha) = git_sha {\n        content.append_styled(\"  Git SHA     \", self.theme.label.clone());\n        \n        // Color dirty indicator red\n        if sha.contains(\"dirty\") {\n            let clean_sha = sha.replace(\" (dirty)\", \"\").replace(\"(dirty)\", \"\");\n            content.append_styled(&clean_sha, self.theme.value.clone());\n            content.append_styled(\" (dirty)\", Style::new().color(self.theme.warning.clone()));\n        } else {\n            content.append_styled(sha, self.theme.value.clone());\n        }\n        content.append(\"\\n\");\n    }\n    \n    // Build time\n    if let Some(time) = build_time {\n        content.append_styled(\"  Built       \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", time), self.theme.muted.clone());\n    }\n    \n    // Rust version (from env at compile time)\n    if let Ok(rustc) = std::env::var(\"VERGEN_RUSTC_SEMVER\") {\n        content.append_styled(\"  Rust        \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", rustc), self.theme.muted.clone());\n    }\n    \n    // Target triple\n    if let Ok(target) = std::env::var(\"VERGEN_CARGO_TARGET_TRIPLE\") {\n        content.append_styled(\"  Target      \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", target), self.theme.muted.clone());\n    }\n    \n    content.append(\"\\n\");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"sd\")\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n### Compile-Time Metadata Access\nThe build.rs uses vergen to embed these at compile time:\n```rust\n// Access in main.rs or version command\nconst VERSION: &str = env!(\"CARGO_PKG_VERSION\");\nconst GIT_SHA: Option<&str> = option_env!(\"VERGEN_GIT_SHA\");\nconst GIT_DIRTY: Option<&str> = option_env!(\"VERGEN_GIT_DIRTY\");\nconst BUILD_TIME: Option<&str> = option_env!(\"VERGEN_BUILD_TIMESTAMP\");\nconst RUSTC_VERSION: Option<&str> = option_env!(\"VERGEN_RUSTC_SEMVER\");\nconst TARGET_TRIPLE: Option<&str> = option_env!(\"VERGEN_CARGO_TARGET_TRIPLE\");\n\n// Combine SHA and dirty flag\nlet git_sha = match (GIT_SHA, GIT_DIRTY) {\n    (Some(sha), Some(\"true\")) => Some(format!(\"{} (dirty)\", sha)),\n    (Some(sha), _) => Some(sha.to_string()),\n    _ => None,\n};\n```\n\n## Design Decisions\n\n### Panel Title \"sd\"\n- Short, recognizable\n- Matches CLI name\n- Centered in accent color\n\n### Label Alignment\n- Fixed-width labels (12 chars with padding)\n- Creates visual column alignment\n- Easy to scan\n\n### Dirty Indicator\n- Yellow/amber color draws attention\n- Indicates uncommitted changes in build\n- Useful for debugging version issues\n\n### Optional Fields\n- Git SHA may not be available (non-git checkout)\n- Build time may be disabled\n- Gracefully omit missing fields\n\n### Information Selection\n- Version: Primary identifier\n- Git SHA: Exact commit for bug reports\n- Build time: When binary was compiled\n- Rust version: Compiler used\n- Target: Architecture (useful for cross-compiled binaries)\n\n## Testing\n```rust\n#[test]\nfn version_info_shows_version() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| {\n        output.version_info(\"0.1.0\", Some(\"abc123\"), Some(\"2026-01-01T00:00:00Z\"));\n    });\n    \n    assert!(captured.contains(\"0.1.0\"));\n    assert!(captured.contains(\"abc123\"));\n}\n\n#[test]\nfn version_info_highlights_dirty() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| {\n        output.version_info(\"0.1.0\", Some(\"abc123 (dirty)\"), None);\n    });\n    \n    // Verify dirty indicator is present and styled differently\n    assert!(captured.contains(\"dirty\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] Version info displays in styled panel\n- [ ] Panel title is \"sd\"\n- [ ] Labels are aligned in a column\n- [ ] Dirty indicator is highlighted in amber/yellow\n- [ ] Missing fields are gracefully omitted\n- [ ] Border uses accent color","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:08:14.737413735Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:14.781492096Z","compaction_level":0,"original_size":0,"labels":["metadata","phase-2","rich-rust","version"],"dependencies":[{"issue_id":"bd-eg3r","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:08:14.781454505Z","created_by":"ubuntu"},{"issue_id":"bd-eg3r","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:08:14.775782225Z","created_by":"ubuntu"}]}
{"id":"bd-gbs","title":"Implement cmd_completions handler in main.rs","description":"Implement the completions command:\n```rust\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n```\n\nAdd dispatch in main match statement.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.459670076Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.469921677Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-gbs","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.469880500Z","created_by":"ubuntu"}]}
{"id":"bd-hgu","title":"Implement ImageCache struct with get/put","description":"## Purpose\nCreate the core ImageCache struct that stores pre-processed, device-ready image data.\n\n## Implementation\n```rust\n// src/cache.rs\nuse std::path::{Path, PathBuf};\nuse std::io;\nuse tracing::{debug, trace, info, warn, error, instrument};\n\n/// Content-addressable image cache for pre-processed device images\npub struct ImageCache {\n    cache_dir: PathBuf,\n    /// Track hits and misses for statistics\n    hits: std::sync::atomic::AtomicU64,\n    misses: std::sync::atomic::AtomicU64,\n}\n\nimpl ImageCache {\n    /// Create new cache, initializing directory structure\n    #[instrument]\n    pub fn new() -> Result<Self, CacheError> {\n        let cache_dir = Self::default_cache_dir()?;\n        \n        trace!(dir = %cache_dir.display(), \"Creating cache directory\");\n        std::fs::create_dir_all(&cache_dir)?;\n        \n        info!(dir = %cache_dir.display(), \"Image cache initialized\");\n        \n        Ok(Self {\n            cache_dir,\n            hits: std::sync::atomic::AtomicU64::new(0),\n            misses: std::sync::atomic::AtomicU64::new(0),\n        })\n    }\n    \n    /// Create cache at specific location (for testing)\n    pub fn with_dir(cache_dir: PathBuf) -> Result<Self, CacheError> {\n        std::fs::create_dir_all(&cache_dir)?;\n        Ok(Self {\n            cache_dir,\n            hits: std::sync::atomic::AtomicU64::new(0),\n            misses: std::sync::atomic::AtomicU64::new(0),\n        })\n    }\n    \n    /// Get default cache directory (~/.cache/sd/images/)\n    fn default_cache_dir() -> Result<PathBuf, CacheError> {\n        dirs::cache_dir()\n            .ok_or(CacheError::NoCacheDir)\n            .map(|d| d.join(\"sd\").join(\"images\"))\n    }\n    \n    /// Retrieve cached image data if it exists\n    #[instrument(skip(self), fields(cache_key))]\n    pub fn get(&self, source: &Path, width: u32, height: u32) -> Option<Vec<u8>> {\n        let key = cache_key(source, width, height)?;\n        let cache_path = self.cache_dir.join(&key);\n        \n        tracing::Span::current().record(\"cache_key\", &key);\n        \n        match std::fs::read(&cache_path) {\n            Ok(data) => {\n                self.hits.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                debug!(\n                    size_bytes = %data.len(),\n                    \"Cache hit\"\n                );\n                Some(data)\n            }\n            Err(e) if e.kind() == io::ErrorKind::NotFound => {\n                self.misses.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                trace!(\"Cache miss\");\n                None\n            }\n            Err(e) => {\n                warn!(error = %e, \"Cache read error\");\n                self.misses.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                None\n            }\n        }\n    }\n    \n    /// Store processed image in cache\n    #[instrument(skip(self, data), fields(cache_key, size_bytes = %data.len()))]\n    pub fn put(&self, source: &Path, width: u32, height: u32, data: &[u8]) -> Result<(), CacheError> {\n        let key = cache_key(source, width, height)\n            .ok_or(CacheError::InvalidSource)?;\n        let cache_path = self.cache_dir.join(&key);\n        \n        tracing::Span::current().record(\"cache_key\", &key);\n        \n        trace!(\"Writing to cache\");\n        \n        // Write to temp file first, then rename (atomic)\n        let temp_path = cache_path.with_extension(\"tmp\");\n        std::fs::write(&temp_path, data)?;\n        std::fs::rename(&temp_path, &cache_path)?;\n        \n        debug!(\"Cached successfully\");\n        Ok(())\n    }\n    \n    /// Get cache statistics\n    pub fn stats(&self) -> CacheStats {\n        let entries = std::fs::read_dir(&self.cache_dir)\n            .map(|rd| rd.filter_map(|e| e.ok()).collect::<Vec<_>>())\n            .unwrap_or_default();\n        \n        let total_size: u64 = entries.iter()\n            .filter_map(|e| e.metadata().ok())\n            .map(|m| m.len())\n            .sum();\n        \n        let hits = self.hits.load(std::sync::atomic::Ordering::Relaxed);\n        let misses = self.misses.load(std::sync::atomic::Ordering::Relaxed);\n        \n        CacheStats {\n            location: self.cache_dir.clone(),\n            entries: entries.len(),\n            size_bytes: total_size,\n            hits,\n            misses,\n        }\n    }\n    \n    /// Clear all cached images, returns count of removed entries\n    #[instrument(skip(self))]\n    pub fn clear(&self) -> Result<usize, CacheError> {\n        let entries = std::fs::read_dir(&self.cache_dir)?;\n        let mut count = 0;\n        \n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            if path.extension().map(|e| e == \"bin\").unwrap_or(false) {\n                trace!(file = %path.display(), \"Removing cached file\");\n                std::fs::remove_file(&path)?;\n                count += 1;\n            }\n        }\n        \n        info!(removed = %count, \"Cache cleared\");\n        Ok(count)\n    }\n}\n\n/// Generate cache key from source file and dimensions\nfn cache_key(source: &Path, width: u32, height: u32) -> Option<String> {\n    use sha2::{Sha256, Digest};\n    \n    let content = std::fs::read(source).ok()?;\n    \n    let mut hasher = Sha256::new();\n    hasher.update(&content);\n    hasher.update(width.to_le_bytes());\n    hasher.update(height.to_le_bytes());\n    let hash = hasher.finalize();\n    \n    Some(format!(\"{:x}-{}x{}.bin\", hash, width, height))\n}\n\n#[derive(Debug)]\npub struct CacheStats {\n    pub location: PathBuf,\n    pub entries: usize,\n    pub size_bytes: u64,\n    pub hits: u64,\n    pub misses: u64,\n}\n\nimpl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        let total = self.hits + self.misses;\n        if total == 0 {\n            0.0\n        } else {\n            self.hits as f64 / total as f64\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum CacheError {\n    #[error(\"No cache directory available\")]\n    NoCacheDir,\n    #[error(\"Invalid source path\")]\n    InvalidSource,\n    #[error(\"IO error: {0}\")]\n    Io(#[from] io::Error),\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_cache_miss_then_hit() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        // Create a test image file\n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"fake image data\").unwrap();\n        \n        // First access should miss\n        assert!(cache.get(&img_path, 72, 72).is_none());\n        \n        // Store data\n        cache.put(&img_path, 72, 72, b\"processed data\").unwrap();\n        \n        // Second access should hit\n        let data = cache.get(&img_path, 72, 72).unwrap();\n        assert_eq!(data, b\"processed data\");\n    }\n    \n    #[test]\n    fn test_different_dimensions_different_keys() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"fake image\").unwrap();\n        \n        cache.put(&img_path, 72, 72, b\"72x72 data\").unwrap();\n        cache.put(&img_path, 96, 96, b\"96x96 data\").unwrap();\n        \n        assert_eq!(cache.get(&img_path, 72, 72).unwrap(), b\"72x72 data\");\n        assert_eq!(cache.get(&img_path, 96, 96).unwrap(), b\"96x96 data\");\n    }\n    \n    #[test]\n    fn test_stats() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"test\").unwrap();\n        \n        // Miss, store, hit, hit\n        cache.get(&img_path, 72, 72);  // miss\n        cache.put(&img_path, 72, 72, b\"data\").unwrap();\n        cache.get(&img_path, 72, 72);  // hit\n        cache.get(&img_path, 72, 72);  // hit\n        \n        let stats = cache.stats();\n        assert_eq!(stats.hits, 2);\n        assert_eq!(stats.misses, 1);\n        assert_eq!(stats.entries, 1);\n    }\n}\n```\n\n## Success Criteria\n- [ ] Cache directory created at ~/.cache/sd/images/ (or custom path)\n- [ ] get() returns None on miss, Some(data) on hit\n- [ ] put() writes data atomically (via temp file rename)\n- [ ] Different dimensions produce different cache keys\n- [ ] stats() returns accurate entry count, size, hits/misses\n- [ ] clear() removes all .bin files\n\n## Logging Requirements\n- TRACE: Cache directory creation, cache miss, removing individual files\n- DEBUG: Cache hit with size, cached successfully\n- INFO: Cache initialized, cache cleared with count\n- WARN: Cache read error (non-NotFound)\n- ERROR: (none for this module - errors bubble up via Result)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.475179194Z","created_by":"ubuntu","updated_at":"2026-01-19T20:49:51.475743626Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-hgu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.484576697Z","created_by":"ubuntu"}]}
{"id":"bd-i146","title":"Implement robot mode regression tests for JSON output","description":"# Implement robot mode regression tests for JSON output\n\n## Purpose\nCreate comprehensive tests that verify robot mode JSON output is IDENTICAL to the pre-refactor behavior. This is the most critical testing task because AI agents depend on consistent JSON structure.\n\n## Test Strategy\n\n### Approach: Golden File Testing\n1. Capture current (pre-refactor) output for each command\n2. Store as golden files in tests/golden/\n3. After refactor, compare output against golden files\n4. Any difference is a regression\n\n### Alternative: Schema Validation\nFor cases where exact matching isn't possible (timestamps, etc.), use JSON schema validation to ensure structure is correct.\n\n## Test Implementation\n\n### Test Utilities (tests/common/mod.rs)\n```rust\nuse std::io::Write;\nuse std::sync::{Arc, Mutex};\n\n/// Capture stdout for testing\npub struct OutputCapture {\n    buffer: Arc<Mutex<Vec<u8>>>,\n}\n\nimpl OutputCapture {\n    pub fn new() -> Self {\n        Self {\n            buffer: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    \n    pub fn capture<F: FnOnce()>(&self, f: F) -> String {\n        // Redirect stdout to buffer\n        // Execute function\n        // Return captured output\n        todo!(\"implement stdout capture\")\n    }\n}\n\n/// Create mock DeviceInfo for testing\npub fn mock_device_info() -> DeviceInfo {\n    DeviceInfo {\n        serial: \"TEST123\".to_string(),\n        product_name: \"Stream Deck XL\".to_string(),\n        firmware_version: \"1.5.3\".to_string(),\n        key_count: 32,\n        key_width: 96,\n        key_height: 96,\n        rows: 4,\n        cols: 8,\n        kind: \"Xl\".to_string(),\n    }\n}\n```\n\n### Device List Test\n```rust\n#[test]\nfn robot_device_list_json_structure() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let devices = vec![mock_device_info()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    \n    // Parse as JSON to verify structure\n    let parsed: Vec<serde_json::Value> = serde_json::from_str(&captured)\n        .expect(\"should be valid JSON array\");\n    \n    assert_eq!(parsed.len(), 1);\n    \n    let device = &parsed[0];\n    assert_eq!(device[\"serial\"], \"TEST123\");\n    assert_eq!(device[\"product_name\"], \"Stream Deck XL\");\n    assert_eq!(device[\"firmware_version\"], \"1.5.3\");\n    assert_eq!(device[\"key_count\"], 32);\n    assert_eq!(device[\"key_width\"], 96);\n    assert_eq!(device[\"key_height\"], 96);\n    assert_eq!(device[\"rows\"], 4);\n    assert_eq!(device[\"cols\"], 8);\n    assert_eq!(device[\"kind\"], \"Xl\");\n}\n\n#[test]\nfn robot_device_list_compact_json() {\n    let output = RobotOutput::new(RobotFormat::JsonCompact);\n    let devices = vec![mock_device_info()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    \n    // Compact JSON should be single line\n    assert!(!captured.contains('\\n') || captured.trim().lines().count() == 1);\n    \n    // Should still be valid JSON\n    let _: Vec<DeviceInfo> = serde_json::from_str(&captured).unwrap();\n}\n```\n\n### Error Response Test\n```rust\n#[test]\nfn robot_error_json_structure() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let error = SdError::NoDevicesFound;\n    \n    let captured = capture_stdout(|| output.error(&error));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    // Verify required fields\n    assert_eq!(parsed[\"error\"], true);\n    assert!(parsed[\"message\"].is_string());\n    assert!(parsed[\"recoverable\"].is_boolean());\n    \n    // Suggestion should be present for recoverable errors\n    if parsed[\"recoverable\"] == true {\n        assert!(parsed[\"suggestion\"].is_string() || parsed[\"suggestion\"].is_null());\n    }\n}\n\n#[test]\nfn robot_error_multiple_devices() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let error = SdError::MultipleDevices {\n        serials: vec![\"AAA\".to_string(), \"BBB\".to_string()],\n    };\n    \n    let captured = capture_stdout(|| output.error(&error));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"error\"], true);\n    assert!(parsed[\"message\"].as_str().unwrap().contains(\"Multiple\"));\n}\n```\n\n### Button Event Test\n```rust\n#[test]\nfn robot_button_event_single_line() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let event = ButtonEvent {\n        key: 5,\n        pressed: true,\n        timestamp_ms: 1234,\n    };\n    \n    let captured = capture_stdout(|| output.button_event(&event));\n    \n    // Should be single line (for streaming)\n    assert_eq!(captured.trim().lines().count(), 1);\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"key\"], 5);\n    assert_eq!(parsed[\"pressed\"], true);\n    assert_eq!(parsed[\"timestamp_ms\"], 1234);\n}\n```\n\n### Success Confirmation Tests\n```rust\n#[test]\nfn robot_brightness_set_json() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    \n    let captured = capture_stdout(|| output.brightness_set(50));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"brightness\"], 50);\n    assert_eq!(parsed[\"ok\"], true);\n}\n\n#[test]\nfn robot_key_set_json() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let path = Path::new(\"/path/to/icon.png\");\n    \n    let captured = capture_stdout(|| output.key_set(5, path));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"key\"], 5);\n    assert!(parsed[\"image\"].as_str().unwrap().contains(\"icon.png\"));\n    assert_eq!(parsed[\"ok\"], true);\n}\n\n#[test]\nfn robot_all_cleared_json() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    \n    let captured = capture_stdout(|| output.all_cleared());\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"all_cleared\"], true);\n    assert_eq!(parsed[\"ok\"], true);\n}\n```\n\n### No ANSI Codes Test\n```rust\n#[test]\nfn robot_output_no_ansi_codes() {\n    let output = RobotOutput::new(RobotFormat::Json);\n    let devices = vec![mock_device_info()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    \n    // ANSI escape codes start with \\x1b[\n    assert!(!captured.contains('\\x1b'), \"Robot mode output contains ANSI codes\");\n}\n```\n\n## Golden File Workflow\n```bash\n# Generate golden files (before refactor)\nsd list --robot > tests/golden/list.json\nsd info --robot > tests/golden/info.json\n# etc.\n\n# Compare after refactor\ncargo test golden_file_comparison\n```\n\n## Acceptance Criteria\n- [ ] Tests for all Output trait methods in robot mode\n- [ ] JSON structure validated for each command\n- [ ] Compact JSON verified single-line\n- [ ] No ANSI codes in robot output\n- [ ] Error responses include all required fields\n- [ ] Button events are single-line for streaming\n- [ ] All tests pass","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:10:29.943463786Z","created_by":"ubuntu","updated_at":"2026-01-19T21:10:29.995590390Z","compaction_level":0,"original_size":0,"labels":["phase-4","regression","rich-rust","robot-mode","testing"],"dependencies":[{"issue_id":"bd-i146","depends_on_id":"bd-1xd","type":"blocks","created_at":"2026-01-19T21:10:29.995557258Z","created_by":"ubuntu"},{"issue_id":"bd-i146","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:10:29.989736849Z","created_by":"ubuntu"}]}
{"id":"bd-i5h","title":"Implement dry-run for set-keys (batch)","description":"When dry_run=true:\n- Scan directory and show all matches\n- For each key: show source, dimensions, resize needed\n- Show keys that would be skipped (no file)\n- Summary: N keys would be set, M would be skipped","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.755545788Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.765086591Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-i5h","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.764953701Z","created_by":"ubuntu"}]}
{"id":"bd-iuk","title":"Add keymap gesture support","description":"Extend keymap format:\n```yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: open new window\n    hold: push-to-talk script\n```\n\nIntegrate with scripting hooks.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.758897955Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.768966392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-iuk","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.768925646Z","created_by":"ubuntu"}]}
{"id":"bd-kmt","title":"Document testing strategy and guidelines","description":"## Purpose\nProvide clear guidelines for writing tests in this project.\n\n## Document Contents\nCreate `docs/TESTING.md`:\n\n```markdown\n# Testing Guide for sd\n\n## Test Categories\n\n### Unit Tests (src/**/*.rs)\n- Test individual functions in isolation\n- Use MockDevice for device operations\n- Fast, run on every commit\n- Target: 80%+ coverage\n\n### Integration Tests (tests/integration/)\n- Test component interactions\n- Use MockDevice and fixtures\n- Medium speed, run on every commit\n- Focus on data flow between components\n\n### E2E Tests (tests/e2e/)\n- Test CLI behavior end-to-end\n- Use CliRunner helper\n- May be slower, run on PR and main\n- Test user-facing behavior\n\n## Writing Tests\n\n### Naming Convention\n```rust\n#[test]\nfn test_<function>_<scenario>_<expected_outcome>() {\n    // e.g., test_set_brightness_out_of_range_returns_error\n}\n```\n\n### Test Structure (AAA Pattern)\n```rust\n#[test]\nfn test_example() {\n    // Arrange\n    let mut device = MockDevice::new(DeviceModel::XL);\n    \n    // Act\n    let result = device.set_brightness(50);\n    \n    // Assert\n    assert!(result.is_ok());\n    assert_eq!(device.get_brightness(), 50);\n}\n```\n\n### Using Fixtures\n```rust\nuse crate::common::fixtures::fixtures_path;\n\n#[test]\nfn test_with_fixture() {\n    let image_path = fixtures_path(\"images/valid/72x72.png\");\n    // ...\n}\n```\n\n## Running Tests\n\n```bash\n# All tests\ncargo test\n\n# Unit tests only\ncargo test --lib\n\n# Integration tests\ncargo test --test integration\n\n# E2E tests\ncargo test --test e2e\n\n# With logging\nRUST_LOG=debug cargo test -- --nocapture\n\n# Coverage\ncargo tarpaulin\n```\n\n## Mocking Guidelines\n\n### When to use MockDevice\n- Testing command logic\n- Testing error handling\n- Testing state management\n\n### When NOT to mock\n- Testing actual image processing (use real images)\n- Testing file I/O (use fixtures)\n- Testing CLI parsing (use CliRunner)\n```\n\n## Success Criteria\n- [ ] TESTING.md created\n- [ ] All test categories documented\n- [ ] Examples provided for each category\n- [ ] Guidelines for mocking\n- [ ] Instructions for running tests\n- [ ] CI integration documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:53.199538236Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:53.209925994Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-kmt","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:53.209878063Z","created_by":"ubuntu"}]}
{"id":"bd-mwd","title":"Add robot mode rate limit reporting","description":"Report when rate limited:\n```json\n{\n  \"key\": 15,\n  \"rate_limited\": true,\n  \"waited_ms\": 50\n}\n```\n\nUseful for debugging performance issues.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.134002733Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:21.146063381Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-mwd","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.145981728Z","created_by":"ubuntu"}]}
{"id":"bd-oqp","title":"Implement long-press detection","description":"Long press = released after threshold:\n1. Track press start time\n2. On release, check duration\n3. If >= threshold → LongPress\n4. If < threshold → potential Tap\n\nDistinct from Hold (still pressed).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.058745696Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.069535210Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-oqp","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.069490276Z","created_by":"ubuntu"}]}
{"id":"bd-p9h","title":"Implement tap/double-tap detection with deferral","description":"Tap detection requires deferral:\n1. On release, record potential tap time\n2. Start timer for double-tap window\n3. If another press within window → DoubleTap\n4. If window expires → emit deferred Tap\n\nThis prevents emitting Tap before DoubleTap is ruled out.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.663327449Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:00.673778296Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-p9h","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.673732490Z","created_by":"ubuntu"}]}
{"id":"bd-pls","title":"Implement command template substitution","description":"Replace placeholders in command strings:\n- {key} → key index (e.g., \"5\")\n- {pressed} → \"true\" or \"false\"\n- {timestamp} → ISO timestamp\n\nUse simple string replacement, not shell interpolation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.638071617Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.652607365Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-pls","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.652559995Z","created_by":"ubuntu"}]}
{"id":"bd-pnk","title":"Add rich_rust dependency to Cargo.toml","description":"# Add rich_rust dependency to Cargo.toml\n\n## Purpose\nAdd the rich_rust crate as a dependency, which provides all the terminal formatting capabilities needed for beautiful human-mode output.\n\n## Background\nrich_rust is located at /dp/rich_rust and provides:\n- Console: Central coordinator for terminal output\n- Style/Color: Text styling with automatic capability detection\n- Table: Auto-sizing tables with headers and borders\n- Panel: Boxed content with titles\n- ProgressBar: Visual progress indicators\n- Rule: Horizontal dividers\n- Markup parsing: [bold red]text[/] syntax\n\n## Technical Details\n\n### Dependency Specification\n```toml\n[dependencies]\nrich_rust = { path = \"/dp/rich_rust\", features = [\"json\"] }\n```\n\nNote: Using path dependency for local development. When rich_rust is published to crates.io, this should change to:\n```toml\nrich_rust = { version = \"0.1\", features = [\"json\"] }\n```\n\n### Feature Selection\n- json: Enables JSON pretty-printing (useful for displaying device info)\n- NOT including: syntax, markdown (not needed for this CLI)\n\n### What NOT to Remove (Yet)\nKeep the colored crate temporarily during migration. It will be removed in a later task (bd-XXX) after all output has been migrated.\n\n## Implementation Steps\n1. Open Cargo.toml\n2. Add rich_rust dependency in [dependencies] section\n3. Run cargo check to verify resolution\n4. Run cargo build to ensure compilation\n\n## Verification\n```bash\ncargo check --all-targets\ncargo clippy --all-targets -- -D warnings\n```\n\n## Considerations\n- Path dependency works for local dev but needs version for publishing\n- The json feature adds serde_json (already a dependency, so no bloat)\n- rich_rust itself has minimal dependencies (crossterm, unicode-width, etc.)\n\n## Acceptance Criteria\n- [ ] Cargo.toml contains rich_rust dependency\n- [ ] cargo check passes\n- [ ] cargo build succeeds\n- [ ] use rich_rust::prelude::* compiles in any source file","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:30.486547563Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:30.520014755Z","compaction_level":0,"original_size":0,"labels":["cargo","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-pnk","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:02:30.519969480Z","created_by":"ubuntu"}]}
{"id":"bd-qch","title":"Handle edge cases (delete, rename)","description":"Handle file operations:\n- File deleted: warn and continue watching (may reappear)\n- File renamed: re-watch new path?\n- Directory deleted: error and exit\n\nDecide on behavior and document.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:36.265137410Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:36.276036341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qch","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:36.275979654Z","created_by":"ubuntu"}]}
{"id":"bd-qf8","title":"Audit existing src/config/ code and identify gaps","description":"Review existing infrastructure:\n- src/config/loader.rs: ZIP extraction capabilities\n- src/config/db.rs: SQLite schema and operations\n- src/config/types.rs: Profile, Key, Action types\n\nDocument what exists vs what needs implementation.\nThis is RESEARCH - produces a gap analysis document.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:29.966270817Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:29.994810562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qf8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:29.994765116Z","created_by":"ubuntu"}]}
{"id":"bd-qvw","title":"Write tests for gesture edge cases","description":"## Test Coverage for Gesture Detection\n\n### Unit Tests - Tap Detection\n\n1. **Single Tap Tests**\n   - Press + quick release (< 200ms) = tap\n   - Tap fires after release, not on press\n   - Multiple taps on same key distinguished\n   - Tap on different key during wait = two taps\n\n2. **Double-Tap Tests**\n   - Two taps within 300ms = double-tap\n   - Two taps > 300ms apart = two single taps\n   - Triple tap = double-tap + single tap\n   - Double-tap fires only after timeout (no third tap coming)\n   - Exact boundary: 299ms = double, 301ms = two singles\n\n3. **Tap Deferral Tests**\n   - First tap doesn't fire immediately (waiting for double)\n   - If double-tap detected, first tap cancelled\n   - If timeout expires, deferred tap fires\n   - Deferral timeout configurable\n\n### Unit Tests - Long Press Detection\n\n4. **Long Press Threshold Tests**\n   - Hold < 500ms = tap (not long press)\n   - Hold >= 500ms = long press\n   - Exact boundary: 499ms = tap, 500ms = long press\n   - Threshold configurable via --long-press-ms\n\n5. **Hold Duration Tests**\n   - Hold start event at threshold\n   - Hold tick events every 100ms (configurable)\n   - Hold end event on release\n   - Total hold duration reported accurately\n\n6. **Long Press Cancellation**\n   - Moving to different key cancels\n   - (Not applicable for physical buttons)\n\n### Unit Tests - State Machine\n\n7. **State Transitions**\n   - Idle → Pressed on press\n   - Pressed → Held after threshold\n   - Pressed → Released on quick release\n   - Held → Released on release\n   - Released → Idle after timeout\n\n8. **Event Emission Order**\n   - Events in correct order for each gesture\n   - No duplicate events\n   - No missing events\n   - Timestamps accurate\n\n### Integration Tests (require MockDevice)\n\n1. **Simultaneous Keys**\n   - Press key 0, then key 1 while 0 held\n   - Both gestures tracked independently\n   - Release order doesn't matter\n   - No state corruption\n\n2. **Rapid Sequences**\n   - 10 taps in 1 second on same key\n   - All detected correctly\n   - Performance doesn't degrade\n   - No events lost\n\n3. **Gesture + Hook Integration**\n   - Long press triggers hook\n   - Double-tap triggers different hook\n   - Tap triggers tap hook\n   - All hooks fire correctly\n\n4. **Watch Mode Stress Test**\n   - Many rapid gestures\n   - Memory stable\n   - CPU reasonable\n   - All events reported\n\n### E2E Tests (require E2E harness)\n\n1. **CLI Gesture Configuration**\n   ```bash\n   sd watch --long-press-ms 500 --double-tap-ms 300\n   ```\n   - Verify thresholds respected\n   - Verify events in output\n\n2. **Keymap Gesture Hooks**\n   ```yaml\n   keys:\n     0:\n       tap: \"echo tap\"\n       double_tap: \"echo double\"\n       long_press: \"echo long\"\n       hold_tick: \"echo holding\"\n   ```\n   - All gesture types trigger correct hook\n\n3. **Robot Mode Events**\n   ```json\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"tap\"}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"long_press_start\"}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"hold_tick\", \"duration_ms\": 600}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"long_press_end\", \"duration_ms\": 1500}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"double_tap\"}\n   ```\n\n### Edge Case Tests\n\n1. **Boundary Conditions**\n   - Press duration exactly at threshold\n   - Tap interval exactly at double-tap threshold\n   - Zero-duration press (immediate release)\n   - Very long press (> 30 seconds)\n\n2. **Clock Skew**\n   - System time changes during hold\n   - Monotonic clock used (unaffected)\n\n3. **Device Disconnection**\n   - Disconnect during held state\n   - Reconnect clears gesture state\n   - No orphaned events\n\n### Test Fixtures (tests/fixtures/gestures/)\n\n```\ngestures/\n├── gesture-keymap.yaml    # All gesture types mapped\n├── tap-only.yaml          # Only tap hooks\n├── timing-test.yaml       # Tight timing thresholds\n└── stress-test.yaml       # Many keys, many hooks\n```\n\n### Performance Requirements\n- Gesture detection latency < 5ms\n- State machine handles 100 events/second\n- Memory per tracked key < 100 bytes","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:03.175268351Z","created_by":"ubuntu","updated_at":"2026-01-19T20:43:58.136516085Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qvw","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:00.339019776Z","created_by":"ubuntu"},{"issue_id":"bd-qvw","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:03.185587339Z","created_by":"ubuntu"}]}
{"id":"bd-rfp","title":"Add --retry and --retry-delay CLI flags","description":"Add global flags to CLI:\n- --retry N: Retry N times on connection failure\n- --retry-delay MS: Initial delay between retries (default: 1000)\n\nApply to all commands that open a device.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.030520980Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.045733392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-rfp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.045697124Z","created_by":"ubuntu"}]}
{"id":"bd-s04","title":"EPIC: Elgato Profile Import","description":"## Overview\n**Rank: #6 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nComplete the `sd init --import <file.streamDeckProfile>` command to load official Elgato Stream Deck profiles.\n\n## Problem Statement\nUsers with existing Stream Deck setups have invested significant time configuring their devices through the official Elgato software. To migrate to this CLI, they currently must:\n- Manually recreate every key configuration\n- Re-source and re-apply all images\n- Lose any complex configurations (folders, multi-actions)\n\nThis is a huge barrier to adoption. Users wont switch if it means starting from scratch.\n\n## Solution\nImport official Elgato profile files:\n```bash\n# Import an exported profile\nsd init --import ~/Downloads/MySetup.streamDeckProfile\n\n# The profile is a ZIP containing:\n# - manifest.json (profile metadata)\n# - Profiles/<uuid>/profile.json (key configurations)\n# - Images/<uuid>.png (key images)\n\n# After import, users can:\nsd config show        # See imported configuration\nsd apply default      # Apply the imported profile\n```\n\n## Why This Is #6 Priority\n1. **Infrastructure already built**: `src/config/` has ZIP loader, SQLite schema, profile parser!\n2. **Adoption enabler**: Users can migrate without losing their existing setup\n3. **Competitive advantage**: No other open-source tool does this well\n4. **Trust builder**: Shows we respect users existing investment\n\n## Existing Infrastructure in src/config/\n\nThe `src/config/` module already contains substantial infrastructure:\n\n```\nsrc/config/\n├── mod.rs       # Module exports\n├── loader.rs    # ZIP file extraction and parsing\n├── db.rs        # SQLite schema and operations\n└── types.rs     # Profile, Key, Action type definitions\n```\n\nKey existing code:\n- `ProfileLoader::from_zip()` - Opens and validates profile ZIP\n- `ProfileLoader::extract_to()` - Extracts to temp directory\n- `Profile`, `Key`, `Action` structs defined\n- SQLite schema for storing profiles\n\nWhat needs to be done:\n- Wire loader to CLI commands\n- Implement the `init` and `config` commands\n- Handle the mapping from Elgato action types to our commands\n- Store and retrieve images from the extracted profile\n\n## Elgato Profile Format Analysis\n\nThe `.streamDeckProfile` file is a ZIP archive:\n```\nMySetup.streamDeckProfile (ZIP)\n├── manifest.json\n│   {\n│     \"Version\": \"1.0\",\n│     \"DeviceUUID\": \"...\",\n│     \"DeviceModel\": \"StreamDeckXL\"\n│   }\n├── Profiles/\n│   └── <uuid>/\n│       └── profile.json\n│           {\n│             \"Controller\": \"Encoder\",\n│             \"Name\": \"Default Profile\",\n│             \"Keys\": [\n│               {\n│                 \"UUID\": \"...\",\n│                 \"Title\": \"Chrome\",\n│                 \"Image\": \"Images/abc123.png\",\n│                 \"Actions\": [...]\n│               }\n│             ]\n│           }\n└── Images/\n    ├── abc123.png\n    └── def456.png\n```\n\n## Implementation Approach\n\n### Phase 1: Complete the Init Command\n```rust\n// In src/cli/mod.rs\nInit {\n    /// Import from Elgato profile file\n    #[arg(long)]\n    import: Option<PathBuf>,\n    \n    /// Profile name (default: \"default\")\n    #[arg(long, default_value = \"default\")]\n    name: String,\n}\n\n// In main.rs\nfn cmd_init(import: Option<&Path>, name: &str) -> Result<()> {\n    if let Some(profile_path) = import {\n        let loader = ProfileLoader::from_zip(profile_path)?;\n        let profile = loader.parse()?;\n        \n        // Store in config database\n        let config_dir = config_dir()?;\n        let db = ConfigDb::open(&config_dir)?;\n        db.import_profile(name, &profile)?;\n        \n        // Copy images to config storage\n        for key in &profile.keys {\n            if let Some(image_path) = &key.image {\n                copy_image_to_storage(&config_dir, image_path)?;\n            }\n        }\n        \n        println!(\"Imported profile \\\"{}\\\" with {} keys\", name, profile.keys.len());\n    } else {\n        // Interactive setup\n        println!(\"Interactive setup not yet implemented\");\n    }\n    Ok(())\n}\n```\n\n### Phase 2: Config Show/Apply Commands\n```rust\n// Show imported configuration\nfn cmd_config_show(name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        println!(\"Key {}: {} ({})\", key.index, key.title, key.image_source());\n    }\n    Ok(())\n}\n\n// Apply configuration to device\nfn cmd_apply(device: &Device, name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        if let Some(image_path) = key.resolved_image_path() {\n            set_key_image(device, key.index, &image_path)?;\n        }\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Leverage existing code**: Dont rewrite what exists in src/config/\n2. **Named profiles**: Store multiple profiles, apply by name\n3. **Image copying**: Copy images to our storage for portability\n4. **Graceful degradation**: Handle unsupported Elgato features gracefully\n5. **Forward compatibility**: Design for future Elgato format versions\n\n## Elgato Feature Mapping\n| Elgato Feature | Our Support |\n|----------------|-------------|\n| Static images | Full |\n| Solid colors | Full |\n| System actions | Partial (map to shell commands) |\n| Folders | Not yet (track as nested profiles) |\n| Multi-actions | Not yet (future scripting feature) |\n| Animated GIFs | Not yet |\n\n## Success Criteria\n- [ ] `sd init --import <file>` loads Elgato profile\n- [ ] Imported images stored in config directory\n- [ ] `sd config show` displays imported configuration\n- [ ] `sd apply <name>` applies profile to device\n- [ ] Unsupported features logged with warnings\n- [ ] Robot mode returns import summary JSON\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Init, Config, Apply commands\n- `src/main.rs`: Implement command handlers\n- `src/config/loader.rs`: Complete extraction logic\n- `src/config/db.rs`: Complete storage operations\n\n## Dependencies\n- Soft: Benefits from BATCH-OPS for applying multiple keys efficiently\n\n## Estimated Subtasks\n1. Audit existing src/config/ code and identify gaps\n2. Complete ProfileLoader extraction logic\n3. Implement init --import command\n4. Implement config show command\n5. Implement config list command\n6. Implement apply command\n7. Handle image copying and storage\n8. Add support for unsupported feature warnings\n9. Write tests with sample profile files","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:05.904911952Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:05.948021860Z","compaction_level":0,"original_size":0,"labels":["config","interoperability","migration","priority-6"]}
{"id":"bd-txy","title":"Add sha2 dependency to Cargo.toml","description":"Add:\n```toml\n[dependencies]\nsha2 = \"0.10\"\n```\n\nUsed for content-addressable cache keys.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.179210261Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.189556802Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-txy","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.189514442Z","created_by":"ubuntu"}]}
{"id":"bd-uau","title":"Implement config show command","description":"Implement sd config show [name]:\n- Display profile metadata (name, device type, key count)\n- List all key configurations\n- Show image sources and action types\n- Robot mode: Full JSON of profile\n- Human mode: Formatted table","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.642852300Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.652578512Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-uau","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.652525282Z","created_by":"ubuntu"}]}
{"id":"bd-usa2","title":"Implement human mode visual tests","description":"# Implement human mode visual tests\n\n## Purpose\nCreate tests that verify human mode output contains expected visual elements. Since we can't easily test exact visual appearance, we verify that key elements (text, symbols, structure) are present.\n\n## Test Strategy\n\n### Approach: Content Verification\nTest that output contains expected elements:\n- Text content (device names, serials, etc.)\n- Visual symbols (✓, ✗, ●, ○)\n- Panel borders (box-drawing characters)\n- Styled text (via presence of ANSI codes in capture)\n\n### Using rich_rust Capture\nrich_rust Console has built-in capture functionality:\n```rust\nlet console = Console::builder()\n    .force_terminal(true)\n    .width(80)\n    .build();\n\nconsole.begin_capture();\n// ... output operations ...\nlet captured = console.end_capture();\n```\n\n## Test Implementation\n\n### Test Helper\n```rust\nfn test_console() -> Console {\n    Console::builder()\n        .force_terminal(true)  // Force terminal mode for testing\n        .width(80)             // Fixed width for consistent layout\n        .color_system(ColorSystem::TrueColor)  // Full color support\n        .build()\n}\n\nfn output_with_capture<F>(f: F) -> String \nwhere\n    F: FnOnce(&HumanOutput)\n{\n    let console = test_console();\n    console.begin_capture();\n    \n    let output = HumanOutput::new(console.clone());\n    f(&output);\n    \n    console.end_capture()\n}\n```\n\n### Device List Tests\n```rust\n#[test]\nfn human_device_list_shows_panel() {\n    let captured = output_with_capture(|output| {\n        output.device_list(&[mock_device_info()]);\n    });\n    \n    // Should contain panel border characters\n    assert!(captured.contains('╭') || captured.contains('┌'));\n    assert!(captured.contains('╰') || captured.contains('└'));\n    \n    // Should contain title\n    assert!(captured.contains(\"Stream Deck Devices\"));\n    \n    // Should contain device info\n    assert!(captured.contains(\"Stream Deck XL\"));\n    assert!(captured.contains(\"TEST123\"));\n}\n\n#[test]\nfn human_device_list_empty_shows_warning() {\n    let captured = output_with_capture(|output| {\n        output.device_list(&[]);\n    });\n    \n    assert!(captured.contains(\"No devices found\"));\n    assert!(captured.contains(\"Ensure Stream Deck is connected\"));\n}\n```\n\n### Error Output Tests\n```rust\n#[test]\nfn human_error_shows_panel_with_icon() {\n    let captured = output_with_capture(|output| {\n        output.error(&SdError::NoDevicesFound);\n    });\n    \n    // Error icon\n    assert!(captured.contains('✗'));\n    \n    // Panel border\n    assert!(captured.contains('╭') || captured.contains('┌'));\n    \n    // Error title\n    assert!(captured.contains(\"Error\"));\n    \n    // Suggestion section\n    assert!(captured.contains(\"Suggestion\"));\n}\n\n#[test]\nfn human_error_multiple_devices_lists_serials() {\n    let captured = output_with_capture(|output| {\n        output.error(&SdError::MultipleDevices {\n            serials: vec![\"AAA\".into(), \"BBB\".into()],\n        });\n    });\n    \n    assert!(captured.contains(\"AAA\"));\n    assert!(captured.contains(\"BBB\"));\n    assert!(captured.contains(\"Available devices\"));\n}\n```\n\n### Button Event Tests\n```rust\n#[test]\nfn human_button_pressed_shows_filled_circle() {\n    let captured = output_with_capture(|output| {\n        output.button_event(&ButtonEvent {\n            key: 5,\n            pressed: true,\n            timestamp_ms: 1234,\n        });\n    });\n    \n    assert!(captured.contains('●'));\n    assert!(captured.contains(\"pressed\"));\n    assert!(captured.contains(\"Key 5\") || captured.contains(\"Key  5\"));\n}\n\n#[test]\nfn human_button_released_shows_empty_circle() {\n    let captured = output_with_capture(|output| {\n        output.button_event(&ButtonEvent {\n            key: 5,\n            pressed: false,\n            timestamp_ms: 1234,\n        });\n    });\n    \n    assert!(captured.contains('○'));\n    assert!(captured.contains(\"released\"));\n}\n```\n\n### Key Operation Tests\n```rust\n#[test]\nfn human_key_set_shows_checkmark() {\n    let captured = output_with_capture(|output| {\n        output.key_set(5, Path::new(\"/path/to/icon.png\"));\n    });\n    \n    assert!(captured.contains('✓'));\n    assert!(captured.contains(\"Key 5\"));\n    assert!(captured.contains(\"icon.png\"));\n}\n\n#[test]\nfn human_brightness_shows_value() {\n    let captured = output_with_capture(|output| {\n        output.brightness_set(50);\n    });\n    \n    // Should show percentage\n    assert!(captured.contains(\"50%\") || captured.contains(\"50\"));\n    \n    // May contain progress bar characters\n    // (don't require specific format, just verify value shown)\n}\n```\n\n### Version Info Tests\n```rust\n#[test]\nfn human_version_shows_panel() {\n    let captured = output_with_capture(|output| {\n        output.version_info(\"0.1.0\", Some(\"abc123\"), Some(\"2026-01-01\"));\n    });\n    \n    assert!(captured.contains(\"0.1.0\"));\n    assert!(captured.contains(\"abc123\"));\n    assert!(captured.contains(\"2026-01-01\"));\n    \n    // Should be in a panel\n    assert!(captured.contains('╭') || captured.contains('┌'));\n}\n```\n\n### ANSI Code Presence Tests\n```rust\n#[test]\nfn human_output_contains_ansi_codes() {\n    let captured = output_with_capture(|output| {\n        output.success(\"Test message\");\n    });\n    \n    // Human mode should contain ANSI escape codes\n    assert!(captured.contains('\\x1b'), \"Human mode should contain ANSI codes\");\n}\n```\n\n### Rule Tests\n```rust\n#[test]\nfn human_rule_with_title() {\n    let captured = output_with_capture(|output| {\n        output.rule(Some(\"Section Title\"));\n    });\n    \n    assert!(captured.contains(\"Section Title\"));\n    assert!(captured.contains('─') || captured.contains('-'));\n}\n\n#[test]\nfn human_rule_without_title() {\n    let captured = output_with_capture(|output| {\n        output.rule(None);\n    });\n    \n    // Should just be a line\n    assert!(captured.contains('─') || captured.contains('-'));\n}\n```\n\n## Acceptance Criteria\n- [ ] Tests verify key text content present\n- [ ] Tests verify visual symbols (✓, ✗, ●, ○)\n- [ ] Tests verify panel structure (box characters)\n- [ ] Tests verify ANSI codes present in human mode\n- [ ] Empty/error states tested\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:10:59.401997030Z","created_by":"ubuntu","updated_at":"2026-01-19T21:10:59.453345109Z","compaction_level":0,"original_size":0,"labels":["human-mode","phase-4","rich-rust","testing","visual"],"dependencies":[{"issue_id":"bd-usa2","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:10:59.453317987Z","created_by":"ubuntu"},{"issue_id":"bd-usa2","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:10:59.447902151Z","created_by":"ubuntu"}]}
{"id":"bd-vc3","title":"EPIC: Rate Limiting and Burst Protection","description":"## Overview\n**Rank: #13 of 15** | **Impact: Low** | **Effort: Low** | **Confidence: High**\n\nPrevent USB communication floods with configurable rate limiting to protect device stability.\n\n## Problem Statement\nRapid-fire commands from scripts or AI agents can:\n- Overwhelm the USB communication channel\n- Cause device firmware to misbehave\n- Lead to dropped commands or corrupted state\n- Create unpredictable timing issues\n\nWhile the current single-command CLI naturally rate-limits (each command is a separate process), future features like daemon mode, batch operations, or scripted sequences could hit these limits.\n\n## Solution\nConfigurable rate limiting with sensible defaults:\n```bash\n# Explicit rate limiting\nsd set-keys ~/layout/ --rate-limit 50ms\n\n# Global rate limit for all operations\nsd --rate-limit 100ms brightness 50\n\n# Burst mode with queue\nsd batch --queue-size 100 --rate-limit 20ms < commands.txt\n```\n\nInternal rate limiter for programmatic use:\n```rust\nlet limiter = RateLimiter::new(Duration::from_millis(50));\n\nfor key in 0..32 {\n    limiter.wait(); // Blocks until rate limit allows\n    device.set_key_image(key, &images[key])?;\n}\n```\n\n## Why This Is #13 Priority\n1. **Defensive programming**: Prevents edge case failures\n2. **Low effort**: Token bucket is ~50 lines\n3. **Future-proofing**: Needed for daemon/server mode\n4. **Low immediate impact**: Current CLI is naturally limited\n5. **Invisible when working**: Users dont notice rate limiting\n\n## Implementation Approach\n\n### Token Bucket Rate Limiter\n```rust\n// In src/rate_limit.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct RateLimiter {\n    min_interval: Duration,\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    pub fn new(min_interval: Duration) -> Self {\n        Self {\n            min_interval,\n            last_action: None,\n        }\n    }\n    \n    /// Block until rate limit allows next action\n    pub fn wait(&mut self) {\n        if let Some(last) = self.last_action {\n            let elapsed = last.elapsed();\n            if elapsed < self.min_interval {\n                std::thread::sleep(self.min_interval - elapsed);\n            }\n        }\n        self.last_action = Some(Instant::now());\n    }\n    \n    /// Check if action is allowed without blocking\n    pub fn check(&self) -> bool {\n        self.last_action\n            .map(|last| last.elapsed() >= self.min_interval)\n            .unwrap_or(true)\n    }\n    \n    /// Try to acquire permission, return false if rate limited\n    pub fn try_acquire(&mut self) -> bool {\n        if self.check() {\n            self.last_action = Some(Instant::now());\n            true\n        } else {\n            false\n        }\n    }\n}\n\n// Advanced: Token bucket with burst capacity\npub struct TokenBucket {\n    capacity: usize,\n    tokens: f64,\n    refill_rate: f64,  // tokens per second\n    last_refill: Instant,\n}\n\nimpl TokenBucket {\n    pub fn new(capacity: usize, rate_per_second: f64) -> Self {\n        Self {\n            capacity,\n            tokens: capacity as f64,\n            refill_rate: rate_per_second,\n            last_refill: Instant::now(),\n        }\n    }\n    \n    pub fn try_acquire(&mut self, count: usize) -> bool {\n        self.refill();\n        if self.tokens >= count as f64 {\n            self.tokens -= count as f64;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn refill(&mut self) {\n        let now = Instant::now();\n        let elapsed = now.duration_since(self.last_refill).as_secs_f64();\n        self.tokens = (self.tokens + elapsed * self.refill_rate).min(self.capacity as f64);\n        self.last_refill = now;\n    }\n}\n```\n\n### Integration Points\n```rust\n// In device operations\nimpl Device {\n    pub fn set_key_image_rate_limited(\n        &self,\n        key: u8,\n        image: &[u8],\n        limiter: &mut RateLimiter,\n    ) -> Result<()> {\n        limiter.wait();\n        self.set_key_image(key, image)\n    }\n}\n\n// In batch operations\nfn cmd_set_keys(device: &Device, dir: &Path, rate_limit_ms: Option<u64>) -> Result<()> {\n    let mut limiter = rate_limit_ms\n        .map(|ms| RateLimiter::new(Duration::from_millis(ms)));\n    \n    for (key, path) in keys_to_set {\n        if let Some(ref mut l) = limiter {\n            l.wait();\n        }\n        set_key_image(device, key, &path)?;\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Optional by default**: Dont rate limit unless requested or in batch mode\n2. **Simple interval limiter**: Default implementation, easy to understand\n3. **Token bucket for burst**: Advanced option for daemon/server mode\n4. **Per-operation granularity**: Rate limit individual USB operations\n5. **Configurable via CLI**: --rate-limit flag on relevant commands\n\n## Success Criteria\n- [ ] RateLimiter struct implemented with wait/check/try_acquire\n- [ ] TokenBucket implemented for burst scenarios\n- [ ] --rate-limit flag available on batch commands\n- [ ] Batch operations use rate limiting by default\n- [ ] Rate limiting is invisible when not needed\n- [ ] Robot mode reports when rate limited\n\n## Files to Create/Modify\n- `src/rate_limit.rs`: New rate limiting module\n- `src/cli/mod.rs`: Add --rate-limit flag to relevant commands\n- `src/main.rs`: Integrate rate limiter into batch operations\n\n## Dependencies\n- Useful for BATCH-OPS (#1) and future daemon mode\n\n## Estimated Subtasks\n1. Implement simple RateLimiter struct\n2. Implement TokenBucket for burst scenarios\n3. Add --rate-limit CLI flag\n4. Integrate into batch set-keys command\n5. Add robot mode rate limit reporting\n6. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:38.963557809Z","created_by":"ubuntu","updated_at":"2026-01-19T18:21:38.996177816Z","compaction_level":0,"original_size":0,"labels":["defensive","priority-13","reliability","usb"]}
{"id":"bd-vh6","title":"Write integration tests for web API","description":"## Test Coverage for Web API\n\n### Endpoint Tests (Unit/Integration)\n\n1. **Device Info Endpoint (GET /api/device)**\n   - Returns device model (XL, MK2, Mini)\n   - Returns firmware version\n   - Returns serial number\n   - Returns key count and grid dimensions\n   - Returns 200 OK for connected device\n   - Returns 503 Service Unavailable when device disconnected\n   - Robot mode: Returns JSON matching schema\n\n2. **Health Check Endpoint (GET /api/health)**\n   - Returns 200 OK when server running\n   - Includes version in response\n   - Includes device connection status\n   - Response time < 50ms\n\n3. **Brightness Endpoints**\n   - GET /api/brightness returns current level (0-100)\n   - PUT /api/brightness with valid level (50) succeeds\n   - PUT /api/brightness with 0 succeeds (minimum)\n   - PUT /api/brightness with 100 succeeds (maximum)\n   - PUT /api/brightness with -1 returns 400 Bad Request\n   - PUT /api/brightness with 101 returns 400 Bad Request\n   - PUT /api/brightness with non-numeric returns 400\n\n4. **Key Image Endpoints**\n   - PUT /api/keys/:id with valid PNG succeeds\n   - PUT /api/keys/:id with valid JPG succeeds\n   - PUT /api/keys/:id with valid WebP succeeds\n   - PUT /api/keys/:id validates key index range\n   - PUT /api/keys/:id with invalid key returns 400\n   - PUT /api/keys/:id with corrupted image returns 400\n   - Content-Type must be image/* or multipart/form-data\n   - Large images (4K) are auto-resized\n\n5. **Key Color Endpoints**\n   - PUT /api/keys/:id/color with hex (#FF5500) succeeds\n   - PUT /api/keys/:id/color with named color (red) succeeds\n   - PUT /api/keys/:id/color with rgb(255,85,0) succeeds\n   - PUT /api/keys/:id/color with invalid color returns 400\n\n6. **Clear Key Endpoints**\n   - DELETE /api/keys/:id clears specific key\n   - DELETE /api/keys/:id returns 204 No Content\n   - DELETE /api/keys/:id with invalid key returns 400\n\n7. **Keys Listing Endpoint (GET /api/keys)**\n   - Returns array of key states\n   - Each key has index, type (image/color/empty)\n   - Includes last-modified timestamp\n\n### WebSocket Tests (if WebSocket endpoint exists)\n\n8. **WebSocket Connection**\n   - Client can connect to /ws/events\n   - Connection survives across operations\n   - Proper close handshake\n\n9. **Event Streaming**\n   - Key press events delivered\n   - Key release events delivered\n   - Events include key index and timestamp\n   - No events lost during rapid presses\n\n### Error Handling Tests\n\n10. **CORS Headers**\n    - OPTIONS requests return proper CORS headers\n    - Allow-Origin set correctly for local development\n    - Credentials handled appropriately\n\n11. **Error Response Format**\n    - All errors return JSON body\n    - Error includes code, message, suggestion\n    - 400 errors include validation details\n    - 500 errors don't leak internal info\n\n### Performance Tests\n\n12. **Concurrent Requests**\n    - 10 concurrent brightness sets don't corrupt\n    - Image uploads don't block other requests\n    - Server remains responsive under load\n\n13. **Resource Limits**\n    - Max upload size enforced\n    - Request timeout enforced\n    - Connection limits enforced\n\n### Integration with MockDevice\n\n14. **MockDevice Assertions**\n    - Verify set_key_image called with correct data\n    - Verify set_brightness called with correct value\n    - Verify clear_key called for correct key\n    - Track operation order\n\n### Logging Requirements\n- TRACE: Request/response bodies (summarized for large)\n- DEBUG: Request routing, handler entry/exit\n- INFO: Server start/stop, client connections\n- WARN: Invalid requests, rate limiting\n- ERROR: Handler panics, device errors\n\n### Test Data\n- Use test fixtures from bd-2ky\n- Include small, medium, large test images\n- Include valid and intentionally corrupted images","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.964820103Z","created_by":"ubuntu","updated_at":"2026-01-19T21:06:41.513362826Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-vh6","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:08.145081713Z","created_by":"ubuntu"},{"issue_id":"bd-vh6","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.981074787Z","created_by":"ubuntu"},{"issue_id":"bd-vh6","depends_on_id":"bd-bxu","type":"blocks","created_at":"2026-01-19T18:39:04.558546814Z","created_by":"ubuntu"}]}
{"id":"bd-xjo","title":"Implement brightness endpoint","description":"GET /api/brightness → { \"level\": 80 }\nPUT /api/brightness { \"level\": 50 } → { \"success\": true }\n\nThread-safe device access via Mutex.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.725990551Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.742484065Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-xjo","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.742385780Z","created_by":"ubuntu"}]}
{"id":"bd-ylj","title":"EPIC: Connection Health Monitoring with Auto-Reconnect","description":"## Overview\n**Rank: #3 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDetect USB disconnection/reconnection and handle it gracefully. Add `--retry` flag for commands and robust reconnection in `sd watch` for long-running usage.\n\n## Problem Statement\nStream Decks can disconnect unexpectedly due to:\n- USB power issues (especially on hubs)\n- System sleep/wake cycles\n- USB hub resets\n- Physical cable issues\n- Driver glitches\n\nCurrently, the CLI just fails with a USB error. Users must manually re-run commands. This is especially problematic for:\n- `sd watch` which is designed for long-running event streaming\n- AI agents that expect reliable operation without crash-restart loops\n- Automated scripts that run unattended\n\n## Solution\nIntelligent connection management with configurable retry behavior:\n```bash\n# Retry on connection failure\nsd brightness 50 --retry 3 --retry-delay 1000\n\n# Watch mode with auto-reconnect\nsd watch --reconnect --reconnect-delay 2000\n\n# Monitor connection health\nsd monitor --health-check-interval 5000\n```\n\n## Why This Is #3 Priority\n1. **Real pain point**: USB flakiness is common, especially with hubs\n2. **Essential for `sd watch`**: Long-running monitoring needs resilience\n3. **Robot-mode critical**: Agents need robust operation, not crash loops\n4. **Invisible quality**: Users dont notice it working, but definitely notice failures\n\n## Implementation Approach\n\n### Phase 1: Retry Logic for Single Commands\n```rust\n// In src/device.rs\npub struct ConnectionOptions {\n    pub max_retries: u32,\n    pub retry_delay: Duration,\n    pub backoff_factor: f32,  // Exponential backoff\n}\n\nimpl Device {\n    pub fn open_with_retry(\n        serial: Option<&str>, \n        opts: &ConnectionOptions\n    ) -> Result<Self> {\n        let mut delay = opts.retry_delay;\n        \n        for attempt in 1..=opts.max_retries {\n            match Self::open(serial) {\n                Ok(dev) => return Ok(dev),\n                Err(e) if e.is_connection_error() && attempt < opts.max_retries => {\n                    eprintln!(\"Connection failed, retrying in {:?}...\", delay);\n                    std::thread::sleep(delay);\n                    delay = Duration::from_secs_f32(\n                        delay.as_secs_f32() * opts.backoff_factor\n                    );\n                }\n                Err(e) => return Err(e),\n            }\n        }\n        unreachable!()\n    }\n}\n```\n\n### Phase 2: Auto-Reconnect for Watch Mode\n```rust\n// In main.rs, watch command\nfn cmd_watch(opts: WatchOptions) -> Result<()> {\n    let mut device = Device::open_with_retry(opts.serial, &opts.connection)?;\n    \n    loop {\n        match device.read_input(opts.timeout) {\n            Ok(Some(event)) => emit_event(&event, opts.robot),\n            Ok(None) => continue,  // Timeout, no event\n            Err(e) if e.is_connection_error() && opts.reconnect => {\n                emit_disconnected(opts.robot);\n                device = reconnect_with_backoff(&opts)?;\n                emit_reconnected(opts.robot);\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n\nfn reconnect_with_backoff(opts: &WatchOptions) -> Result<Device> {\n    let mut delay = opts.reconnect_delay;\n    loop {\n        std::thread::sleep(delay);\n        match Device::open(opts.serial) {\n            Ok(dev) => return Ok(dev),\n            Err(_) => {\n                delay = std::cmp::min(\n                    delay * 2,\n                    Duration::from_secs(30)  // Max backoff\n                );\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Connection Health Events\n```json\n// Robot mode output for connection events\n{\"event\": \"disconnected\", \"timestamp\": \"...\", \"reason\": \"usb_error\"}\n{\"event\": \"reconnecting\", \"attempt\": 1, \"delay_ms\": 2000}\n{\"event\": \"reconnected\", \"timestamp\": \"...\", \"downtime_ms\": 4500}\n```\n\n## Key Design Decisions\n1. **Exponential backoff**: Prevents USB flood during recovery\n2. **Maximum backoff cap**: 30 seconds max to balance responsiveness\n3. **Explicit opt-in**: `--retry` and `--reconnect` flags, not default behavior\n4. **Event emission**: Connection state changes are reported in robot mode\n5. **Graceful degradation**: Single commands fail fast by default, long-running commands are resilient\n\n## Error Classification\nNeed to distinguish connection errors from other errors:\n```rust\nimpl SdError {\n    pub fn is_connection_error(&self) -> bool {\n        matches!(self, \n            SdError::DeviceNotFound |\n            SdError::UsbError(_) |\n            SdError::DeviceDisconnected\n        )\n    }\n}\n```\n\n## Success Criteria\n- [ ] `--retry N` flag retries failed connections N times\n- [ ] `--retry-delay MS` controls initial retry delay\n- [ ] `sd watch --reconnect` automatically reconnects on disconnect\n- [ ] Connection events emitted in robot mode JSON\n- [ ] Exponential backoff prevents USB flooding\n- [ ] Maximum backoff prevents infinite slow retries\n- [ ] Works correctly across sleep/wake cycles\n\n## Files to Modify\n- `src/cli/mod.rs`: Add retry/reconnect flags to relevant commands\n- `src/device.rs`: Add open_with_retry and connection options\n- `src/error.rs`: Add is_connection_error classification\n- `src/main.rs`: Update command handlers to use retry logic\n\n## Dependencies\nNone - enhances existing functionality\n\n## Estimated Subtasks\n1. Add error classification (is_connection_error)\n2. Implement open_with_retry in device.rs\n3. Add --retry and --retry-delay CLI flags\n4. Update single commands to use retry logic\n5. Implement auto-reconnect for watch command\n6. Add connection event emission for robot mode\n7. Implement exponential backoff with cap\n8. Test across sleep/wake cycles\n9. Write integration tests","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:10:27.991892800Z","created_by":"ubuntu","updated_at":"2026-01-19T18:10:28.031775261Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","priority-3","reliability","usb"]}
{"id":"bd-ym1","title":"Implement diff command","description":"Implement sd diff <config.yaml>:\n- Load current state (from session or device)\n- Load config file\n- Compare and show differences\n- Format: \"Key 0: (empty) → ~/icons/chrome.png\"\n\nNote: Requires state tracking from SAVE-RESTORE epic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:58.847465402Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:58.864068762Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-ym1","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.863954908Z","created_by":"ubuntu"}]}
{"id":"bd-zcq","title":"Add --rate-limit CLI flag","description":"Add to relevant commands:\n- --rate-limit <MS>: Minimum interval between operations\n\nApply to: set-keys (batch), fill-all, future bulk commands.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:19.669438641Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:19.683910799Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zcq","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:19.683856817Z","created_by":"ubuntu"}]}
{"id":"bd-zg7","title":"Add notify dependency for file watching","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nnotify = \"6\"\n```\n\nThis is the standard Rust crate for cross-platform file system notifications.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.503911483Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:33.533933589Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zg7","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.533892311Z","created_by":"ubuntu"}]}
{"id":"bd-znw","title":"Add installation instructions to help text","description":"Update completions command help to include installation instructions:\n- Bash: ~/.local/share/bash-completion/completions/sd\n- Zsh: ~/.zfunc/_sd (ensure fpath includes this)\n- Fish: ~/.config/fish/completions/sd.fish\n- PowerShell: >> $PROFILE","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.289760717Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:00.299742470Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-znw","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.299695742Z","created_by":"ubuntu"}]}
