{"id":"bd-10c","title":"Add --exec, --on-press, --on-release flags to CLI","description":"Add to Watch command in src/cli/mod.rs:\n- --exec <CMD>: Command for any key event ({key} substituted)\n- --on-press <CMD>: Command for press events only\n- --on-release <CMD>: Command for release events only\n- --exec-timeout <MS>: Timeout for command execution (default: 5000)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.286502630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.315959421Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10c","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.315913896Z","created_by":"ubuntu"}]}
{"id":"bd-10v","title":"Add --no-open flag to serve","description":"By default, open browser to http://localhost:PORT\nWith --no-open, just print URL and dont open browser.\n\nUseful for headless/server scenarios.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.079956565Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:51.093955392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10v","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.093899026Z","created_by":"ubuntu"}]}
{"id":"bd-117","title":"Implement diff-based apply","description":"Only apply changes:\n1. Track previous ConfigState\n2. Load new config\n3. Compute diff (changed keys, brightness)\n4. Apply only changed items\n5. Update tracked state\n\nMore efficient than full re-apply.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.675738818Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.688270112Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-117","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.688223104Z","created_by":"ubuntu"}]}
{"id":"bd-11p","title":"Build frontend JavaScript logic","description":"Create static/app.js:\n- Fetch and display device info\n- Handle image drag-and-drop\n- Brightness slider updates\n- WebSocket for live events\n- Color picker integration","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:48.733315351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:48.749847778Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-11p","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:48.749796221Z","created_by":"ubuntu"}]}
{"id":"bd-123","title":"Test with various editors","description":"Manual testing:\n- VSCode (may write temp files)\n- Vim (backup then write)\n- nano (direct write)\n- sed -i (replace)\n\nEnsure debouncing handles each pattern.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.860516467Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.870844322Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-123","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.870801802Z","created_by":"ubuntu"}]}
{"id":"bd-13e","title":"Add font rendering dependencies","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nab_glyph = \"0.2\"      # Modern font rendering\nimageproc = \"0.23\"    # Drawing on images\n```\n\nab_glyph is preferred over rusttype for better performance.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:13.794603556Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:13.823919262Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-13e","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:13.823857295Z","created_by":"ubuntu"}]}
{"id":"bd-156","title":"EPIC: Scripting Hooks on Key Press","description":"## Overview\n**Rank: #8 of 15** | **Impact: High** | **Effort: Low** | **Confidence: Medium-High**\n\nRun shell commands when Stream Deck buttons are pressed, making the device an automation trigger.\n\n## Problem Statement\nCurrently `sd watch` just reports button events to stdout. Users must:\n- Parse the JSON output in another script\n- Build their own event loop\n- Handle the complexity of process management\n\nThis makes the device a passive reporter rather than an active automation tool.\n\n## Solution\nExecute shell commands directly on key press:\n```bash\n# Simple: run a script per key\nsd watch --exec \"~/scripts/key-{key}.sh\"\n\n# Inline command with key substitution\nsd watch --on-press \"notify-send \\\"Key {key} pressed\\\"\"\n\n# Different commands for press vs release\nsd watch \\\n  --on-press \"echo pressed {key}\" \\\n  --on-release \"echo released {key}\"\n\n# With a command map file\nsd watch --keymap ~/keymap.yaml\n```\n\nKeymap file format:\n```yaml\n# ~/keymap.yaml\nkeys:\n  0:\n    press: open -a \"Google Chrome\"\n    release: null  # Optional\n  1:\n    press: osascript -e \"tell application \\\"Spotify\\\" to playpause\"\n  2:\n    press: ~/scripts/toggle-mic.sh\n  \n  # Range with pattern\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\n## Why This Is #8 Priority\n1. **Makes device useful**: Transforms from reporter to automation trigger\n2. **Unix philosophy**: Compose with existing tools, dont reinvent\n3. **Agent-friendly**: AI agents can wire up arbitrary actions\n4. **Low implementation effort**: Fork/exec in watch loop is straightforward\n5. **Immediate value**: Users can automate without writing custom code\n\n## Implementation Approach\n\n### Phase 1: Simple --exec Flag\n```rust\n// In src/cli/mod.rs\nWatch {\n    /// Command to execute on key press ({key} = key index)\n    #[arg(long)]\n    exec: Option<String>,\n    \n    /// Command for press events\n    #[arg(long)]\n    on_press: Option<String>,\n    \n    /// Command for release events  \n    #[arg(long)]\n    on_release: Option<String>,\n    \n    /// Keymap configuration file\n    #[arg(long)]\n    keymap: Option<PathBuf>,\n    \n    /// Timeout for command execution (ms)\n    #[arg(long, default_value = \"5000\")]\n    exec_timeout: u64,\n    \n    // ... existing flags\n}\n\n// In main.rs\nfn cmd_watch(device: &Device, opts: WatchOptions) -> Result<()> {\n    loop {\n        if let Some(event) = device.read_input(opts.timeout)? {\n            // Always emit the event (for robot mode consumers)\n            emit_event(&event, opts.robot);\n            \n            // Execute hooks if configured\n            if let Some(cmd) = resolve_command(&opts, &event) {\n                execute_hook(&cmd, opts.exec_timeout)?;\n            }\n        }\n    }\n}\n\nfn resolve_command(opts: &WatchOptions, event: &KeyEvent) -> Option<String> {\n    // Priority: keymap > on_press/on_release > exec\n    if let Some(keymap) = &opts.keymap {\n        return keymap.get_command(event.key, event.pressed);\n    }\n    \n    let template = match event.pressed {\n        true => opts.on_press.as_ref().or(opts.exec.as_ref()),\n        false => opts.on_release.as_ref(),\n    };\n    \n    template.map(|t| t.replace(\"{key}\", &event.key.to_string()))\n}\n\nfn execute_hook(cmd: &str, timeout_ms: u64) -> Result<()> {\n    use std::process::Command;\n    \n    let child = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .spawn()?;\n    \n    // Non-blocking: dont wait for completion\n    // Or with timeout if configured\n    Ok(())\n}\n```\n\n### Phase 2: Keymap File Support\n```rust\n// In src/config/keymap.rs (new file)\n#[derive(Debug, Deserialize)]\npub struct Keymap {\n    pub keys: HashMap<KeySelector, KeyActions>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct KeyActions {\n    pub press: Option<String>,\n    pub release: Option<String>,\n}\n\nimpl Keymap {\n    pub fn load(path: &Path) -> Result<Self> {\n        let content = std::fs::read_to_string(path)?;\n        Ok(serde_yaml::from_str(&content)?)\n    }\n    \n    pub fn get_command(&self, key: u8, pressed: bool) -> Option<String> {\n        for (selector, actions) in &self.keys {\n            if selector.matches(key) {\n                let template = if pressed { &actions.press } else { &actions.release };\n                return template.as_ref().map(|t| \n                    t.replace(\"{key}\", &key.to_string())\n                );\n            }\n        }\n        None\n    }\n}\n```\n\n## Security Considerations\n1. **No shell injection from device**: Key index is always a number\n2. **User-provided commands only**: We execute what the user configured\n3. **Timeout protection**: Prevent runaway commands\n4. **Non-blocking execution**: Dont block the event loop on slow commands\n5. **Error isolation**: Command failure doesnt crash watch mode\n\n## Key Design Decisions\n1. **Shell execution via sh -c**: Allows pipes, redirects, etc.\n2. **Non-blocking by default**: Fire-and-forget for responsiveness\n3. **{key} substitution**: Simple, predictable placeholder\n4. **Keymap file optional**: Simple use cases dont need files\n5. **Press/release separation**: Different actions for different events\n\n## Robot Mode Integration\n```json\n// Events include hook execution status\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"timestamp\": \"...\",\n  \"hook\": {\n    \"command\": \"~/scripts/key-05.sh\",\n    \"status\": \"started\",\n    \"pid\": 12345\n  }\n}\n\n// Optionally report completion\n{\n  \"event\": \"hook_completed\",\n  \"key\": 5,\n  \"pid\": 12345,\n  \"exit_code\": 0,\n  \"duration_ms\": 150\n}\n```\n\n## Success Criteria\n- [ ] `--exec` flag runs command on any key press\n- [ ] `--on-press` and `--on-release` for event-specific commands\n- [ ] `{key}` placeholder substituted correctly\n- [ ] `--keymap` loads YAML keymap file\n- [ ] Commands execute non-blocking\n- [ ] Timeout prevents runaway commands\n- [ ] Robot mode reports hook execution\n- [ ] Command errors dont crash watch mode\n\n## Files to Create/Modify\n- `src/cli/mod.rs`: Add exec flags to Watch command\n- `src/main.rs`: Implement hook execution in watch loop\n- `src/config/keymap.rs`: New keymap file support\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for keymap schema consistency\n\n## Estimated Subtasks\n1. Add --exec, --on-press, --on-release flags to CLI\n2. Implement command template substitution\n3. Implement non-blocking command execution\n4. Add timeout support for commands\n5. Implement keymap file loading\n6. Integrate hook execution into watch loop\n7. Add robot mode hook status reporting\n8. Handle command errors gracefully\n9. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:18:49.274948425Z","created_by":"ubuntu","updated_at":"2026-01-19T18:18:49.313818630Z","compaction_level":0,"original_size":0,"labels":["automation","priority-8","scripting","watch"]}
{"id":"bd-169","title":"Implement KeyConfig parsing","description":"Implement KeyConfig enum and serde deserialization:\n- Image { image: PathBuf }\n- Pattern { pattern: String }\n- Color { color: ColorSpec }\n- Clear { clear: bool }\n\nHandle untagged enum deserialization properly.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.342822871Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:56.357925747Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-169","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.357886824Z","created_by":"ubuntu"}]}
{"id":"bd-16u","title":"Write tests for export functionality","description":"Test coverage:\n1. Empty session produces minimal script\n2. Various commands tracked correctly\n3. Path quoting handles spaces and special chars\n4. Base64 embedding produces valid script\n5. Generated scripts are syntactically valid","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.979294395Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:04.996200296Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-16u","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.996155501Z","created_by":"ubuntu"}]}
{"id":"bd-17e","title":"Add robot mode hook status reporting","description":"Emit hook execution in robot mode:\n```json\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"hook\": {\"command\": \"...\", \"status\": \"started\", \"pid\": 12345}\n}\n```\n\nOptionally report completion/timeout.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.271293808Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.283235562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-17e","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.283150772Z","created_by":"ubuntu"}]}
{"id":"bd-18h","title":"Integrate rate limiter into batch set-keys","description":"Modify batch operations:\n1. Create RateLimiter if --rate-limit specified\n2. Call limiter.wait() before each device operation\n3. Apply default rate limit for large batches\n\nPrevents USB flooding on rapid operations.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:20.391609830Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:20.408684178Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-18h","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:20.408634585Z","created_by":"ubuntu"}]}
{"id":"bd-1ch","title":"Add error handling and continue-on-error","description":"Implement error handling:\n- When continue_on_error=false: fail fast on first error\n- When continue_on_error=true: collect all errors, report at end\n- Include key index and file path in error messages\n- Track partial success (N of M keys set)","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.535377378Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.551934833Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ch","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.551895849Z","created_by":"ubuntu"}]}
{"id":"bd-1dc","title":"Add state tracking to all mutating commands","description":"Modify each command handler to track state:\n- brightness: track_brightness(level)\n- set-key: track_set_key(key, path)\n- fill-key: track_fill_key(key, color)\n- clear-key: track_clear_key(key)\n- clear-all: track_clear_all(key_count)\n\nCall after successful device operation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.467962903Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.478565857Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1dc","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.478517055Z","created_by":"ubuntu"}]}
{"id":"bd-1eu","title":"Add robot mode cache hit/miss reporting","description":"In robot mode, include cache info:\n```json\n{\n  \"key\": 5,\n  \"cache\": {\"hit\": true, \"path\": \"...\"}\n}\n```\n\nUseful for diagnosing performance.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:40.506479431Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:40.520617811Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1eu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:40.520564341Z","created_by":"ubuntu"}]}
{"id":"bd-1fd","title":"Implement text positioning","description":"Add TextPosition enum:\n- Top: centered at top with padding\n- Center: centered both ways\n- Bottom: centered at bottom with padding\n- Custom { x, y }: explicit coordinates\n\nCalculate position based on text metrics.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.298548355Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.309658684Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1fd","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.309593942Z","created_by":"ubuntu"}]}
{"id":"bd-1g6","title":"Write tests for image caching","description":"Test coverage:\n1. Cache miss processes and stores\n2. Cache hit returns stored data\n3. Different dimensions = different entries\n4. Source file change = new entry\n5. Clear removes all entries\n6. Stats accuracy","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:41.073285158Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:41.087572548Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1g6","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:41.087502506Z","created_by":"ubuntu"}]}
{"id":"bd-1go","title":"Implement simple RateLimiter struct","description":"Create src/rate_limit.rs:\n```rust\npub struct RateLimiter {\n    min_interval: Duration,\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    pub fn new(min_interval: Duration) -> Self;\n    pub fn wait(&mut self);      // Block until allowed\n    pub fn check(&self) -> bool; // Non-blocking check\n    pub fn try_acquire(&mut self) -> bool; // Try without blocking\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.219455612Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:18.249376667Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1go","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.249333887Z","created_by":"ubuntu"}]}
{"id":"bd-1gy","title":"Add PowerShell output format","description":"With --format powershell:\n- Use PowerShell syntax\n- Proper escaping for Windows paths\n- Different comment style","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.318755708Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:04.335099500Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1gy","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.335053844Z","created_by":"ubuntu"}]}
{"id":"bd-1he","title":"Write tests with sample profile files","description":"Create test fixtures:\n1. Minimal valid profile\n2. Profile with various key types\n3. Profile with unsupported features\n4. Corrupted/invalid profiles\n\nTest import, storage, and retrieval.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.811560473Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.820974988Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1he","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.820941004Z","created_by":"ubuntu"}]}
{"id":"bd-1hi","title":"Implement dry-run for brightness command","description":"When dry_run=true:\n- Show current brightness (if readable)\n- Show target brightness\n- Show device info\n- Return without calling device\n\nRobot mode: JSON with action details\nHuman mode: formatted preview text","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.986179469Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:43.996964545Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1hi","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.996911625Z","created_by":"ubuntu"}]}
{"id":"bd-1im","title":"Add cache clear command","description":"Implement sd cache clear:\n- Remove all .bin files from cache directory\n- Report number of entries removed\n- Confirm before clearing (unless --force)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.939628450Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.957039341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1im","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.956989828Z","created_by":"ubuntu"}]}
{"id":"bd-1jf","title":"Obtain and bundle Inter font (OFL licensed)","description":"Add Inter font to binary:\n1. Download Inter-Regular.ttf from Google Fonts\n2. Place in assets/ directory\n3. Embed with include_bytes!()\n\nInter is OFL licensed - free to bundle.\nAlternative: Roboto, Source Sans Pro.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.288939436Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.299350899Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jf","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.299283902Z","created_by":"ubuntu"}]}
{"id":"bd-1jk","title":"Test generated completions for fish","description":"Manual testing (if fish available):\n1. Generate: sd completions fish > /tmp/sd.fish\n2. Source: source /tmp/sd.fish\n3. Test completion\n4. Verify no errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.082684903Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:00.091733189Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jk","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.091697852Z","created_by":"ubuntu"}]}
{"id":"bd-1kd","title":"Implement non-blocking command execution","description":"Execute commands without blocking watch loop:\n```rust\nlet child = Command::new(\"sh\")\n    .arg(\"-c\")\n    .arg(&expanded_cmd)\n    .spawn()?;\n// Fire and forget - dont wait\n```\n\nOptionally track child processes for cleanup.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.147168248Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:19.161559924Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kd","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.161513186Z","created_by":"ubuntu"}]}
{"id":"bd-1kw","title":"Write tests for batch operations","description":"Create comprehensive tests:\n1. Test with full set of images (all keys)\n2. Test with partial set (some keys missing)\n3. Test with invalid images (wrong format, corrupted)\n4. Test continue-on-error behavior\n5. Test pattern matching with various patterns\n6. Mock device for unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:23:43.108243605Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:43.117906188Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kw","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:43.117865321Z","created_by":"ubuntu"}]}
{"id":"bd-1mz","title":"Write tests for text rendering","description":"Test coverage:\n1. Basic text rendering produces valid image\n2. Positioning calculations\n3. Color parsing\n4. Multi-line handling\n5. Custom font loading\n6. Overlay on existing image","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:18.486160476Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:18.495554593Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1mz","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:18.495504950Z","created_by":"ubuntu"}]}
{"id":"bd-1n3","title":"Write tests for rate limiting","description":"Test coverage:\n1. RateLimiter blocks correctly\n2. TokenBucket refills properly\n3. Burst capacity works\n4. Timing accuracy (within tolerance)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.853066162Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:21.870168221Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1n3","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.870109300Z","created_by":"ubuntu"}]}
{"id":"bd-1os","title":"Implement open_with_retry in device.rs","description":"Add ConnectionOptions struct and open_with_retry method:\n- max_retries: u32\n- retry_delay: Duration  \n- backoff_factor: f32 (for exponential backoff)\n\nImplement retry loop with sleep between attempts.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.758006167Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:24.774335762Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1os","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.774281400Z","created_by":"ubuntu"}]}
{"id":"bd-1po","title":"Test on different platforms","description":"Verify text rendering:\n1. Linux (font rendering consistency)\n2. macOS (different gamma/anti-aliasing)\n3. Windows (if applicable)\n\nBundled font should ensure consistent results.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.929869687Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:17.940757286Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1po","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.940706621Z","created_by":"ubuntu"}]}
{"id":"bd-1q4","title":"EPIC: Export to Shell Script","description":"## Overview\n**Rank: #10 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Medium**\n\nGenerate a shell script that recreates the current configuration.\n\n## Problem Statement\nUsers want to:\n- Share their Stream Deck setup with others\n- Back up their configuration in a portable format\n- Reproduce their setup on a new machine\n- Understand exactly what commands created their current state\n\nCurrently theres no way to export the configuration in a reproducible format.\n\n## Solution\nExport command that generates a self-contained shell script:\n```bash\nsd export-script > setup.sh\n# Generates:\n#!/bin/bash\n# Stream Deck configuration exported by sd\n# Device: Stream Deck XL (serial: ABC123)\n# Exported: 2024-01-15T10:30:00Z\n\nset -e\n\nsd brightness 80\nsd set-key 0 /absolute/path/to/chrome.png\nsd set-key 1 /absolute/path/to/slack.png\nsd fill-key 2 \"#FF5500\"\nsd set-key 3 /absolute/path/to/terminal.png\n# ... remaining keys\nsd clear-key 31\n\necho \"Configuration applied successfully\"\n```\n\nAdvanced options:\n```bash\n# Include images as base64 (self-contained)\nsd export-script --embed-images > setup.sh\n\n# Export specific profile\nsd export-script --profile work > work-setup.sh\n\n# Export as different format\nsd export-script --format makefile > Makefile.streamdeck\n```\n\n## Why This Is #10 Priority\n1. **Reproducibility**: Share and restore configurations easily\n2. **Backup strategy**: Simple text file captures everything\n3. **Debugging**: See exactly what commands create the state\n4. **Low effort**: ~60 lines if we track applied state\n5. **Complementary**: Works alongside other features\n\n## Technical Challenge: State Tracking\nLike SAVE-RESTORE, we face the challenge that Stream Deck hardware doesnt allow reading back the current state. Two approaches:\n\n### Approach A: Session History\nTrack commands applied during the current session:\n```rust\nstruct SessionHistory {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyCommand>,\n}\n\nenum KeyCommand {\n    SetImage(PathBuf),\n    FillColor(String),\n    Clear,\n}\n```\n- Pro: Accurate for current session\n- Con: Lost on restart\n\n### Approach B: Config-Based Export\nExport from declarative config or saved snapshot:\n```bash\nsd export-script --profile work  # Export from saved profile\nsd export-script --config work.yaml  # Export from config file\n```\n- Pro: Persistent, accurate\n- Con: Requires config system\n\n### Recommended: Support Both\n1. Session history for `sd export-script` (current session)\n2. Config-based for `sd export-script --profile <name>`\n\n## Implementation Approach\n\n### Phase 1: Session History Tracking\n```rust\n// In src/state.rs (new file, shared with SAVE-RESTORE)\nuse std::sync::Mutex;\nuse once_cell::sync::Lazy;\n\nstatic SESSION_STATE: Lazy<Mutex<SessionState>> = Lazy::new(|| {\n    Mutex::new(SessionState::default())\n});\n\n#[derive(Default)]\npub struct SessionState {\n    pub brightness: Option<u8>,\n    pub keys: HashMap<u8, KeyState>,\n}\n\npub enum KeyState {\n    Image(PathBuf),\n    Color(String),\n    Cleared,\n}\n\nimpl SessionState {\n    pub fn record_brightness(&mut self, level: u8) {\n        self.brightness = Some(level);\n    }\n    \n    pub fn record_set_key(&mut self, key: u8, path: PathBuf) {\n        self.keys.insert(key, KeyState::Image(path));\n    }\n    \n    pub fn record_fill_key(&mut self, key: u8, color: String) {\n        self.keys.insert(key, KeyState::Color(color));\n    }\n    \n    pub fn record_clear_key(&mut self, key: u8) {\n        self.keys.insert(key, KeyState::Cleared);\n    }\n}\n\n// Call from command handlers\npub fn track_brightness(level: u8) {\n    SESSION_STATE.lock().unwrap().record_brightness(level);\n}\n```\n\n### Phase 2: Export Command\n```rust\n// In src/cli/mod.rs\nExportScript {\n    /// Embed images as base64 (makes script self-contained)\n    #[arg(long)]\n    embed_images: bool,\n    \n    /// Export from saved profile instead of session\n    #[arg(long)]\n    profile: Option<String>,\n    \n    /// Output format\n    #[arg(long, default_value = \"bash\")]\n    format: ExportFormat,\n}\n\n#[derive(ValueEnum, Clone)]\nenum ExportFormat {\n    Bash,\n    Fish,\n    PowerShell,\n    Makefile,\n}\n\n// In main.rs\nfn cmd_export_script(opts: ExportOptions) -> Result<()> {\n    let state = if let Some(profile) = &opts.profile {\n        load_profile_state(profile)?\n    } else {\n        SESSION_STATE.lock().unwrap().clone()\n    };\n    \n    let script = generate_script(&state, &opts)?;\n    println!(\"{}\", script);\n    Ok(())\n}\n\nfn generate_script(state: &SessionState, opts: &ExportOptions) -> String {\n    let mut lines = vec![\n        \"#!/bin/bash\".to_string(),\n        format!(\"# Stream Deck configuration exported by sd\"),\n        format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()),\n        \"\".to_string(),\n        \"set -e\".to_string(),\n        \"\".to_string(),\n    ];\n    \n    if let Some(brightness) = state.brightness {\n        lines.push(format!(\"sd brightness {}\", brightness));\n    }\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => {\n                if opts.embed_images {\n                    let b64 = base64_encode_image(path)?;\n                    lines.push(format!(\n                        \"echo \\\"{}\\\" | base64 -d | sd set-key {} -\",\n                        b64, key\n                    ));\n                } else {\n                    lines.push(format!(\"sd set-key {} \\\"{}\\\"\", key, path.display()));\n                }\n            }\n            KeyState::Color(color) => {\n                lines.push(format!(\"sd fill-key {} \\\"{}\\\"\", key, color));\n            }\n            KeyState::Cleared => {\n                lines.push(format!(\"sd clear-key {}\", key));\n            }\n        }\n    }\n    \n    lines.push(\"\".to_string());\n    lines.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    lines.join(\"\\n\")\n}\n```\n\n## Key Design Decisions\n1. **Shell script default**: Most portable, universally understood\n2. **Absolute paths**: Avoid relative path confusion\n3. **Embed option**: Self-contained scripts for sharing\n4. **Multiple formats**: Bash, Fish, PowerShell for cross-platform\n5. **set -e**: Fail fast on errors\n\n## Success Criteria\n- [ ] Session commands are tracked in memory\n- [ ] `sd export-script` generates valid bash script\n- [ ] Generated script reproduces device state when run\n- [ ] `--embed-images` creates self-contained script\n- [ ] `--profile` exports from saved profile\n- [ ] Multiple output formats supported\n- [ ] Robot mode outputs structured JSON instead of script\n\n## Files to Create/Modify\n- `src/state.rs`: New session state tracking (shared with SAVE-RESTORE)\n- `src/cli/mod.rs`: Add ExportScript command\n- `src/main.rs`: Add state tracking calls, implement export\n- All command handlers: Add state tracking calls\n\n## Dependencies\n- Shares state tracking with SAVE-RESTORE epic\n- Benefits from DECLARATIVE-CONFIG for profile-based export\n\n## Estimated Subtasks\n1. Implement SessionState struct\n2. Add state tracking to all mutating commands\n3. Implement basic bash export\n4. Add --embed-images with base64 encoding\n5. Add --profile support (requires saved profiles)\n6. Add Fish output format\n7. Add PowerShell output format\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:57.831756849Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.230684166Z","compaction_level":0,"original_size":0,"labels":["backup","priority-10","reproducibility","sharing"],"dependencies":[{"issue_id":"bd-1q4","depends_on_id":"bd-34i","type":"blocks","created_at":"2026-01-19T18:23:22.230653178Z","created_by":"ubuntu"}]}
{"id":"bd-1q8","title":"Implement batch application loop","description":"Implement the main loop that:\n1. Iterates over matched key-file pairs\n2. Calls existing set_key_image for each\n3. Collects results (success/failure per key)\n4. Respects continue_on_error flag\n\nReuse existing image loading and device communication code.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.335879502Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.356993646Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1q8","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.356950264Z","created_by":"ubuntu"}]}
{"id":"bd-1r4","title":"EPIC: Declarative YAML/TOML Configuration","description":"## Overview\n**Rank: #7 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDefine device state in human-readable configuration files instead of imperative commands.\n\n## Problem Statement\nThe current CLI is imperative: users run commands to change state. This has limitations:\n- No single source of truth for desired configuration\n- Cant version control device setup\n- Cant easily share configurations\n- Cant diff or merge configurations\n- No way to declare \"this is what I want\" and have the tool figure out how to get there\n\n## Solution\nDeclarative configuration files in YAML or TOML:\n```yaml\n# ~/.config/sd/profiles/work.yaml\nname: Work Mode\nbrightness: 80\n\nkeys:\n  # Individual keys\n  0:\n    image: ~/icons/chrome.png\n    label: Browser  # Optional text overlay (future)\n  \n  1:\n    image: ~/icons/slack.png\n  \n  2:\n    color: \"#FF5500\"\n  \n  # Ranges with patterns\n  8-15:\n    pattern: ~/icons/apps/{index}.png\n  \n  # Rows\n  row-3:\n    color: \"#333333\"  # Fill entire row with color\n```\n\nUsage:\n```bash\nsd apply work.yaml           # Apply configuration\nsd apply work                # Apply from ~/.config/sd/profiles/work.yaml\nsd diff work.yaml            # Show what would change\nsd validate work.yaml        # Check configuration is valid\n```\n\n## Why This Is #7 Priority\n1. **Desired-state model**: Declare what you want, not how to get there\n2. **Version controllable**: Check your config into git\n3. **Composable**: Layer configs, override specific keys\n4. **Human-readable**: YAML/TOML are familiar and editable\n5. **Foundation for other features**: Hot-reload, profiles, etc.\n\n## Configuration Schema Design\n\n### YAML Format (Preferred for Readability)\n```yaml\n# Profile metadata\nname: My Profile\ndescription: Optional description\nbrightness: 80\n\n# Key definitions\nkeys:\n  # Explicit key index\n  0:\n    image: /absolute/path/to/image.png\n  \n  # Relative path (resolved from config file location)\n  1:\n    image: ./icons/slack.png\n  \n  # Home directory expansion\n  2:\n    image: ~/stream-deck/chrome.png\n  \n  # Solid color (hex)\n  3:\n    color: \"#FF5500\"\n  \n  # RGB color\n  4:\n    color: [255, 85, 0]\n  \n  # Clear key explicitly\n  5:\n    clear: true\n  \n  # Range with pattern\n  8-15:\n    pattern: ~/icons/row2/{index}.png\n    # Expands to: row2/08.png, row2/09.png, etc.\n  \n  # Named row (device-specific mapping)\n  row-0:\n    color: \"#222222\"  # Fill entire row\n  \n  # All remaining keys\n  default:\n    color: \"#000000\"  # Black background for unspecified keys\n\n# Optional: Device targeting\ndevice:\n  model: StreamDeckXL  # Only apply to this model\n  serial: ABC123       # Only apply to this serial\n```\n\n### TOML Format (Alternative)\n```toml\nname = \"My Profile\"\nbrightness = 80\n\n[keys.0]\nimage = \"~/icons/chrome.png\"\n\n[keys.1]\ncolor = \"#FF5500\"\n\n[keys.\"8-15\"]\npattern = \"~/icons/row2/{index}.png\"\n```\n\n## Implementation Approach\n\n### Phase 1: Schema Definition and Parsing\n```rust\n// In src/config/declarative.rs (new file)\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ProfileConfig {\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub brightness: Option<u8>,\n    pub keys: HashMap<KeySelector, KeyConfig>,\n    pub device: Option<DeviceFilter>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum KeySelector {\n    Single(u8),           // \"0\", \"15\"\n    Range(u8, u8),        // \"8-15\"\n    Row(u8),              // \"row-0\"\n    Default,              // \"default\"\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum KeyConfig {\n    Image { image: PathBuf },\n    Pattern { pattern: String },\n    Color { color: ColorSpec },\n    Clear { clear: bool },\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum ColorSpec {\n    Hex(String),          // \"#FF5500\"\n    Rgb([u8; 3]),         // [255, 85, 0]\n}\n```\n\n### Phase 2: Config Resolution\n```rust\nimpl ProfileConfig {\n    /// Resolve all selectors and patterns to concrete key assignments\n    pub fn resolve(&self, device: &DeviceInfo) -> Result<ResolvedProfile> {\n        let mut keys = HashMap::new();\n        \n        for (selector, config) in &self.keys {\n            let indices = selector.resolve(device)?;\n            for index in indices {\n                let resolved = config.resolve_for_key(index)?;\n                keys.insert(index, resolved);\n            }\n        }\n        \n        Ok(ResolvedProfile {\n            brightness: self.brightness,\n            keys,\n        })\n    }\n}\n```\n\n### Phase 3: Apply Logic\n```rust\nfn cmd_apply(device: &Device, config_path: &Path) -> Result<()> {\n    let config = load_config(config_path)?;\n    let resolved = config.resolve(device.info())?;\n    \n    // Apply brightness if specified\n    if let Some(brightness) = resolved.brightness {\n        device.set_brightness(brightness)?;\n    }\n    \n    // Apply keys\n    for (index, key_config) in &resolved.keys {\n        match key_config {\n            ResolvedKey::Image(path) => set_key_image(device, *index, path)?,\n            ResolvedKey::Color(color) => fill_key_color(device, *index, color)?,\n            ResolvedKey::Clear => clear_key(device, *index)?,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **YAML primary, TOML supported**: YAML is more readable for this use case\n2. **Flexible selectors**: Support individual keys, ranges, rows, and defaults\n3. **Pattern expansion**: `{index}` placeholder for batch definitions\n4. **Path resolution**: Support absolute, relative, and ~ paths\n5. **Device filtering**: Configs can target specific devices\n6. **Additive application**: Only touch keys that are specified\n\n## Diff and Validate Commands\n```bash\nsd diff work.yaml\n# Output:\n# Key 0: (empty) → ~/icons/chrome.png\n# Key 1: ~/icons/old.png → ~/icons/slack.png\n# Key 2: (no change)\n# Brightness: 50 → 80\n\nsd validate work.yaml\n# Output:\n# ✓ Valid YAML syntax\n# ✓ All image paths exist\n# ✓ All color values valid\n# ✓ Key indices within device range\n# ⚠ Key 33 out of range for Stream Deck XL (0-31)\n```\n\n## Success Criteria\n- [ ] YAML configuration files parsed correctly\n- [ ] TOML configuration files parsed correctly\n- [ ] Key selectors (single, range, row) resolve correctly\n- [ ] Pattern expansion works with {index} placeholder\n- [ ] Path expansion (~, relative) works correctly\n- [ ] `sd apply <config>` applies configuration to device\n- [ ] `sd validate <config>` checks configuration validity\n- [ ] `sd diff <config>` shows what would change\n- [ ] Robot mode returns structured JSON\n\n## Files to Create/Modify\n- `src/config/declarative.rs`: New module for declarative config\n- `src/cli/mod.rs`: Add Apply, Validate, Diff commands\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- Soft: ELGATO-IMPORT can generate declarative configs\n- Soft: SAVE-RESTORE can use declarative configs as storage format\n\n## Estimated Subtasks\n1. Design and document config schema\n2. Implement KeySelector parsing and resolution\n3. Implement KeyConfig parsing\n4. Implement path resolution (absolute, relative, ~)\n5. Implement pattern expansion\n6. Implement config loading (YAML + TOML)\n7. Implement apply command\n8. Implement validate command\n9. Implement diff command\n10. Write comprehensive tests","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:43.071432352Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:43.111176112Z","compaction_level":0,"original_size":0,"labels":["config","declarative","priority-7","user-experience"]}
{"id":"bd-1rm","title":"Integrate hook execution into watch loop","description":"Modify watch command handler:\n1. Load keymap if specified\n2. On each event, resolve command\n3. Substitute placeholders\n4. Execute if command found\n5. Continue watching\n\nPriority: keymap > on-press/on-release > exec","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.736317029Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.751530874Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1rm","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.751477624Z","created_by":"ubuntu"}]}
{"id":"bd-1sb","title":"Add multi-line support","description":"Handle newlines in text:\n- Split on \\\\n\n- Calculate line height (font_size * 1.2)\n- Render each line\n- Adjust vertical positioning\n\nExample: sd text-key 0 \"Line 1\\\\nLine 2\"","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.397910630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:17.408254937Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1sb","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.408193742Z","created_by":"ubuntu"}]}
{"id":"bd-1sl","title":"EPIC: Dynamic Text Overlay on Images","description":"## Overview\n**Rank: #15 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nGenerate key images with text labels programmatically, without external image editing.\n\n## Problem Statement\nMost Stream Deck keys need labels. Currently users must:\n- Create images externally with text baked in\n- Use image editing software for simple text\n- Maintain separate image files for each variation\n- Manually update when text needs to change\n\nThis is especially painful for:\n- Dynamic content (build status, counters, time)\n- Localization (different languages)\n- AI agents that can generate text but not images\n\n## Solution\nText rendering commands and options:\n```bash\n# Text-only key (auto-generated background)\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n\n# Text overlay on existing image\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n\n# Multi-line text\nsd text-key 0 \"Line 1\\nLine 2\" --font-size 18\n\n# Dynamic text in declarative config\nkeys:\n  0:\n    image: ~/icons/cpu.png\n    text: \"${CPU_USAGE}%\"\n    text_position: center\n    text_color: white\n```\n\n## Why This Is #15 Priority\n1. **Font complexity**: Text rendering requires font handling\n2. **Platform differences**: Font availability varies by OS\n3. **Scope creep risk**: Leads toward full image editor\n4. **Medium effort**: ~150 lines plus dependencies\n5. **Workaround exists**: External image editing works today\n\n## Implementation Approach\n\n### Font Handling Strategy\nOptions:\n1. **Bundled font**: Include a single font (e.g., Inter, Roboto) in binary\n2. **System fonts**: Use fontconfig to find system fonts\n3. **User-specified**: `--font /path/to/font.ttf`\n\nRecommended: Bundle one good font, allow override.\n\n### Text Rendering with imageproc\n```rust\n// Add to Cargo.toml\n[dependencies]\nimageproc = \"0.23\"\nrusttype = \"0.9\"\n\n// Or use ab_glyph (more modern)\nab_glyph = \"0.2\"\n\n// In src/text.rs (new file)\nuse ab_glyph::{FontRef, PxScale};\nuse image::{Rgba, RgbaImage};\nuse imageproc::drawing::draw_text_mut;\n\npub struct TextOverlay {\n    pub text: String,\n    pub font_size: f32,\n    pub color: Rgba<u8>,\n    pub position: TextPosition,\n    pub font: Option<PathBuf>,\n}\n\npub enum TextPosition {\n    Top,\n    Center,\n    Bottom,\n    Custom { x: i32, y: i32 },\n}\n\n// Bundled font (embedded in binary)\nconst BUNDLED_FONT: &[u8] = include_bytes\\!(\"../assets/Inter-Regular.ttf\");\n\npub fn render_text_key(\n    width: u32,\n    height: u32,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = RgbaImage::from_pixel(width, height, opts.background);\n    \n    let font_data = opts.font\n        .as_ref()\n        .map(|p| std::fs::read(p).unwrap())\n        .unwrap_or_else(|| BUNDLED_FONT.to_vec());\n    \n    let font = FontRef::try_from_slice(&font_data).unwrap();\n    let scale = PxScale::from(opts.font_size);\n    \n    let (text_width, text_height) = measure_text(&font, scale, text);\n    let (x, y) = calculate_position(\n        width, height, \n        text_width, text_height, \n        &opts.position\n    );\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\npub fn overlay_text_on_image(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = base.clone();\n    \n    // Similar to render_text_key but overlays on existing image\n    let font = load_font(&opts.font)?;\n    let scale = PxScale::from(opts.font_size);\n    \n    let (x, y) = calculate_position(\n        img.width(), img.height(),\n        measure_text(&font, scale, text),\n        &opts.position\n    );\n    \n    // Optional: draw background rectangle for readability\n    if opts.text_background {\n        draw_filled_rect_mut(&mut img, text_rect, opts.text_bg_color);\n    }\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\nfn calculate_position(\n    img_w: u32, img_h: u32,\n    text_w: u32, text_h: u32,\n    position: &TextPosition,\n) -> (i32, i32) {\n    match position {\n        TextPosition::Top => ((img_w - text_w) / 2, 2),\n        TextPosition::Center => ((img_w - text_w) / 2, (img_h - text_h) / 2),\n        TextPosition::Bottom => ((img_w - text_w) / 2, img_h - text_h - 2),\n        TextPosition::Custom { x, y } => (*x, *y),\n    }\n}\n```\n\n### CLI Integration\n```rust\n// In src/cli/mod.rs\nTextKey {\n    /// Key index (0-31)\n    key: u8,\n    /// Text to display\n    text: String,\n    /// Font size in pixels\n    #[arg(long, default_value = \"24\")]\n    font_size: f32,\n    /// Text color (hex)\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n    /// Background color (hex)\n    #[arg(long, default_value = \"#333333\")]\n    bg_color: String,\n    /// Text position (top, center, bottom)\n    #[arg(long, default_value = \"center\")]\n    position: TextPosition,\n    /// Custom font file path\n    #[arg(long)]\n    font: Option<PathBuf>,\n}\n\n// Add --text flag to SetKey\nSetKey {\n    key: u8,\n    image: PathBuf,\n    /// Overlay text on image\n    #[arg(long)]\n    text: Option<String>,\n    /// Text position for overlay\n    #[arg(long, default_value = \"bottom\")]\n    text_position: TextPosition,\n    /// Text color for overlay\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n}\n```\n\n## Key Design Decisions\n1. **Bundle one font**: Guaranteed availability, no system dependency\n2. **Allow font override**: Power users can specify custom fonts\n3. **Simple positioning**: Top/center/bottom covers 95% of use cases\n4. **Optional background**: Text background for readability on busy images\n5. **Hex colors**: Consistent with fill-key command\n\n## Multi-Line Text Support\n```rust\nfn render_multiline(text: &str, opts: &TextOverlay) -> RgbaImage {\n    let lines: Vec<&str> = text.split(n).collect();\n    let line_height = opts.font_size * 1.2;  // 120% line height\n    \n    // Calculate total height\n    let total_height = lines.len() as f32 * line_height;\n    \n    // Render each line\n    for (i, line) in lines.iter().enumerate() {\n        let y = start_y + (i as f32 * line_height);\n        draw_text_mut(&mut img, opts.color, x, y as i32, scale, &font, line);\n    }\n}\n```\n\n## Success Criteria\n- [ ] `sd text-key` creates text-only key images\n- [ ] `sd set-key --text` overlays text on images\n- [ ] Bundled font works on all platforms\n- [ ] Custom font via --font flag\n- [ ] Text positioning (top, center, bottom)\n- [ ] Hex color support for text and background\n- [ ] Multi-line text support\n- [ ] Robot mode reports text rendering details\n\n## Files to Create/Modify\n- `Cargo.toml`: Add ab_glyph, imageproc dependencies\n- `assets/Inter-Regular.ttf`: Bundled font file\n- `src/text.rs`: New text rendering module\n- `src/cli/mod.rs`: Add TextKey command, --text flag to SetKey\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- None (standalone feature)\n\n## Estimated Subtasks\n1. Add font rendering dependencies\n2. Obtain and bundle Inter font (OFL licensed)\n3. Implement basic text rendering\n4. Implement text positioning\n5. Implement text overlay on images\n6. Add text-key command\n7. Add --text flag to set-key\n8. Add multi-line support\n9. Test on different platforms\n10. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:55.996344390Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:56.029651662Z","compaction_level":0,"original_size":0,"labels":["generation","images","priority-15","text"]}
{"id":"bd-1ur","title":"Design and document config schema","description":"Create formal schema documentation:\n- YAML structure with all supported fields\n- Key selector syntax (single, range, row, default)\n- Color formats (hex, RGB array)\n- Path resolution rules (absolute, relative, ~)\n- Pattern expansion ({index} placeholder)\n\nThis is a DESIGN task - produces documentation.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.473608969Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:55.487887883Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ur","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.487834763Z","created_by":"ubuntu"}]}
{"id":"bd-1uz","title":"Add global --dry-run flag to CLI","description":"In src/cli/mod.rs, add to Cli struct:\n```rust\n/// Preview what would happen without making changes\n#[arg(long, global = true)]\npub dry_run: bool,\n```\n\nEnsure flag is accessible in all command handlers.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.771173494Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:43.800811557Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1uz","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.800752005Z","created_by":"ubuntu"}]}
{"id":"bd-1v8","title":"EPIC: Gesture Support (Long-Press, Double-Tap)","description":"## Overview\n**Rank: #12 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nDetect and report gesture events beyond simple press/release: long-press, double-tap, and hold.\n\n## Problem Statement\nStream Deck has 32 keys (on XL model). Currently each key can only do one thing: trigger on press. Users want more actions without more keys:\n- Tap for quick action, long-press for settings\n- Double-tap for alternate action\n- Hold for continuous/repeated action\n\n## Solution\nEnhanced event detection in watch mode:\n```bash\nsd watch --gestures\n\n# Output includes gesture classification:\n{\"key\": 5, \"gesture\": \"tap\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"long_press\", \"duration_ms\": 1200}\n{\"key\": 5, \"gesture\": \"double_tap\", \"interval_ms\": 150}\n{\"key\": 5, \"gesture\": \"hold_start\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"hold_tick\", \"held_ms\": 500}\n{\"key\": 5, \"gesture\": \"hold_end\", \"total_ms\": 2500}\n```\n\nConfigurable thresholds:\n```bash\nsd watch --gestures \\\n  --long-press-ms 800 \\\n  --double-tap-ms 300 \\\n  --hold-tick-ms 100\n```\n\nIntegration with scripting hooks:\n```bash\nsd watch --gestures --keymap gestures.yaml\n```\n\n```yaml\n# gestures.yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: osascript -e \"tell Chrome to make new window\"\n  1:\n    tap: ~/scripts/toggle-mic.sh\n    hold: ~/scripts/push-to-talk.sh  # Runs while held\n```\n\n## Why This Is #12 Priority\n1. **Expressiveness**: 32 keys become 96+ possible actions\n2. **Standard UX pattern**: Users expect gesture support\n3. **Differentiator**: Most Stream Deck tools lack this\n4. **Moderate complexity**: State machine logic is fiddly\n5. **Subjective tuning**: \"Long press\" timing is personal preference\n\n## Implementation Approach\n\n### Gesture State Machine\n```rust\n// In src/gestures.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct GestureConfig {\n    pub long_press_threshold: Duration,   // Default: 800ms\n    pub double_tap_window: Duration,      // Default: 300ms\n    pub hold_tick_interval: Duration,     // Default: 100ms\n}\n\npub struct GestureDetector {\n    config: GestureConfig,\n    key_states: HashMap<u8, KeyGestureState>,\n}\n\nstruct KeyGestureState {\n    press_time: Option<Instant>,\n    last_tap_time: Option<Instant>,\n    is_held: bool,\n    last_tick: Option<Instant>,\n}\n\npub enum Gesture {\n    Tap { key: u8 },\n    DoubleTap { key: u8, interval: Duration },\n    LongPress { key: u8, duration: Duration },\n    HoldStart { key: u8 },\n    HoldTick { key: u8, held_for: Duration },\n    HoldEnd { key: u8, total: Duration },\n}\n\nimpl GestureDetector {\n    pub fn process_event(&mut self, event: &RawKeyEvent) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        let state = self.key_states.entry(event.key).or_default();\n        \n        match event.pressed {\n            true => {\n                // Key pressed\n                state.press_time = Some(Instant::now());\n                state.is_held = false;\n            }\n            false => {\n                // Key released\n                if let Some(press_time) = state.press_time.take() {\n                    let duration = press_time.elapsed();\n                    \n                    if duration >= self.config.long_press_threshold {\n                        // Long press\n                        gestures.push(Gesture::LongPress { \n                            key: event.key, \n                            duration \n                        });\n                    } else if state.is_held {\n                        // End of hold\n                        gestures.push(Gesture::HoldEnd {\n                            key: event.key,\n                            total: duration,\n                        });\n                    } else {\n                        // Potential tap or double-tap\n                        if let Some(last_tap) = state.last_tap_time {\n                            if last_tap.elapsed() < self.config.double_tap_window {\n                                gestures.push(Gesture::DoubleTap {\n                                    key: event.key,\n                                    interval: last_tap.elapsed(),\n                                });\n                                state.last_tap_time = None;\n                            } else {\n                                gestures.push(Gesture::Tap { key: event.key });\n                                state.last_tap_time = Some(Instant::now());\n                            }\n                        } else {\n                            state.last_tap_time = Some(Instant::now());\n                            // Defer tap emission until we know it is not double-tap\n                        }\n                    }\n                }\n                state.is_held = false;\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Call periodically to emit hold ticks and detect long-press during hold\n    pub fn tick(&mut self) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        \n        for (key, state) in &mut self.key_states {\n            if let Some(press_time) = state.press_time {\n                let held_for = press_time.elapsed();\n                \n                // Detect transition to hold\n                if !state.is_held && held_for >= self.config.long_press_threshold {\n                    state.is_held = true;\n                    gestures.push(Gesture::HoldStart { key: *key });\n                }\n                \n                // Emit hold ticks\n                if state.is_held {\n                    if state.last_tick.map(|t| t.elapsed() >= self.config.hold_tick_interval).unwrap_or(true) {\n                        gestures.push(Gesture::HoldTick { key: *key, held_for });\n                        state.last_tick = Some(Instant::now());\n                    }\n                }\n            }\n            \n            // Emit deferred taps (after double-tap window expires)\n            if let Some(last_tap) = state.last_tap_time {\n                if last_tap.elapsed() >= self.config.double_tap_window && state.press_time.is_none() {\n                    gestures.push(Gesture::Tap { key: *key });\n                    state.last_tap_time = None;\n                }\n            }\n        }\n        \n        gestures\n    }\n}\n```\n\n### Integration with Watch Loop\n```rust\nfn cmd_watch_with_gestures(device: &Device, opts: WatchOptions) -> Result<()> {\n    let mut detector = GestureDetector::new(GestureConfig {\n        long_press_threshold: Duration::from_millis(opts.long_press_ms),\n        double_tap_window: Duration::from_millis(opts.double_tap_ms),\n        hold_tick_interval: Duration::from_millis(opts.hold_tick_ms),\n    });\n    \n    loop {\n        // Check for raw events (short timeout)\n        if let Some(event) = device.read_input(Duration::from_millis(50))? {\n            let gestures = detector.process_event(&event);\n            for g in gestures {\n                emit_gesture(&g, opts.robot);\n            }\n        }\n        \n        // Process ticks for held keys and deferred events\n        let tick_gestures = detector.tick();\n        for g in tick_gestures {\n            emit_gesture(&g, opts.robot);\n        }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Deferred tap emission**: Wait for double-tap window before emitting tap\n2. **Hold distinct from long-press**: Long-press = released after threshold, Hold = still pressed\n3. **Configurable thresholds**: Personal preference varies widely\n4. **Tick-based detection**: Periodic polling for held key events\n5. **Backward compatible**: Without --gestures, behavior unchanged\n\n## Success Criteria\n- [ ] `--gestures` flag enables gesture detection\n- [ ] Tap events emitted after double-tap window\n- [ ] Double-tap detected within configurable window\n- [ ] Long-press detected on release after threshold\n- [ ] Hold events with periodic ticks while pressed\n- [ ] Threshold flags allow customization\n- [ ] Robot mode outputs structured gesture events\n- [ ] Keymap supports gesture-specific actions\n\n## Files to Create/Modify\n- `src/gestures.rs`: New gesture detection module\n- `src/cli/mod.rs`: Add gesture flags to Watch command\n- `src/main.rs`: Integrate gesture detector\n- `src/config/keymap.rs`: Add gesture-specific actions\n\n## Dependencies\n- Soft: Benefits from SCRIPTING-HOOKS (#8) for gesture-specific actions\n\n## Estimated Subtasks\n1. Design gesture state machine\n2. Implement GestureDetector struct\n3. Implement tap/double-tap detection with deferral\n4. Implement long-press detection\n5. Implement hold start/tick/end\n6. Add CLI flags for thresholds\n7. Integrate with watch loop\n8. Add keymap gesture support\n9. Write tests for edge cases","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:11.972191367Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.327002495Z","compaction_level":0,"original_size":0,"labels":["expressiveness","input","priority-12","watch"],"dependencies":[{"issue_id":"bd-1v8","depends_on_id":"bd-156","type":"blocks","created_at":"2026-01-19T18:23:22.326971206Z","created_by":"ubuntu"}]}
{"id":"bd-1xp","title":"Add connection event emission for robot mode","description":"Emit JSON events for connection state changes:\n```json\n{\"event\": \"disconnected\", \"timestamp\": \"...\", \"reason\": \"usb_error\"}\n{\"event\": \"reconnecting\", \"attempt\": 1, \"delay_ms\": 2000}\n{\"event\": \"reconnected\", \"timestamp\": \"...\", \"downtime_ms\": 4500}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:25.780621064Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.792861450Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.792821745Z","created_by":"ubuntu"}]}
{"id":"bd-1xs","title":"Add --text flag to set-key","description":"Extend set-key command:\n```\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n```\n\nOverlays text on the provided image.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.841788169Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.852442359Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xs","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.852367277Z","created_by":"ubuntu"}]}
{"id":"bd-1zf","title":"EPIC: Hot-Reload Configuration Files","description":"## Overview\n**Rank: #11 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium-High**\n\nMonitor configuration files and automatically apply changes when files are modified.\n\n## Problem Statement\nWhen designing a Stream Deck layout, users must:\n1. Edit configuration file\n2. Save file\n3. Run `sd apply config.yaml`\n4. See result on device\n5. Repeat\n\nThis edit-save-run-check cycle is slow and breaks flow. Users want to see changes instantly.\n\n## Solution\nWatch mode for configuration files:\n```bash\n# Watch a single config file\nsd watch-config ~/.config/sd/current.yaml\n\n# Watch with debounce (avoid rapid re-applies)\nsd watch-config work.yaml --debounce 500\n\n# Watch entire config directory\nsd watch-config ~/.config/sd/profiles/ --active work.yaml\n```\n\nWhen the file changes:\n```\n[2024-01-15 10:30:15] Detected change in work.yaml\n[2024-01-15 10:30:15] Applying configuration...\n[2024-01-15 10:30:15] ✓ Applied 5 key changes, brightness unchanged\n```\n\n## Why This Is #11 Priority\n1. **Developer experience**: Real-time feedback during design\n2. **Natural extension**: Builds on DECLARATIVE-CONFIG (#7)\n3. **Live editing workflow**: Edit in VSCode, see on device instantly\n4. **Moderate effort**: File watching is well-supported in Rust\n5. **Dependent feature**: Requires declarative config to be useful\n\n## Implementation Approach\n\n### Phase 1: File Watcher Setup\n```rust\n// Add to Cargo.toml\n[dependencies]\nnotify = \"6\"\n\n// In src/watch_config.rs (new file)\nuse notify::{Watcher, RecursiveMode, watcher};\nuse std::sync::mpsc::channel;\nuse std::time::Duration;\n\npub fn watch_config(\n    device: &Device,\n    config_path: &Path,\n    debounce_ms: u64,\n) -> Result<()> {\n    let (tx, rx) = channel();\n    \n    let mut watcher = notify::recommended_watcher(move |res| {\n        if let Ok(event) = res {\n            let _ = tx.send(event);\n        }\n    })?;\n    \n    watcher.watch(config_path, RecursiveMode::NonRecursive)?;\n    \n    println!(\"Watching {} for changes...\", config_path.display());\n    println!(\"Press Ctrl+C to stop\");\n    \n    // Apply initial configuration\n    apply_config(device, config_path)?;\n    \n    let mut last_apply = std::time::Instant::now();\n    \n    loop {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(event) => {\n                // Debounce: ignore events too close together\n                if last_apply.elapsed() < Duration::from_millis(debounce_ms) {\n                    continue;\n                }\n                \n                if is_modify_event(&event) {\n                    println!(\"[{}] Detected change\", timestamp());\n                    match apply_config(device, config_path) {\n                        Ok(changes) => {\n                            println!(\"[{}] ✓ Applied {} changes\", timestamp(), changes);\n                        }\n                        Err(e) => {\n                            eprintln!(\"[{}] ✗ Error: {}\", timestamp(), e);\n                        }\n                    }\n                    last_apply = std::time::Instant::now();\n                }\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => continue,\n            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => break,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n### Phase 2: Intelligent Diff-Apply\nInstead of re-applying everything, track what changed:\n```rust\npub struct ConfigState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyConfig>,\n}\n\nimpl ConfigState {\n    pub fn diff(&self, new: &ConfigState) -> ConfigDiff {\n        let mut changes = Vec::new();\n        \n        if self.brightness != new.brightness {\n            changes.push(Change::Brightness(new.brightness));\n        }\n        \n        for (key, new_config) in &new.keys {\n            match self.keys.get(key) {\n                Some(old_config) if old_config != new_config => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                None => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                _ => {}\n            }\n        }\n        \n        ConfigDiff { changes }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Debouncing**: Prevent rapid re-applies during multi-file saves\n2. **Error resilience**: Invalid config shows error, keeps watching\n3. **Diff-based apply**: Only change what actually changed\n4. **Initial apply**: Apply config once when watch starts\n5. **Graceful shutdown**: Ctrl+C stops cleanly\n\n## Robot Mode Output\n```json\n{\"event\": \"watching\", \"path\": \"/home/user/.config/sd/work.yaml\"}\n{\"event\": \"change_detected\", \"timestamp\": \"...\"}\n{\"event\": \"applying\", \"changes\": 5}\n{\"event\": \"applied\", \"success\": true, \"changes\": 5, \"duration_ms\": 150}\n{\"event\": \"error\", \"message\": \"Invalid YAML on line 15\"}\n```\n\n## Success Criteria\n- [ ] `sd watch-config <file>` monitors for changes\n- [ ] Changes auto-applied within debounce window\n- [ ] Syntax errors reported without crashing\n- [ ] Diff-based apply only changes modified keys\n- [ ] Debounce prevents rapid re-applies\n- [ ] Robot mode outputs structured events\n- [ ] Ctrl+C stops cleanly\n\n## Files to Create/Modify\n- `Cargo.toml`: Add notify dependency\n- `src/watch_config.rs`: New file watcher module\n- `src/cli/mod.rs`: Add WatchConfig command\n- `src/main.rs`: Implement command handler\n\n## Dependencies\n- **Hard dependency on DECLARATIVE-CONFIG (#7)**: Requires config files to watch\n\n## Estimated Subtasks\n1. Add notify dependency\n2. Implement basic file watcher\n3. Add debouncing logic\n4. Implement diff-based apply\n5. Add error handling for invalid configs\n6. Add robot mode output\n7. Test with various editors (VSCode, vim, etc.)\n8. Handle edge cases (file deletion, rename)","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:20:34.580206020Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.116619464Z","compaction_level":0,"original_size":0,"labels":["config","developer-experience","priority-11","watch"],"dependencies":[{"issue_id":"bd-1zf","depends_on_id":"bd-1r4","type":"blocks","created_at":"2026-01-19T18:23:22.116589698Z","created_by":"ubuntu"}]}
{"id":"bd-20s","title":"Handle command errors gracefully","description":"Command failures should not crash watch:\n- Log error to stderr\n- Report in robot mode\n- Continue watching\n- Track failure counts for diagnostics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.803142096Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.816837942Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-20s","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.816778210Z","created_by":"ubuntu"}]}
{"id":"bd-21c","title":"Add clap_complete to Cargo.toml","description":"Add dependency:\n```toml\n[dependencies]\nclap_complete = \"4\"\n```\n\nThis is the standard completion generation crate for clap.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.238271755Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.266803876Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21c","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.266752779Z","created_by":"ubuntu"}]}
{"id":"bd-227","title":"Handle image copying and storage","description":"When importing profiles:\n1. Extract images from ZIP to temp\n2. Copy to ~/.local/share/sd/images/\n3. Use content-addressable naming (SHA256)\n4. Update database with new paths\n5. Handle duplicates (same image, different keys)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.340162210Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.349396096Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-227","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.349355890Z","created_by":"ubuntu"}]}
{"id":"bd-22s","title":"Implement dry-run for clear-key/clear-all","description":"When dry_run=true:\n- clear-key: Show which key would be cleared\n- clear-all: Show total key count that would be cleared\n- Include device info in output","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.569143769Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.578920226Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-22s","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.578880340Z","created_by":"ubuntu"}]}
{"id":"bd-24m","title":"Implement basic text rendering","description":"Create src/text.rs:\n```rust\npub fn render_text_image(\n    width: u32, height: u32,\n    text: &str,\n    font_size: f32,\n    text_color: Rgba<u8>,\n    bg_color: Rgba<u8>,\n) -> RgbaImage\n```\n\nUses ab_glyph for text rasterization.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.796958819Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.808425628Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-24m","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.808361998Z","created_by":"ubuntu"}]}
{"id":"bd-254","title":"Write tests for scripting hooks","description":"Test coverage:\n1. Template substitution\n2. Non-blocking execution\n3. Timeout behavior\n4. Keymap loading\n5. Error handling\n6. Command priority resolution","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:22.353005212Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:22.367746497Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-254","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:22.367692125Z","created_by":"ubuntu"}]}
{"id":"bd-26w","title":"Implement color fill endpoint","description":"PUT /api/keys/:id/color { \"color\": \"#FF5500\" }\n- Parse color\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:45.404624395Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:45.421082954Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26w","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:45.421027660Z","created_by":"ubuntu"}]}
{"id":"bd-26y","title":"Add robot mode output for watch-config","description":"Emit JSON events:\n```json\n{\"event\": \"watching\", \"path\": \"...\"}\n{\"event\": \"change_detected\", \"timestamp\": \"...\"}\n{\"event\": \"applying\", \"changes\": 5}\n{\"event\": \"applied\", \"success\": true, \"changes\": 5}\n{\"event\": \"error\", \"message\": \"...\"}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.466745652Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.477125535Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26y","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.477087133Z","created_by":"ubuntu"}]}
{"id":"bd-271","title":"EPIC: Web Dashboard (Complete serve Command)","description":"## Overview\n**Rank: #14 of 15** | **Impact: High** | **Effort: High** | **Confidence: Medium**\n\nVisual browser-based interface for configuring Stream Deck, completing the stubbed `sd serve` command.\n\n## Problem Statement\nNot everyone wants a CLI. Visual editing is more intuitive for:\n- Designing key layouts\n- Previewing images before applying\n- Drag-and-drop configuration\n- Non-technical users\n- Quick experimentation\n\nThe official Elgato software provides this, but is closed-source and limited to official features.\n\n## Solution\nLocal web server with visual editor:\n```bash\nsd serve --port 8420\n# Opens http://localhost:8420\n\n# With specific device\nsd serve --serial ABC123 --port 8420\n\n# Headless mode (no browser auto-open)\nsd serve --no-open --port 8420\n```\n\nWeb interface features:\n- Visual grid of keys matching device layout\n- Drag-and-drop images onto keys\n- Color picker for fill colors\n- Brightness slider\n- Live preview (changes apply immediately)\n- Configuration save/load\n- Device status display\n\n## Why This Is #14 Priority\n1. **High effort**: Full web frontend + API = significant work\n2. **Competes with Elgato**: Official software already does this\n3. **Different audience**: CLI users may not want web UI\n4. **Already stubbed**: The serve command exists in code\n5. **Nice to have**: Not essential for CLI-first users\n\n## Architecture\n```\nBrowser (React/Preact/Vanilla JS)\n    ↓ HTTP/WebSocket\nsd serve (axum)\n    ↓ \nDevice Module\n    ↓\nStream Deck Hardware\n```\n\n## Implementation Approach\n\n### Phase 1: REST API\n```rust\n// In src/server/mod.rs (new)\nuse axum::{Router, Json, extract::State};\n\npub fn create_router(device: Arc<Mutex<Device>>) -> Router {\n    Router::new()\n        .route(\"/api/device\", get(get_device_info))\n        .route(\"/api/brightness\", get(get_brightness).put(set_brightness))\n        .route(\"/api/keys\", get(get_keys))\n        .route(\"/api/keys/:id\", put(set_key).delete(clear_key))\n        .route(\"/api/keys/:id/image\", post(upload_image))\n        .route(\"/api/keys/:id/color\", put(set_color))\n        .route(\"/api/config\", get(get_config).post(save_config))\n        .nest_service(\"/\", ServeDir::new(\"static\"))\n        .with_state(AppState { device })\n}\n\n// API handlers\nasync fn get_device_info(State(state): State<AppState>) -> Json<DeviceInfo> {\n    let device = state.device.lock().unwrap();\n    Json(device.info().clone())\n}\n\nasync fn set_brightness(\n    State(state): State<AppState>,\n    Json(req): Json<BrightnessRequest>,\n) -> Result<Json<()>, ApiError> {\n    let device = state.device.lock().unwrap();\n    device.set_brightness(req.level)?;\n    Ok(Json(()))\n}\n\nasync fn set_key(\n    State(state): State<AppState>,\n    Path(key): Path<u8>,\n    mut multipart: Multipart,\n) -> Result<Json<()>, ApiError> {\n    // Handle image upload\n    while let Some(field) = multipart.next_field().await? {\n        if field.name() == Some(\"image\") {\n            let data = field.bytes().await?;\n            let device = state.device.lock().unwrap();\n            set_key_from_bytes(&device, key, &data)?;\n        }\n    }\n    Ok(Json(()))\n}\n```\n\n### Phase 2: WebSocket for Live Updates\n```rust\n// Real-time key press events\nasync fn ws_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<AppState>,\n) -> impl IntoResponse {\n    ws.on_upgrade(|socket| handle_websocket(socket, state))\n}\n\nasync fn handle_websocket(mut socket: WebSocket, state: AppState) {\n    // Send key events as they happen\n    loop {\n        if let Some(event) = state.event_rx.recv().await {\n            let msg = serde_json::to_string(&event).unwrap();\n            if socket.send(Message::Text(msg)).await.is_err() {\n                break;\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Frontend (Embedded Static Files)\n```rust\n// Embed static files in binary\nuse rust_embed::RustEmbed;\n\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n\n// Or serve from filesystem in dev mode\n#[cfg(debug_assertions)]\nfn static_handler() -> ServeDir {\n    ServeDir::new(\"static\")\n}\n\n#[cfg(not(debug_assertions))]\nfn static_handler() -> EmbeddedAssets {\n    EmbeddedAssets::new()\n}\n```\n\nFrontend stack options (keep simple):\n- **Vanilla JS + HTML**: Zero build step, ~2KB\n- **Preact**: Small React-like library, ~4KB\n- **Alpine.js**: Declarative, ~15KB\n\nRecommended: Vanilla JS with modern features for simplicity.\n\n## API Specification\n```yaml\n# OpenAPI-style specification\npaths:\n  /api/device:\n    get:\n      summary: Get device information\n      response: { model, serial, key_count, key_size, firmware }\n  \n  /api/brightness:\n    get:\n      summary: Get current brightness\n      response: { level: 0-100 }\n    put:\n      summary: Set brightness\n      body: { level: 0-100 }\n  \n  /api/keys:\n    get:\n      summary: Get all key states (if tracked)\n      response: [{ index, source, type }]\n  \n  /api/keys/{id}:\n    put:\n      summary: Set key image (multipart form)\n    delete:\n      summary: Clear key\n  \n  /api/keys/{id}/color:\n    put:\n      summary: Fill key with color\n      body: { color: \"#RRGGBB\" }\n  \n  /api/config:\n    get:\n      summary: Export current config as YAML\n    post:\n      summary: Import and apply config\n```\n\n## Key Design Decisions\n1. **Local only**: No authentication needed (localhost)\n2. **Single device**: Serve manages one device at a time\n3. **Embedded assets**: Single binary deployment\n4. **REST + WebSocket**: REST for actions, WS for events\n5. **Minimal frontend**: Avoid heavy frameworks\n\n## Success Criteria\n- [ ] `sd serve` starts web server on configurable port\n- [ ] Device info displayed in browser\n- [ ] Brightness slider works\n- [ ] Can set key images via drag-and-drop\n- [ ] Can fill keys with colors via picker\n- [ ] Can clear keys\n- [ ] Live key press events via WebSocket\n- [ ] Configuration export/import\n\n## Files to Create/Modify\n- `src/server/mod.rs`: New web server module\n- `src/server/api.rs`: REST API handlers\n- `src/server/ws.rs`: WebSocket handler\n- `static/index.html`: Frontend HTML\n- `static/app.js`: Frontend JavaScript\n- `static/style.css`: Frontend styles\n- `Cargo.toml`: Add axum, tower, rust-embed dependencies\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for import/export\n\n## Estimated Subtasks\n1. Set up axum server skeleton\n2. Implement device info endpoint\n3. Implement brightness endpoint\n4. Implement key image upload endpoint\n5. Implement color fill endpoint\n6. Implement clear key endpoint\n7. Add WebSocket for key events\n8. Build frontend HTML structure\n9. Build frontend JavaScript logic\n10. Add configuration export/import\n11. Embed static files in binary\n12. Add --no-open flag\n13. Write integration tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:15.417798563Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:15.457603949Z","compaction_level":0,"original_size":0,"labels":["priority-14","serve","visual","web"]}
{"id":"bd-28r","title":"Add WebSocket for key events","description":"WS /api/events:\n- Stream key press/release events\n- Allow real-time UI updates\n- Handle multiple clients","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.083855094Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:47.101776507Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-28r","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.101714961Z","created_by":"ubuntu"}]}
{"id":"bd-298","title":"Implement clear key endpoint","description":"DELETE /api/keys/:id\n- Clear specified key\n- Return success","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:46.247930850Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:46.263618777Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-298","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:46.263574033Z","created_by":"ubuntu"}]}
{"id":"bd-2a1","title":"Update single commands to use retry logic","description":"Modify command dispatch in main.rs:\n1. Parse retry options from CLI\n2. Use open_with_retry instead of Device::open\n3. Ensure all device-using commands benefit","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.244590391Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.256786624Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2a1","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.256753532Z","created_by":"ubuntu"}]}
{"id":"bd-2ag","title":"Implement TokenBucket for burst scenarios","description":"Advanced rate limiter with burst capacity:\n```rust\npub struct TokenBucket {\n    capacity: usize,\n    tokens: f64,\n    refill_rate: f64,\n    last_refill: Instant,\n}\n```\n\nAllows bursts up to capacity, then rate-limits.\nUseful for future daemon mode.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.947415931Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:18.965877150Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ag","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.965819181Z","created_by":"ubuntu"}]}
{"id":"bd-2gt","title":"Add cache stats command","description":"Implement sd cache stats:\n- Location: ~/.cache/sd/images/\n- Entry count\n- Total size (bytes, formatted)\n- Optional: hit rate if tracked\n\nRobot mode: JSON object with stats","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.398978560Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.408353431Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2gt","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.408310671Z","created_by":"ubuntu"}]}
{"id":"bd-2js","title":"Implement GestureDetector struct","description":"Create src/gestures.rs:\n- GestureConfig with timing thresholds\n- GestureDetector with per-key state\n- KeyGestureState tracking press time, last tap, etc.\n- Gesture enum with all gesture types","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.259522713Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:00.270775930Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2js","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.270731547Z","created_by":"ubuntu"}]}
{"id":"bd-2ks","title":"Implement SessionState struct (shared with snapshots)","description":"Create src/state.rs (if not already from SAVE-RESTORE):\n- SessionState struct with brightness, keys HashMap\n- KeyState enum: Image(PathBuf), Color(String), Cleared\n- Thread-safe global accessor\n- Record methods for each mutation type\n\nNOTE: This is SHARED with SAVE-RESTORE epic. Coordinate implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.088169255Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.119119759Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ks","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.119070255Z","created_by":"ubuntu"}]}
{"id":"bd-2kw","title":"Add support for unsupported feature warnings","description":"Elgato profiles may contain unsupported features:\n- Folders (nested profiles)\n- Multi-actions (sequences)\n- System actions (specific to Elgato software)\n- Animated GIFs\n\nLog warnings for unsupported features, continue with supported parts.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.573276189Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.582720831Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2kw","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.582677830Z","created_by":"ubuntu"}]}
{"id":"bd-2oj","title":"Add text-key command","description":"Implement sd text-key:\n```\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n```\n\nGenerates image from text and applies to key.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.314684264Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.326125375Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2oj","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.326055764Z","created_by":"ubuntu"}]}
{"id":"bd-2qo","title":"Design snapshot storage schema","description":"Design the storage schema for snapshots:\n1. SQLite table structure for snapshot metadata\n2. File storage layout for cached images\n3. Relationship between snapshot records and image files\n4. Consider: ~/.local/share/sd/snapshots/{name}/ structure\n\nKey decisions:\n- Store source paths AND cached images for resilience\n- Include device info in snapshot for compatibility checking\n- Timestamp for audit trail","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:04.945524164Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:04.973821573Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qo","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:04.973777821Z","created_by":"ubuntu"}]}
{"id":"bd-2re","title":"Write tests for snapshot system","description":"Test coverage:\n1. Save and restore round-trip\n2. Snapshot listing\n3. Graceful handling of missing images\n4. Device compatibility checking\n5. Concurrent access (if applicable)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:05.979311207Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.988296685Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2re","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.988259595Z","created_by":"ubuntu"}]}
{"id":"bd-2sd","title":"Integrate gesture detector with watch loop","description":"Modify watch loop:\n1. If --gestures, use GestureDetector\n2. Pass raw events through detector\n3. Emit gesture events instead of raw events\n4. Call tick() periodically for held keys and deferred taps","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.324903187Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.334627155Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sd","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.334583503Z","created_by":"ubuntu"}]}
{"id":"bd-2sp","title":"Add timeout support for commands","description":"If --exec-timeout specified:\n1. Spawn command\n2. Wait with timeout\n3. Kill if exceeds timeout\n4. Report timeout in robot mode\n\nUse std::process::Child with wait_timeout or similar.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.671716912Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:19.687064749Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sp","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.687008323Z","created_by":"ubuntu"}]}
{"id":"bd-2t5","title":"Add configuration export/import","description":"GET /api/config → YAML configuration\nPOST /api/config with YAML → apply configuration\n\nIntegrates with declarative config system.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:49.338508012Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:49.356031806Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2t5","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:49.355979357Z","created_by":"ubuntu"}]}
{"id":"bd-2ui","title":"Implement basic file watcher","description":"Create src/watch_config.rs:\n1. Set up notify watcher for config file\n2. Channel for receiving events\n3. Loop receiving events and triggering reloads\n4. Initial apply on start\n\nHandle: permission errors, non-existent files.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.905192428Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:33.915531764Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ui","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.915490016Z","created_by":"ubuntu"}]}
{"id":"bd-2vg","title":"Implement config loading (YAML + TOML)","description":"Load config from file:\n1. Detect format from extension (.yaml, .yml, .toml)\n2. Parse with appropriate library\n3. Validate structure\n4. Return ProfileConfig struct\n\nAdd serde_yaml and toml dependencies if not present.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.427405742Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:57.441551135Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2vg","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.441503776Z","created_by":"ubuntu"}]}
{"id":"bd-2xx","title":"Build frontend HTML structure","description":"Create static/index.html:\n- Device info display\n- Grid of keys matching device layout\n- Brightness slider\n- Drag-and-drop zones for images\n- Color picker\n\nKeep minimal - vanilla JS preferred.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.901045537Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:47.916799168Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2xx","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.916732602Z","created_by":"ubuntu"}]}
{"id":"bd-2yg","title":"Add snapshot show/delete commands","description":"Implement:\n- sd snapshot show <name>: Display snapshot contents (keys, brightness)\n- sd snapshot delete <name>: Remove snapshot with confirmation\n\nNote: deletion should be explicit, not part of normal workflow","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.566787383Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.576297149Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yg","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.576243097Z","created_by":"ubuntu"}]}
{"id":"bd-305","title":"Add SetKeys command struct to CLI","description":"Add the SetKeys command variant to src/cli/mod.rs with:\n- dir: PathBuf for directory path\n- pattern: String with default \"key-{index}.png\"\n- continue_on_error: bool flag\n\nThis is the CLI interface definition, not implementation.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:41.964096116Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:41.982501680Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-305","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:41.982464199Z","created_by":"ubuntu"}]}
{"id":"bd-319","title":"Add --profile support for saved profiles","description":"With --profile <name>:\n- Load profile from snapshot/config storage\n- Generate script from stored state instead of session\n- Allows exporting saved configurations\n\nRequires: SAVE-RESTORE or DECLARATIVE-CONFIG to be implemented.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:02.945280338Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:02.961325127Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-319","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.961283929Z","created_by":"ubuntu"}]}
{"id":"bd-326","title":"Implement auto-reconnect for watch command","description":"Enhance sd watch with --reconnect flag:\n1. Detect connection errors in read loop\n2. Emit disconnected event (robot mode)\n3. Enter reconnection loop with backoff\n4. Re-open device and resume watching\n5. Emit reconnected event\n\nMaximum backoff: 30 seconds to stay responsive.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.492377938Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.507513124Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-326","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.507471676Z","created_by":"ubuntu"}]}
{"id":"bd-33c","title":"Integrate cache into set_key_image","description":"Modify image setting flow:\n1. Check cache for pre-processed image\n2. If hit: use cached data directly\n3. If miss: load, resize, encode, cache, then send\n4. Report cache hit/miss for metrics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.075313942Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.084764195Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-33c","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.084713159Z","created_by":"ubuntu"}]}
{"id":"bd-34h","title":"Test across sleep/wake cycles","description":"Manual testing checklist:\n1. Start sd watch --reconnect\n2. Put machine to sleep\n3. Wake machine\n4. Verify automatic reconnection\n5. Test on Linux and macOS if possible","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:26.463127532Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:26.478002950Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-34h","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.477954358Z","created_by":"ubuntu"}]}
{"id":"bd-34i","title":"EPIC: Device State Snapshots (Save/Restore)","description":"## Overview\n**Rank: #2 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nAdd `sd save <name>` and `sd restore <name>` commands to capture and restore complete device state (key images + brightness).\n\n## Problem Statement\nUsers typically want to switch between different configurations:\n- \"Work mode\" with productivity app shortcuts\n- \"Gaming mode\" with game-specific macros\n- \"Streaming mode\" with OBS controls\n- \"Music mode\" with DAW controls\n\nCurrently, switching requires re-running 30+ commands or maintaining external scripts. There is no way to capture the current state and restore it later.\n\n## Solution\nNamed snapshots that capture the entire device state:\n```bash\nsd save work-mode      # Capture current state\nsd save gaming-mode    # Capture another state\nsd restore work-mode   # Switch back instantly\nsd snapshots           # List available snapshots\nsd snapshot delete gaming-mode  # Remove a snapshot\n```\n\n## Why This Is #2 Priority\n1. **Workflow enabler**: Makes the CLI usable for real multi-context workflows\n2. **Builds on config infrastructure**: The `src/config/` module already has SQLite and image storage\n3. **Complements batch ops**: Import images → set-keys → save = powerful workflow\n4. **Reversibility**: Currently the CLI is one-way; this adds the ability to go back\n\n## Technical Challenge: Reading Device State\n**Critical consideration**: Stream Deck hardware does NOT allow reading back key images. We can only:\n- Read current brightness level\n- Read button press events\n\nThis means we have two implementation approaches:\n\n### Approach A: Command History Tracking (Simpler)\nTrack what commands were applied during the session:\n```rust\nstruct SessionState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyState>,  // What we set, not what device has\n}\n\nenum KeyState {\n    Image(PathBuf),    // Source image path\n    Color(String),     // Hex color\n    Cleared,\n}\n```\n- Pro: Simple, works with any command sequence\n- Con: Only tracks current session; loses state on restart\n\n### Approach B: Config-First Workflow (More Robust)\nRequire users to work through config files:\n```bash\nsd apply work.yaml    # Apply a config\nsd save work-mode     # Save the config reference, not device state\nsd restore work-mode  # Re-apply the config\n```\n- Pro: Persistent, declarative, version-controllable\n- Con: Requires config system (#7) first\n\n### Recommended: Hybrid Approach\n1. Track command history during session (immediate value)\n2. When saving, store both the history AND resolved image data\n3. Restore by replaying the history or applying stored images\n\n## Implementation Approach\n```rust\n// In src/config/snapshots.rs (new file)\npub struct Snapshot {\n    pub name: String,\n    pub created_at: DateTime<Utc>,\n    pub brightness: u8,\n    pub keys: Vec<KeySnapshot>,\n}\n\npub struct KeySnapshot {\n    pub index: u8,\n    pub source: KeySource,\n    pub image_data: Option<Vec<u8>>,  // Cached resized image\n}\n\npub enum KeySource {\n    ImageFile(PathBuf),\n    Color(String),\n    Cleared,\n}\n\n// Storage in ~/.local/share/sd/snapshots/\n// - snapshots.db (SQLite index)\n// - images/<sha256>.bin (cached resized images)\n```\n\n## Key Design Decisions\n1. **Name-based access**: Human-readable names, not UUIDs\n2. **Store source AND cached**: Keep original paths for portability, cache for speed\n3. **Graceful degradation**: If source image moved, use cached version\n4. **Atomic restore**: All-or-nothing application\n5. **Conflict handling**: Prompt before overwriting existing snapshot name\n\n## Success Criteria\n- [ ] `sd save <name>` captures current tracked state\n- [ ] `sd restore <name>` applies a saved snapshot\n- [ ] `sd snapshots` lists all saved snapshots with metadata\n- [ ] `sd snapshot show <name>` displays snapshot contents\n- [ ] `sd snapshot delete <name>` removes a snapshot\n- [ ] Robot mode returns structured JSON for all operations\n- [ ] Graceful handling when source images are missing\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Save, Restore, Snapshots commands\n- `src/main.rs`: Add command handlers\n- `src/config/snapshots.rs`: New snapshot storage module\n- `src/state.rs`: Session state tracking (new)\n\n## Dependencies\n- Soft dependency on BATCH-OPS: batch operations make saving more useful\n- Soft dependency on DECLARATIVE-CONFIG: config-first workflow is cleaner\n\n## Estimated Subtasks\n1. Design snapshot storage schema\n2. Implement session state tracking\n3. Add save command with state serialization\n4. Add restore command with state application\n5. Add snapshots list command\n6. Add snapshot show/delete commands\n7. Implement image caching for snapshots\n8. Handle missing source images gracefully\n9. Add robot mode output\n10. Write tests","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:59.040775758Z","created_by":"ubuntu","updated_at":"2026-01-19T18:09:59.079746712Z","compaction_level":0,"original_size":0,"labels":["cli","config","priority-2","workflow"]}
{"id":"bd-35a","title":"EPIC: Dry-Run Mode for All Mutating Commands","description":"## Overview\n**Rank: #4 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Very High**\n\nAdd `--dry-run` global flag that shows what would happen without making changes to the device.\n\n## Problem Statement\nUsers experimenting with the CLI (especially AI agents) have no way to preview what a command will do before it executes. This leads to:\n- Trial-and-error workflows on physical hardware\n- Difficulty debugging \"why isnt my image showing?\"\n- Agents making changes without understanding consequences\n- No way to validate commands in CI/CD pipelines without a device\n\n## Solution\nA global `--dry-run` flag that validates and previews all operations:\n```bash\nsd set-key 5 ~/icon.png --dry-run\n# Output:\n# DRY RUN: Would set key 5\n#   Source: /home/user/icon.png (256x256 PNG)\n#   Resize: 72x72 using Lanczos3\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd brightness 80 --dry-run\n# Output:\n# DRY RUN: Would set brightness to 80%\n#   Current: 50% (if readable)\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd set-keys ~/layout/ --dry-run\n# Output:\n# DRY RUN: Would set 24 keys from /home/user/layout/\n#   Key 0: key-00.png (128x128 JPG) → resize to 72x72\n#   Key 1: key-01.png (72x72 PNG) → no resize needed\n#   Key 2: (no file found, would skip)\n#   ...\n```\n\n## Why This Is #4 Priority\n1. **Safety net**: Preview before committing to physical device\n2. **Debugging aid**: See exact image processing that will occur\n3. **Agent-friendly**: Validate operations without side effects\n4. **Low effort**: Simple flag, ~50 lines of code per command\n5. **Universal pattern**: Users immediately understand what --dry-run means\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - global flag\n#[derive(Parser)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Command,\n    \n    /// Preview what would happen without making changes\n    #[arg(long, global = true)]\n    pub dry_run: bool,\n    \n    // ... existing flags\n}\n\n// In main.rs - pass through to handlers\nfn cmd_brightness(device: &Device, level: u8, dry_run: bool, robot: bool) -> Result<()> {\n    if dry_run {\n        let info = DryRunInfo {\n            action: \"set_brightness\",\n            details: BrightnessDetails { level },\n            device: device.info(),\n        };\n        if robot {\n            println\\!(\"{}\", serde_json::to_string(&info)?);\n        } else {\n            println\\!(\"DRY RUN: Would set brightness to {level}%\");\n            println\\!(\"  Device: {} (serial: {})\", \n                device.info().model, \n                device.info().serial);\n        }\n        return Ok(());\n    }\n    device.set_brightness(level)\n}\n\nfn cmd_set_key(\n    device: &Device, \n    key: u8, \n    path: &Path, \n    dry_run: bool,\n    robot: bool\n) -> Result<()> {\n    // Always validate the image (even in dry-run)\n    let img = image::open(path)?;\n    let (w, h) = img.dimensions();\n    let key_size = device.info().key_size();\n    \n    if dry_run {\n        let needs_resize = w \\!= key_size.0 || h \\!= key_size.1;\n        let info = DryRunInfo {\n            action: \"set_key\",\n            details: SetKeyDetails {\n                key,\n                source_path: path.to_path_buf(),\n                source_dimensions: (w, h),\n                target_dimensions: key_size,\n                needs_resize,\n            },\n            device: device.info(),\n        };\n        // Output appropriately\n        return Ok(());\n    }\n    \n    // Actually do it\n    set_key_image(device, key, path)\n}\n```\n\n## Key Design Decisions\n1. **Global flag**: Applies to all mutating commands uniformly\n2. **Full validation**: Dry-run still validates inputs (image exists, parseable, etc.)\n3. **Structured output**: Robot mode gets JSON with full details\n4. **Human-friendly output**: Clear formatting for terminal users\n5. **Early exit**: Dry-run returns after preview, never touches device\n\n## What Dry-Run Shows\nFor each command type:\n- **brightness**: Target level, device info\n- **set-key**: Source path, dimensions, resize behavior, target key\n- **fill-key**: Key index, color value\n- **clear-key/clear-all**: Which keys would be cleared\n- **set-keys**: Full manifest of directory contents and what would happen\n\n## Robot Mode Output Structure\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key\",\n  \"would_succeed\": true,\n  \"details\": {\n    \"key\": 5,\n    \"source\": \"/path/to/image.png\",\n    \"source_dimensions\": [256, 256],\n    \"target_dimensions\": [72, 72],\n    \"resize_required\": true,\n    \"resize_filter\": \"lanczos3\"\n  },\n  \"device\": {\n    \"model\": \"Stream Deck XL\",\n    \"serial\": \"ABC123\",\n    \"key_count\": 32\n  }\n}\n```\n\n## Success Criteria\n- [ ] `--dry-run` flag available on all mutating commands\n- [ ] Dry-run validates inputs without touching device\n- [ ] Human-readable output explains what would happen\n- [ ] Robot mode returns structured JSON with full details\n- [ ] Errors during validation are reported normally\n- [ ] Works even when no device is connected (with limitations)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add global --dry-run flag\n- `src/main.rs`: Add dry_run parameter to all mutating command handlers\n\n## Dependencies\nNone - standalone feature\n\n## Estimated Subtasks\n1. Add global --dry-run flag to CLI\n2. Implement dry-run for brightness command\n3. Implement dry-run for set-key command\n4. Implement dry-run for fill-key command\n5. Implement dry-run for clear-key/clear-all commands\n6. Implement dry-run for set-keys (batch) command\n7. Design and implement robot mode JSON structure\n8. Write tests for dry-run behavior","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:10:57.838742147Z","created_by":"ubuntu","updated_at":"2026-01-19T18:10:57.877812438Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-4","safety"]}
{"id":"bd-35j","title":"Implement robot mode JSON output for batch","description":"Design and implement JSON output structure:\n```json\n{\n  \"command\": \"set_keys\",\n  \"directory\": \"/path/to/dir\",\n  \"results\": [\n    {\"key\": 0, \"file\": \"key-00.png\", \"success\": true},\n    {\"key\": 1, \"file\": \"key-01.png\", \"success\": false, \"error\": \"...\"}\n  ],\n  \"summary\": {\"total\": 32, \"success\": 30, \"failed\": 2}\n}\n```","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.744961886Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.761789870Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-35j","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.761750275Z","created_by":"ubuntu"}]}
{"id":"bd-37o","title":"Add snapshots list command","description":"Implement sd snapshots (list all):\n- Name, creation date, device model, key count\n- Robot mode: JSON array of snapshot objects\n- Human mode: formatted table","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.435833342Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.445532464Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37o","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.445494482Z","created_by":"ubuntu"}]}
{"id":"bd-37v","title":"Add error classification (is_connection_error)","description":"Add to src/error.rs:\n```rust\nimpl SdError {\n    pub fn is_connection_error(&self) -> bool {\n        matches\\!(self, \n            SdError::DeviceNotFound |\n            SdError::UsbError(_) |\n            SdError::DeviceDisconnected\n        )\n    }\n}\n```\n\nEnsure all USB-related errors are properly classified.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.493253348Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:24.509384690Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37v","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.509339205Z","created_by":"ubuntu"}]}
{"id":"bd-38o","title":"Test generated completions for zsh","description":"Manual testing (macOS/Linux with zsh):\n1. Generate: sd completions zsh > /tmp/_sd\n2. Add to fpath and compinit\n3. Test completion behavior\n4. Verify no errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.874093064Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.884083364Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38o","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.884045513Z","created_by":"ubuntu"}]}
{"id":"bd-38x","title":"Add restore command with state application","description":"Implement sd restore <name>:\n1. Load snapshot metadata\n2. Check device compatibility (key count)\n3. Apply brightness if stored\n4. Apply each key image/color/clear\n5. Report progress and any failures\n\nHandle: missing snapshot, incompatible device, missing images","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.312916003Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.322709141Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38x","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.322663555Z","created_by":"ubuntu"}]}
{"id":"bd-3a2","title":"Implement keymap file loading","description":"Support --keymap <file.yaml>:\n```yaml\nkeys:\n  0:\n    press: open -a Chrome\n    release: null\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\nReuse KeySelector from declarative config.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.205128062Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.223338890Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3a2","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.223284417Z","created_by":"ubuntu"}]}
{"id":"bd-3ab","title":"Add debouncing logic","description":"Prevent rapid re-applies:\n- Track last apply timestamp\n- Ignore events within debounce window (default 500ms)\n- Configurable via --debounce flag\n\nSome editors save multiple times (backup, then real).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.290122116Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.300511167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ab","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.300472524Z","created_by":"ubuntu"}]}
{"id":"bd-3aj","title":"Implement basic bash export","description":"Generate bash script from session state:\n```bash\n#!/bin/bash\n# Stream Deck configuration exported by sd\nset -e\nsd brightness 80\nsd set-key 0 \"/path/to/image.png\"\n...\necho \"Configuration applied successfully\"\n```\n\nUse absolute paths, proper quoting.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.820883805Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.830812850Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3aj","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.830765861Z","created_by":"ubuntu"}]}
{"id":"bd-3av","title":"Embed static files in binary","description":"Use rust-embed crate:\n```rust\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n```\n\nSingle binary deployment with embedded frontend.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:50.191473983Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:50.204423324Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3av","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:50.204358191Z","created_by":"ubuntu"}]}
{"id":"bd-3c2","title":"Add CLI flags for gesture thresholds","description":"Add to watch command:\n- --gestures: Enable gesture detection\n- --long-press-ms <MS>: Threshold (default 800)\n- --double-tap-ms <MS>: Window (default 300)\n- --hold-tick-ms <MS>: Interval (default 100)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.896069405Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.905873064Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c2","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.905825153Z","created_by":"ubuntu"}]}
{"id":"bd-3c8","title":"Implement device info endpoint","description":"GET /api/device:\n```json\n{\n  \"model\": \"Stream Deck XL\",\n  \"serial\": \"ABC123\",\n  \"key_count\": 32,\n  \"key_width\": 72,\n  \"key_height\": 72,\n  \"firmware\": \"1.0.0\"\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.004989866Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.016076239Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c8","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.016018160Z","created_by":"ubuntu"}]}
{"id":"bd-3d5","title":"Add human-friendly progress output for batch","description":"Implement progress display for human users:\n- Show which key is being set\n- Display progress bar or counter (e.g., \"Setting key 5/32...\")\n- Report summary at end\n- Use colored output for success/failure","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.949008857Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.965817655Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3d5","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.965774463Z","created_by":"ubuntu"}]}
{"id":"bd-3dy","title":"Implement directory scanning with pattern matching","description":"Implement logic to:\n1. List files in the specified directory\n2. Match files against the pattern (e.g., key-00.png, key-01.png)\n3. Map matched files to key indices\n4. Return Vec<(u8, PathBuf)> of key-to-file mappings\n\nHandle edge cases:\n- Non-existent directory\n- Empty directory\n- No matching files\n- Invalid key indices in filenames","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.150275826Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:42.166775562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3dy","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.166727231Z","created_by":"ubuntu"}]}
{"id":"bd-3fo","title":"Implement path resolution (absolute, relative, ~)","description":"Path resolution logic:\n1. Absolute paths: use as-is\n2. Relative paths: resolve from config file directory\n3. ~ paths: expand to home directory\n4. Pattern paths: expand {index} placeholder\n\nConsider cross-platform home directory handling.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.799582382Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:56.815040156Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3fo","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.814993518Z","created_by":"ubuntu"}]}
{"id":"bd-3g6","title":"Implement config list command","description":"Implement sd config list:\n- List all imported/saved profiles\n- Show: name, creation date, device type, key count\n- Robot mode: JSON array\n- Human mode: Table format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.869558183Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.879394173Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3g6","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.879347044Z","created_by":"ubuntu"}]}
{"id":"bd-3gj","title":"Design gesture state machine","description":"Document state machine design:\n- States: Idle, Pressed, PotentialDoubleTap\n- Transitions based on press/release and timing\n- Gesture outputs: Tap, DoubleTap, LongPress, HoldStart/Tick/End\n\nCritical timing decisions:\n- Long press threshold (default 800ms)\n- Double tap window (default 300ms)\n- Hold tick interval (default 100ms)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:59.836520761Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:59.867034192Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3gj","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:27:59.866981643Z","created_by":"ubuntu"}]}
{"id":"bd-3il","title":"Implement hold start/tick/end","description":"Hold events for continuous actions:\n1. HoldStart when duration exceeds threshold while pressed\n2. HoldTick every interval while held\n3. HoldEnd on release (includes total duration)\n\nUsed for push-to-talk, volume adjustment, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.465425065Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.476661571Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3il","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.476608130Z","created_by":"ubuntu"}]}
{"id":"bd-3ix","title":"Implement validate command","description":"Implement sd validate <config.yaml>:\n- Check YAML/TOML syntax\n- Verify all image paths exist\n- Validate color formats\n- Check key indices against device range\n- Report all issues found\n\nExit code: 0 if valid, 1 if errors.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:58.360885986Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:58.375703194Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ix","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.375651196Z","created_by":"ubuntu"}]}
{"id":"bd-3j4","title":"Implement exponential backoff with cap","description":"Implement proper exponential backoff:\n- Start with configured delay (default 1s)\n- Multiply by backoff_factor each attempt (default 2.0)\n- Cap at maximum (30s) to prevent extremely long waits\n- Reset on successful connection","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:26.072744747Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:26.087364012Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j4","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.087313507Z","created_by":"ubuntu"}]}
{"id":"bd-3j5","title":"Add save command with state serialization","description":"Implement sd save <name>:\n1. Read current session state\n2. Read current device brightness (if available)\n3. Serialize to snapshot format\n4. Copy source images to snapshot storage\n5. Write metadata to SQLite\n\nHandle: name conflicts (prompt or overwrite), missing source images","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.196769381Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.205926602Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j5","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.205885675Z","created_by":"ubuntu"}]}
{"id":"bd-3ju","title":"EPIC: Batch Operations with Directory Import","description":"## Overview\n**Rank: #1 of 15** | **Impact: Very High** | **Effort: Low** | **Confidence: Very High**\n\nAdd `sd set-keys <DIR>` command that loads all images from a directory and sets them to keys based on filename pattern (e.g., `key-00.png`, `key-01.png`).\n\n## Problem Statement\nThe single biggest pain point with the current CLI is setting up a full device. For a Stream Deck XL (32 keys), users must call `sd set-key` 32 separate times. This is:\n- Tedious for humans\n- Inefficient for AI agents (32 tool calls instead of 1)\n- Error-prone (easy to miss keys or use wrong indices)\n- Not scriptable in a clean way\n\n## Solution\nA single command that atomically applies a directory of images to the device:\n```bash\nsd set-keys ~/my-deck-layout/\n# Reads key-00.png through key-31.png and applies them\n```\n\n## Why This Is #1 Priority\n1. **Immediate utility**: Solves the most common workflow pain point\n2. **Obvious accretion**: Uses existing image loading, key validation, and device communication\n3. **Robot-mode friendly**: Agents prepare a directory, apply atomically, get per-key error reporting\n4. **Low complexity**: ~50-75 lines of code, no new dependencies\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - add new command variant\nSetKeys { \n    /// Directory containing key-NN.png/jpg files\n    dir: PathBuf,\n    /// Naming pattern (default: key-{index}.png)\n    #[arg(long, default_value = \"key-{index}.png\")]\n    pattern: String,\n    /// Continue on error (report failures but keep going)\n    #[arg(long)]\n    continue_on_error: bool,\n}\n\n// In main.rs - implement command handler\nfn cmd_set_keys(device: &Device, dir: &Path, pattern: &str, continue_on_error: bool) -> Result<()> {\n    let key_count = device.info().key_count;\n    let mut results = Vec::new();\n    \n    for key in 0..key_count {\n        let filename = pattern.replace(\"{index}\", &format!(\"{key:02}\"));\n        let path = dir.join(&filename);\n        \n        if path.exists() {\n            match set_key_image(device, key, &path) {\n                Ok(()) => results.push((key, Ok(()))),\n                Err(e) if continue_on_error => results.push((key, Err(e))),\n                Err(e) => return Err(e),\n            }\n        }\n    }\n    \n    // Robot mode: return JSON array of results\n    // Human mode: print summary\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Pattern-based naming**: Flexible filename patterns support different conventions\n2. **Two-digit zero-padding**: `key-00.png` not `key-0.png` for proper sorting\n3. **Skip missing files**: Only set keys that have corresponding images\n4. **Continue-on-error option**: Batch operations should be resilient by default for agents\n5. **Detailed reporting**: Each key gets success/failure status in robot mode\n\n## Success Criteria\n- [ ] `sd set-keys <dir>` applies all matching images in one command\n- [ ] Pattern flag allows custom naming conventions\n- [ ] Robot mode returns per-key success/failure JSON\n- [ ] Human mode shows progress and summary\n- [ ] Errors include which key/file failed and why\n- [ ] Works with all Stream Deck variants (different key counts)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add SetKeys command struct\n- `src/main.rs`: Add cmd_set_keys handler and dispatch\n\n## Testing Strategy\n1. Create test directory with sample images\n2. Test with full set (32 images)\n3. Test with partial set (some keys missing)\n4. Test with invalid images (wrong format, corrupted)\n5. Test continue-on-error behavior\n6. Verify robot mode JSON output structure\n\n## Dependencies\nNone - uses existing infrastructure\n\n## Estimated Subtasks\n1. Add CLI command definition\n2. Implement directory scanning with pattern matching\n3. Implement batch application loop\n4. Add error handling and continue-on-error\n5. Implement robot mode JSON output\n6. Add human-friendly progress output\n7. Write tests\n8. Update help text and examples","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:28.552254273Z","created_by":"ubuntu","updated_at":"2026-01-19T18:09:28.568166823Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-1","user-experience"]}
{"id":"bd-3jv","title":"Add error handling for invalid configs","description":"When config file becomes invalid:\n- Parse error: show error, keep watching\n- Missing images: warn and skip those keys\n- Invalid colors: warn and skip\n- Never crash - always continue watching","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:35.076134526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.087156148Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3jv","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.087109520Z","created_by":"ubuntu"}]}
{"id":"bd-3lf","title":"Design and implement robot mode JSON structure","description":"Define consistent JSON structure for dry-run output:\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key\",\n  \"would_succeed\": true,\n  \"details\": { ... },\n  \"device\": { ... }\n}\n```\n\nDocument structure for each command type.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.936881067Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.946974752Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lf","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.946932873Z","created_by":"ubuntu"}]}
{"id":"bd-3ln","title":"Complete ProfileLoader extraction logic","description":"Finish the ProfileLoader implementation:\n1. from_zip(): Open and validate profile ZIP\n2. extract_to(): Extract to temp directory\n3. parse(): Parse manifest.json and profile.json\n4. Map Elgato structures to our types\n\nHandle version differences in Elgato format.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.194682502Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.204058626Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ln","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.204012749Z","created_by":"ubuntu"}]}
{"id":"bd-3lp","title":"Write comprehensive tests for declarative config","description":"Test coverage:\n1. YAML parsing with various structures\n2. TOML parsing equivalence\n3. Selector resolution (single, range, row)\n4. Path resolution (all types)\n5. Pattern expansion\n6. Validation logic\n7. Apply behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:59.218810453Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:59.229437952Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lp","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:59.229375715Z","created_by":"ubuntu"}]}
{"id":"bd-3mz","title":"Implement apply command for declarative config","description":"Implement sd apply <config.yaml>:\n1. Load and parse config file\n2. Resolve all selectors to concrete keys\n3. Apply brightness if specified\n4. Apply each key configuration\n5. Report results\n\nHandle: missing files, invalid configs, partial success.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.880977922Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:57.896528941Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3mz","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.896482794Z","created_by":"ubuntu"}]}
{"id":"bd-3p6","title":"EPIC: Image Caching with Content-Addressable Storage","description":"## Overview\n**Rank: #9 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: High**\n\nCache resized images by content hash so repeated operations are instant.\n\n## Problem Statement\nEvery `sd set-key` call:\n1. Opens the image file\n2. Decodes the image format (PNG, JPG, etc.)\n3. Resizes to device key dimensions (e.g., 72x72)\n4. Encodes to device format\n5. Sends to device\n\nSteps 1-4 take ~50-150ms per image depending on source size. For a 32-key device, full setup takes 2-5 seconds. Repeated applications of the same configuration waste this time.\n\n## Solution\nContent-addressable cache that stores pre-processed images:\n```\n~/.cache/sd/\n└── images/\n    ├── a1b2c3d4e5f6...72x72.bin    # Pre-resized, ready to send\n    ├── f6e5d4c3b2a1...72x72.bin\n    └── ...\n```\n\nCache key: `SHA256(file_content + target_dimensions)`\n\n```bash\n# First run: processes all images (~3s)\nsd set-keys ~/layout/\n\n# Second run: uses cache (~0.3s)\nsd set-keys ~/layout/\n\n# Cache statistics\nsd cache stats\n# Output:\n# Cache location: ~/.cache/sd/images/\n# Entries: 47\n# Size: 2.3 MB\n# Hit rate: 94%\n\n# Clear cache\nsd cache clear\n```\n\n## Why This Is #9 Priority\n1. **Performance**: 10x speedup for repeated operations\n2. **Agent efficiency**: Agents often apply same configs repeatedly\n3. **Batch speedup**: Setting 32 keys goes from ~3s to ~0.3s\n4. **Low effort**: Well-understood pattern, ~100 lines\n5. **Invisible improvement**: Users just notice things are faster\n\n## Implementation Approach\n\n### Phase 1: Cache Infrastructure\n```rust\n// In src/cache.rs (new file)\nuse sha2::{Sha256, Digest};\nuse std::path::PathBuf;\n\npub struct ImageCache {\n    cache_dir: PathBuf,\n}\n\nimpl ImageCache {\n    pub fn new() -> Result<Self> {\n        let cache_dir = dirs::cache_dir()\n            .ok_or(SdError::NoCacheDir)?\n            .join(\"sd\")\n            .join(\"images\");\n        std::fs::create_dir_all(&cache_dir)?;\n        Ok(Self { cache_dir })\n    }\n    \n    /// Generate cache key from source file and target dimensions\n    fn cache_key(source: &Path, width: u32, height: u32) -> String {\n        let content = std::fs::read(source).unwrap_or_default();\n        let mut hasher = Sha256::new();\n        hasher.update(&content);\n        hasher.update(width.to_le_bytes());\n        hasher.update(height.to_le_bytes());\n        let hash = hasher.finalize();\n        format\\!(\"{:x}-{}x{}.bin\", hash, width, height)\n    }\n    \n    /// Get cached image or None if not cached\n    pub fn get(&self, source: &Path, width: u32, height: u32) -> Option<Vec<u8>> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::read(&cache_path).ok()\n    }\n    \n    /// Store processed image in cache\n    pub fn put(&self, source: &Path, width: u32, height: u32, data: &[u8]) -> Result<()> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::write(&cache_path, data)?;\n        Ok(())\n    }\n    \n    /// Get cache statistics\n    pub fn stats(&self) -> CacheStats {\n        let entries: Vec<_> = std::fs::read_dir(&self.cache_dir)\n            .map(|rd| rd.filter_map(|e| e.ok()).collect())\n            .unwrap_or_default();\n        \n        let total_size: u64 = entries.iter()\n            .filter_map(|e| e.metadata().ok())\n            .map(|m| m.len())\n            .sum();\n        \n        CacheStats {\n            location: self.cache_dir.clone(),\n            entries: entries.len(),\n            size_bytes: total_size,\n        }\n    }\n    \n    /// Clear all cached images\n    pub fn clear(&self) -> Result<usize> {\n        let entries = std::fs::read_dir(&self.cache_dir)?;\n        let mut count = 0;\n        for entry in entries.filter_map(|e| e.ok()) {\n            if entry.path().extension().map(|e| e == \"bin\").unwrap_or(false) {\n                std::fs::remove_file(entry.path())?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }\n}\n\n#[derive(Debug)]\npub struct CacheStats {\n    pub location: PathBuf,\n    pub entries: usize,\n    pub size_bytes: u64,\n}\n```\n\n### Phase 2: Integration with set_key_image\n```rust\n// In src/main.rs or src/device.rs\nfn set_key_image_cached(\n    device: &Device,\n    key: u8,\n    path: &Path,\n    cache: &ImageCache,\n) -> Result<()> {\n    let (width, height) = device.info().key_size();\n    \n    // Check cache first\n    if let Some(data) = cache.get(path, width, height) {\n        device.set_key_raw(key, &data)?;\n        return Ok(());\n    }\n    \n    // Cache miss: process image\n    let img = image::open(path)?;\n    let resized = img.resize_exact(width, height, FilterType::Lanczos3);\n    let data = encode_for_device(&resized)?;\n    \n    // Store in cache\n    cache.put(path, width, height, &data)?;\n    \n    // Send to device\n    device.set_key_raw(key, &data)?;\n    Ok(())\n}\n```\n\n### Phase 3: Cache Commands\n```rust\n// In src/cli/mod.rs\nCache {\n    #[command(subcommand)]\n    action: CacheAction,\n}\n\n#[derive(Subcommand)]\nenum CacheAction {\n    /// Show cache statistics\n    Stats,\n    /// Clear all cached images\n    Clear,\n    /// Show cache location\n    Location,\n}\n```\n\n## Cache Invalidation Strategy\nThe content-addressable approach means:\n- If source file changes, hash changes, new cache entry created\n- Old entries become orphaned but harmless\n- Periodic cleanup can remove orphaned entries\n- No explicit invalidation needed for correctness\n\n## Key Design Decisions\n1. **Content-addressable**: Hash-based keys ensure correctness\n2. **Include dimensions in key**: Same image at different sizes = different entries\n3. **Binary format**: Store device-ready bytes, not intermediate images\n4. **Lazy population**: Only cache images that are actually used\n5. **Simple cleanup**: `sd cache clear` removes everything\n\n## Success Criteria\n- [ ] Cache directory created at ~/.cache/sd/images/\n- [ ] Repeated set-key calls use cache (measurable speedup)\n- [ ] Cache key includes source content hash and target dimensions\n- [ ] `sd cache stats` shows cache statistics\n- [ ] `sd cache clear` removes all cached entries\n- [ ] Cache miss processes and stores image\n- [ ] Robot mode reports cache hit/miss\n\n## Files to Create/Modify\n- `src/cache.rs`: New cache module\n- `src/cli/mod.rs`: Add Cache command\n- `src/main.rs`: Integrate cache into set-key operations\n- `Cargo.toml`: Add sha2 dependency\n\n## Dependencies\n- Soft: BATCH-OPS benefits most from caching (many images at once)\n\n## Estimated Subtasks\n1. Add sha2 dependency to Cargo.toml\n2. Implement ImageCache struct with get/put\n3. Implement cache key generation\n4. Integrate cache into set_key_image\n5. Add cache stats command\n6. Add cache clear command\n7. Add robot mode cache hit/miss reporting\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:23.156441630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:19:23.195793021Z","compaction_level":0,"original_size":0,"labels":["cache","optimization","performance","priority-9"]}
{"id":"bd-3pm","title":"Implement init --import command","description":"Implement sd init --import <file>:\n1. Open profile file with ProfileLoader\n2. Parse profile contents\n3. Store in config database with given name\n4. Copy images to config storage\n5. Report import summary\n\nHandle: invalid files, permission errors, existing profiles.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.417682158Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.427250363Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pm","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.427205538Z","created_by":"ubuntu"}]}
{"id":"bd-3pp","title":"Add Fish output format","description":"With --format fish:\n- Use fish shell syntax\n- Different variable handling\n- Proper path quoting for fish","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:03.698067351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:03.710521380Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pp","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:03.710482687Z","created_by":"ubuntu"}]}
{"id":"bd-3pu","title":"EPIC: Shell Completion Scripts","description":"## Overview\n**Rank: #5 of 15** | **Impact: Medium** | **Effort: Very Low** | **Confidence: Very High**\n\nFully implement the `sd completions <shell>` command to generate shell completion scripts for bash, zsh, fish, and PowerShell.\n\n## Problem Statement\nThe `sd completions` command is already stubbed in the CLI definition but the actual clap_complete integration is missing. Without shell completions:\n- Users must remember exact command names and flags\n- Tab completion shows nothing or wrong suggestions\n- The CLI feels unpolished compared to mature tools\n- Discovery of features requires reading help text\n\n## Solution\nComplete the existing stubbed command:\n```bash\n# Generate completions for your shell\nsd completions bash > ~/.local/share/bash-completion/completions/sd\nsd completions zsh > ~/.zfunc/_sd\nsd completions fish > ~/.config/fish/completions/sd.fish\nsd completions powershell > sd.ps1\n\n# Then enjoy tab completion\nsd <TAB>\n# list  info  brightness  set-key  fill-key  clear-key  ...\n\nsd set-key <TAB>\n# Shows: 0 1 2 3 4 5 ... (key indices)\n\nsd --<TAB>\n# Shows: --robot --format --serial --help --version\n```\n\n## Why This Is #5 Priority\n1. **Already stubbed**: The command exists, just needs wiring\n2. **Very low effort**: ~20 lines using clap_complete crate\n3. **High polish signal**: Completions indicate a mature, well-maintained CLI\n4. **Developer experience**: Makes daily use much more pleasant\n5. **Standard pattern**: clap_complete is the canonical solution\n\n## Implementation Approach\n```rust\n// Add to Cargo.toml\n[dependencies]\nclap_complete = \"4\"\n\n// In src/cli/mod.rs - already exists\n#[derive(Subcommand)]\npub enum Command {\n    /// Generate shell completion scripts\n    Completions {\n        /// Shell to generate completions for\n        #[arg(value_enum)]\n        shell: clap_complete::Shell,\n    },\n    // ...\n}\n\n// In main.rs - implement the handler\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n\n// In main dispatch\nCommand::Completions { shell } => cmd_completions(shell),\n```\n\n## Supported Shells\nclap_complete supports:\n- **Bash**: Most common on Linux\n- **Zsh**: Default on macOS, popular on Linux\n- **Fish**: Modern shell with excellent completion support\n- **PowerShell**: Windows default\n- **Elvish**: Niche but supported\n\n## Installation Instructions (to include in help)\n```\nINSTALLATION:\n\nBash (Linux):\n  sd completions bash > ~/.local/share/bash-completion/completions/sd\n  # Or system-wide: sudo sd completions bash > /etc/bash_completion.d/sd\n\nBash (macOS with Homebrew):\n  sd completions bash > $(brew --prefix)/etc/bash_completion.d/sd\n\nZsh:\n  sd completions zsh > ~/.zfunc/_sd\n  # Ensure ~/.zfunc is in fpath and compinit is called\n\nFish:\n  sd completions fish > ~/.config/fish/completions/sd.fish\n\nPowerShell:\n  sd completions powershell >> $PROFILE\n```\n\n## Key Design Decisions\n1. **Use clap_complete**: Standard solution, well-maintained\n2. **Output to stdout**: Let users redirect to appropriate location\n3. **Include installation help**: Show how to install for each shell\n4. **All shells supported**: Dont pick favorites, support what clap_complete offers\n\n## Success Criteria\n- [ ] `sd completions bash` generates valid bash completions\n- [ ] `sd completions zsh` generates valid zsh completions\n- [ ] `sd completions fish` generates valid fish completions\n- [ ] `sd completions powershell` generates valid PowerShell completions\n- [ ] Completions include all commands and flags\n- [ ] Help text includes installation instructions\n\n## Files to Modify\n- `Cargo.toml`: Add clap_complete dependency\n- `src/cli/mod.rs`: Ensure Shell enum is properly defined\n- `src/main.rs`: Implement cmd_completions handler\n\n## Dependencies\nNone - standalone feature, uses existing CLI structure\n\n## Estimated Subtasks\n1. Add clap_complete to Cargo.toml\n2. Implement cmd_completions handler in main.rs\n3. Test generated completions for bash\n4. Test generated completions for zsh\n5. Test generated completions for fish\n6. Add installation instructions to help text","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:11:22.364835803Z","created_by":"ubuntu","updated_at":"2026-01-19T18:11:22.403718031Z","compaction_level":0,"original_size":0,"labels":["cli","developer-experience","polish","priority-5"]}
{"id":"bd-3q3","title":"Implement image caching for snapshots","description":"When saving snapshots:\n1. Read and resize source images\n2. Store processed images in snapshot directory\n3. Use content-addressable naming (SHA256)\n4. On restore, use cached images if source missing\n\nThis provides resilience when source images are moved/deleted.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.703366526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.713034639Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3q3","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.712985466Z","created_by":"ubuntu"}]}
{"id":"bd-3qj","title":"Implement pattern expansion","description":"Pattern expansion for batch key definitions:\n- \"~/icons/row2/{index}.png\" with key 8 → \"~/icons/row2/08.png\"\n- Zero-pad to 2 digits\n- Support in both pattern: field and image: field\n\nHandle missing files gracefully.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.088705856Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:57.098791595Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3qj","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.098753924Z","created_by":"ubuntu"}]}
{"id":"bd-3w1","title":"Write tests for dry-run behavior","description":"Test coverage:\n1. Dry-run validates inputs (catches errors)\n2. Dry-run never touches device\n3. Output includes all relevant details\n4. Works even without device connected (where applicable)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:45.129502306Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:45.138695114Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3w1","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:45.138653376Z","created_by":"ubuntu"}]}
{"id":"bd-4zd","title":"Implement key image upload endpoint","description":"POST /api/keys/:id with multipart form:\n- Accept image file upload\n- Process and resize\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:44.553749212Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:44.570008184Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-4zd","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:44.569957699Z","created_by":"ubuntu"}]}
{"id":"bd-53g","title":"Add --embed-images with base64 encoding","description":"With --embed-images flag:\n1. Read each source image\n2. Base64 encode\n3. Generate self-contained commands:\n```bash\necho \"BASE64DATA\" | base64 -d > /tmp/key0.png\nsd set-key 0 /tmp/key0.png\n```\n\nOr use stdin if supported: sd set-key 0 - < <(echo ... | base64 -d)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:02.311118252Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:02.327835748Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-53g","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.327718307Z","created_by":"ubuntu"}]}
{"id":"bd-5v0","title":"Implement dry-run for fill-key command","description":"When dry_run=true:\n- Parse and validate color\n- Show key index\n- Show color value (hex and RGB)\n- Return without applying","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.368495216Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.379392443Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-5v0","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.379338892Z","created_by":"ubuntu"}]}
{"id":"bd-8r8","title":"Implement apply command","description":"Implement sd apply <name>:\n1. Load profile from database\n2. Verify device compatibility\n3. Set brightness if stored\n4. Apply each key (image, color, or clear)\n5. Report results\n\nConsider: partial application, error handling.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.101462966Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.110721928Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-8r8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.110682404Z","created_by":"ubuntu"}]}
{"id":"bd-9c7","title":"Implement dry-run for set-key command","description":"When dry_run=true:\n1. Validate image exists and is readable\n2. Load image to get dimensions\n3. Calculate resize requirements\n4. Report all details without applying\n\nInclude: source path, dimensions, resize behavior, target key","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.180066411Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.190846257Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9c7","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.190801533Z","created_by":"ubuntu"}]}
{"id":"bd-9gy","title":"Test generated completions for bash","description":"Manual testing:\n1. Generate: sd completions bash > /tmp/sd.bash\n2. Source: source /tmp/sd.bash\n3. Test: sd <TAB> shows commands\n4. Test: sd --<TAB> shows flags\n5. Verify no syntax errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.664311526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.674462538Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9gy","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.674414859Z","created_by":"ubuntu"}]}
{"id":"bd-a1n","title":"Implement KeySelector parsing and resolution","description":"Implement KeySelector enum and parsing:\n- Single(u8): \"0\", \"15\"\n- Range(u8, u8): \"8-15\"\n- Row(u8): \"row-0\", \"row-3\"\n- Default: \"default\"\n\nInclude resolve() method that returns Vec<u8> of key indices.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.902317074Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:55.914106651Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-a1n","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.914061186Z","created_by":"ubuntu"}]}
{"id":"bd-aox","title":"Implement text overlay on images","description":"Add overlay function:\n```rust\npub fn overlay_text(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage\n```\n\nOptional background rectangle for readability.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.807308593Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.818600052Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-aox","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.818546131Z","created_by":"ubuntu"}]}
{"id":"bd-b14","title":"Set up axum server skeleton","description":"Create src/server/mod.rs:\n1. Add axum, tower dependencies\n2. Create basic Router\n3. Add AppState with device handle\n4. Implement server startup in cmd_serve\n5. Auto-open browser (unless --no-open)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:42.555773688Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:42.584502158Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-b14","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:42.584443487Z","created_by":"ubuntu"}]}
{"id":"bd-df0","title":"Handle missing source images gracefully","description":"When restoring and source image is missing:\n1. Check for cached version in snapshot\n2. If cached exists, use it and warn user\n3. If no cache, skip key and report error\n4. Continue with other keys (dont fail completely)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.843973672Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.853646294Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-df0","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.853607040Z","created_by":"ubuntu"}]}
{"id":"bd-e36","title":"Implement session state tracking","description":"Create src/state.rs module with:\n- SessionState struct tracking brightness and key states\n- KeyState enum (Image, Color, Cleared)\n- Global state accessor (thread-safe)\n- Methods: record_brightness, record_set_key, record_fill_key, record_clear_key\n\nThis is SHARED with Export Script epic - design for reuse.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.077604396Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:05.086620522Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e36","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.086576789Z","created_by":"ubuntu"}]}
{"id":"bd-e3b","title":"Implement cache key generation","description":"Generate cache key from:\n- SHA256 of source file contents\n- Target dimensions (width, height)\n\nFormat: {hash}-{w}x{h}.bin\nExample: a1b2c3d4...72x72.bin","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.776692846Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.786506503Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e3b","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.786457801Z","created_by":"ubuntu"}]}
{"id":"bd-gbs","title":"Implement cmd_completions handler in main.rs","description":"Implement the completions command:\n```rust\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n```\n\nAdd dispatch in main match statement.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.459670076Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:59.469921677Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-gbs","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.469880500Z","created_by":"ubuntu"}]}
{"id":"bd-hgu","title":"Implement ImageCache struct with get/put","description":"Create src/cache.rs:\n- ImageCache struct with cache_dir field\n- new() creates ~/.cache/sd/images/ directory\n- get(source, w, h) -> Option<Vec<u8>>\n- put(source, w, h, data) -> Result<()>\n\nCache stores pre-processed images ready for device.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.475179194Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.484622333Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-hgu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.484576697Z","created_by":"ubuntu"}]}
{"id":"bd-i5h","title":"Implement dry-run for set-keys (batch)","description":"When dry_run=true:\n- Scan directory and show all matches\n- For each key: show source, dimensions, resize needed\n- Show keys that would be skipped (no file)\n- Summary: N keys would be set, M would be skipped","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.755545788Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:44.765086591Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-i5h","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.764953701Z","created_by":"ubuntu"}]}
{"id":"bd-iuk","title":"Add keymap gesture support","description":"Extend keymap format:\n```yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: open new window\n    hold: push-to-talk script\n```\n\nIntegrate with scripting hooks.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.758897955Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.768966392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-iuk","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.768925646Z","created_by":"ubuntu"}]}
{"id":"bd-mwd","title":"Add robot mode rate limit reporting","description":"Report when rate limited:\n```json\n{\n  \"key\": 15,\n  \"rate_limited\": true,\n  \"waited_ms\": 50\n}\n```\n\nUseful for debugging performance issues.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.134002733Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:21.146063381Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-mwd","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.145981728Z","created_by":"ubuntu"}]}
{"id":"bd-oqp","title":"Implement long-press detection","description":"Long press = released after threshold:\n1. Track press start time\n2. On release, check duration\n3. If >= threshold → LongPress\n4. If < threshold → potential Tap\n\nDistinct from Hold (still pressed).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.058745696Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.069535210Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-oqp","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.069490276Z","created_by":"ubuntu"}]}
{"id":"bd-p9h","title":"Implement tap/double-tap detection with deferral","description":"Tap detection requires deferral:\n1. On release, record potential tap time\n2. Start timer for double-tap window\n3. If another press within window → DoubleTap\n4. If window expires → emit deferred Tap\n\nThis prevents emitting Tap before DoubleTap is ruled out.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.663327449Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:00.673778296Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-p9h","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.673732490Z","created_by":"ubuntu"}]}
{"id":"bd-pls","title":"Implement command template substitution","description":"Replace placeholders in command strings:\n- {key} → key index (e.g., \"5\")\n- {pressed} → \"true\" or \"false\"\n- {timestamp} → ISO timestamp\n\nUse simple string replacement, not shell interpolation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.638071617Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.652607365Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-pls","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.652559995Z","created_by":"ubuntu"}]}
{"id":"bd-qch","title":"Handle edge cases (delete, rename)","description":"Handle file operations:\n- File deleted: warn and continue watching (may reappear)\n- File renamed: re-watch new path?\n- Directory deleted: error and exit\n\nDecide on behavior and document.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:36.265137410Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:36.276036341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qch","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:36.275979654Z","created_by":"ubuntu"}]}
{"id":"bd-qf8","title":"Audit existing src/config/ code and identify gaps","description":"Review existing infrastructure:\n- src/config/loader.rs: ZIP extraction capabilities\n- src/config/db.rs: SQLite schema and operations\n- src/config/types.rs: Profile, Key, Action types\n\nDocument what exists vs what needs implementation.\nThis is RESEARCH - produces a gap analysis document.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:29.966270817Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:29.994810562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qf8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:29.994765116Z","created_by":"ubuntu"}]}
{"id":"bd-qvw","title":"Write tests for gesture edge cases","description":"Test coverage:\n1. Tap vs double-tap timing edge cases\n2. Long press threshold boundary\n3. Hold tick accuracy\n4. Multiple keys simultaneously\n5. Rapid sequences","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:03.175268351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:03.185624960Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qvw","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:03.185587339Z","created_by":"ubuntu"}]}
{"id":"bd-rfp","title":"Add --retry and --retry-delay CLI flags","description":"Add global flags to CLI:\n- --retry N: Retry N times on connection failure\n- --retry-delay MS: Initial delay between retries (default: 1000)\n\nApply to all commands that open a device.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.030520980Z","created_by":"ubuntu","updated_at":"2026-01-19T18:24:25.045733392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-rfp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.045697124Z","created_by":"ubuntu"}]}
{"id":"bd-s04","title":"EPIC: Elgato Profile Import","description":"## Overview\n**Rank: #6 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nComplete the `sd init --import <file.streamDeckProfile>` command to load official Elgato Stream Deck profiles.\n\n## Problem Statement\nUsers with existing Stream Deck setups have invested significant time configuring their devices through the official Elgato software. To migrate to this CLI, they currently must:\n- Manually recreate every key configuration\n- Re-source and re-apply all images\n- Lose any complex configurations (folders, multi-actions)\n\nThis is a huge barrier to adoption. Users wont switch if it means starting from scratch.\n\n## Solution\nImport official Elgato profile files:\n```bash\n# Import an exported profile\nsd init --import ~/Downloads/MySetup.streamDeckProfile\n\n# The profile is a ZIP containing:\n# - manifest.json (profile metadata)\n# - Profiles/<uuid>/profile.json (key configurations)\n# - Images/<uuid>.png (key images)\n\n# After import, users can:\nsd config show        # See imported configuration\nsd apply default      # Apply the imported profile\n```\n\n## Why This Is #6 Priority\n1. **Infrastructure already built**: `src/config/` has ZIP loader, SQLite schema, profile parser!\n2. **Adoption enabler**: Users can migrate without losing their existing setup\n3. **Competitive advantage**: No other open-source tool does this well\n4. **Trust builder**: Shows we respect users existing investment\n\n## Existing Infrastructure in src/config/\n\nThe `src/config/` module already contains substantial infrastructure:\n\n```\nsrc/config/\n├── mod.rs       # Module exports\n├── loader.rs    # ZIP file extraction and parsing\n├── db.rs        # SQLite schema and operations\n└── types.rs     # Profile, Key, Action type definitions\n```\n\nKey existing code:\n- `ProfileLoader::from_zip()` - Opens and validates profile ZIP\n- `ProfileLoader::extract_to()` - Extracts to temp directory\n- `Profile`, `Key`, `Action` structs defined\n- SQLite schema for storing profiles\n\nWhat needs to be done:\n- Wire loader to CLI commands\n- Implement the `init` and `config` commands\n- Handle the mapping from Elgato action types to our commands\n- Store and retrieve images from the extracted profile\n\n## Elgato Profile Format Analysis\n\nThe `.streamDeckProfile` file is a ZIP archive:\n```\nMySetup.streamDeckProfile (ZIP)\n├── manifest.json\n│   {\n│     \"Version\": \"1.0\",\n│     \"DeviceUUID\": \"...\",\n│     \"DeviceModel\": \"StreamDeckXL\"\n│   }\n├── Profiles/\n│   └── <uuid>/\n│       └── profile.json\n│           {\n│             \"Controller\": \"Encoder\",\n│             \"Name\": \"Default Profile\",\n│             \"Keys\": [\n│               {\n│                 \"UUID\": \"...\",\n│                 \"Title\": \"Chrome\",\n│                 \"Image\": \"Images/abc123.png\",\n│                 \"Actions\": [...]\n│               }\n│             ]\n│           }\n└── Images/\n    ├── abc123.png\n    └── def456.png\n```\n\n## Implementation Approach\n\n### Phase 1: Complete the Init Command\n```rust\n// In src/cli/mod.rs\nInit {\n    /// Import from Elgato profile file\n    #[arg(long)]\n    import: Option<PathBuf>,\n    \n    /// Profile name (default: \"default\")\n    #[arg(long, default_value = \"default\")]\n    name: String,\n}\n\n// In main.rs\nfn cmd_init(import: Option<&Path>, name: &str) -> Result<()> {\n    if let Some(profile_path) = import {\n        let loader = ProfileLoader::from_zip(profile_path)?;\n        let profile = loader.parse()?;\n        \n        // Store in config database\n        let config_dir = config_dir()?;\n        let db = ConfigDb::open(&config_dir)?;\n        db.import_profile(name, &profile)?;\n        \n        // Copy images to config storage\n        for key in &profile.keys {\n            if let Some(image_path) = &key.image {\n                copy_image_to_storage(&config_dir, image_path)?;\n            }\n        }\n        \n        println!(\"Imported profile \\\"{}\\\" with {} keys\", name, profile.keys.len());\n    } else {\n        // Interactive setup\n        println!(\"Interactive setup not yet implemented\");\n    }\n    Ok(())\n}\n```\n\n### Phase 2: Config Show/Apply Commands\n```rust\n// Show imported configuration\nfn cmd_config_show(name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        println!(\"Key {}: {} ({})\", key.index, key.title, key.image_source());\n    }\n    Ok(())\n}\n\n// Apply configuration to device\nfn cmd_apply(device: &Device, name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        if let Some(image_path) = key.resolved_image_path() {\n            set_key_image(device, key.index, &image_path)?;\n        }\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Leverage existing code**: Dont rewrite what exists in src/config/\n2. **Named profiles**: Store multiple profiles, apply by name\n3. **Image copying**: Copy images to our storage for portability\n4. **Graceful degradation**: Handle unsupported Elgato features gracefully\n5. **Forward compatibility**: Design for future Elgato format versions\n\n## Elgato Feature Mapping\n| Elgato Feature | Our Support |\n|----------------|-------------|\n| Static images | Full |\n| Solid colors | Full |\n| System actions | Partial (map to shell commands) |\n| Folders | Not yet (track as nested profiles) |\n| Multi-actions | Not yet (future scripting feature) |\n| Animated GIFs | Not yet |\n\n## Success Criteria\n- [ ] `sd init --import <file>` loads Elgato profile\n- [ ] Imported images stored in config directory\n- [ ] `sd config show` displays imported configuration\n- [ ] `sd apply <name>` applies profile to device\n- [ ] Unsupported features logged with warnings\n- [ ] Robot mode returns import summary JSON\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Init, Config, Apply commands\n- `src/main.rs`: Implement command handlers\n- `src/config/loader.rs`: Complete extraction logic\n- `src/config/db.rs`: Complete storage operations\n\n## Dependencies\n- Soft: Benefits from BATCH-OPS for applying multiple keys efficiently\n\n## Estimated Subtasks\n1. Audit existing src/config/ code and identify gaps\n2. Complete ProfileLoader extraction logic\n3. Implement init --import command\n4. Implement config show command\n5. Implement config list command\n6. Implement apply command\n7. Handle image copying and storage\n8. Add support for unsupported feature warnings\n9. Write tests with sample profile files","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:05.904911952Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:05.948021860Z","compaction_level":0,"original_size":0,"labels":["config","interoperability","migration","priority-6"]}
{"id":"bd-txy","title":"Add sha2 dependency to Cargo.toml","description":"Add:\n```toml\n[dependencies]\nsha2 = \"0.10\"\n```\n\nUsed for content-addressable cache keys.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.179210261Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.189556802Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-txy","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.189514442Z","created_by":"ubuntu"}]}
{"id":"bd-uau","title":"Implement config show command","description":"Implement sd config show [name]:\n- Display profile metadata (name, device type, key count)\n- List all key configurations\n- Show image sources and action types\n- Robot mode: Full JSON of profile\n- Human mode: Formatted table","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.642852300Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.652578512Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-uau","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.652525282Z","created_by":"ubuntu"}]}
{"id":"bd-vc3","title":"EPIC: Rate Limiting and Burst Protection","description":"## Overview\n**Rank: #13 of 15** | **Impact: Low** | **Effort: Low** | **Confidence: High**\n\nPrevent USB communication floods with configurable rate limiting to protect device stability.\n\n## Problem Statement\nRapid-fire commands from scripts or AI agents can:\n- Overwhelm the USB communication channel\n- Cause device firmware to misbehave\n- Lead to dropped commands or corrupted state\n- Create unpredictable timing issues\n\nWhile the current single-command CLI naturally rate-limits (each command is a separate process), future features like daemon mode, batch operations, or scripted sequences could hit these limits.\n\n## Solution\nConfigurable rate limiting with sensible defaults:\n```bash\n# Explicit rate limiting\nsd set-keys ~/layout/ --rate-limit 50ms\n\n# Global rate limit for all operations\nsd --rate-limit 100ms brightness 50\n\n# Burst mode with queue\nsd batch --queue-size 100 --rate-limit 20ms < commands.txt\n```\n\nInternal rate limiter for programmatic use:\n```rust\nlet limiter = RateLimiter::new(Duration::from_millis(50));\n\nfor key in 0..32 {\n    limiter.wait(); // Blocks until rate limit allows\n    device.set_key_image(key, &images[key])?;\n}\n```\n\n## Why This Is #13 Priority\n1. **Defensive programming**: Prevents edge case failures\n2. **Low effort**: Token bucket is ~50 lines\n3. **Future-proofing**: Needed for daemon/server mode\n4. **Low immediate impact**: Current CLI is naturally limited\n5. **Invisible when working**: Users dont notice rate limiting\n\n## Implementation Approach\n\n### Token Bucket Rate Limiter\n```rust\n// In src/rate_limit.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct RateLimiter {\n    min_interval: Duration,\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    pub fn new(min_interval: Duration) -> Self {\n        Self {\n            min_interval,\n            last_action: None,\n        }\n    }\n    \n    /// Block until rate limit allows next action\n    pub fn wait(&mut self) {\n        if let Some(last) = self.last_action {\n            let elapsed = last.elapsed();\n            if elapsed < self.min_interval {\n                std::thread::sleep(self.min_interval - elapsed);\n            }\n        }\n        self.last_action = Some(Instant::now());\n    }\n    \n    /// Check if action is allowed without blocking\n    pub fn check(&self) -> bool {\n        self.last_action\n            .map(|last| last.elapsed() >= self.min_interval)\n            .unwrap_or(true)\n    }\n    \n    /// Try to acquire permission, return false if rate limited\n    pub fn try_acquire(&mut self) -> bool {\n        if self.check() {\n            self.last_action = Some(Instant::now());\n            true\n        } else {\n            false\n        }\n    }\n}\n\n// Advanced: Token bucket with burst capacity\npub struct TokenBucket {\n    capacity: usize,\n    tokens: f64,\n    refill_rate: f64,  // tokens per second\n    last_refill: Instant,\n}\n\nimpl TokenBucket {\n    pub fn new(capacity: usize, rate_per_second: f64) -> Self {\n        Self {\n            capacity,\n            tokens: capacity as f64,\n            refill_rate: rate_per_second,\n            last_refill: Instant::now(),\n        }\n    }\n    \n    pub fn try_acquire(&mut self, count: usize) -> bool {\n        self.refill();\n        if self.tokens >= count as f64 {\n            self.tokens -= count as f64;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn refill(&mut self) {\n        let now = Instant::now();\n        let elapsed = now.duration_since(self.last_refill).as_secs_f64();\n        self.tokens = (self.tokens + elapsed * self.refill_rate).min(self.capacity as f64);\n        self.last_refill = now;\n    }\n}\n```\n\n### Integration Points\n```rust\n// In device operations\nimpl Device {\n    pub fn set_key_image_rate_limited(\n        &self,\n        key: u8,\n        image: &[u8],\n        limiter: &mut RateLimiter,\n    ) -> Result<()> {\n        limiter.wait();\n        self.set_key_image(key, image)\n    }\n}\n\n// In batch operations\nfn cmd_set_keys(device: &Device, dir: &Path, rate_limit_ms: Option<u64>) -> Result<()> {\n    let mut limiter = rate_limit_ms\n        .map(|ms| RateLimiter::new(Duration::from_millis(ms)));\n    \n    for (key, path) in keys_to_set {\n        if let Some(ref mut l) = limiter {\n            l.wait();\n        }\n        set_key_image(device, key, &path)?;\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Optional by default**: Dont rate limit unless requested or in batch mode\n2. **Simple interval limiter**: Default implementation, easy to understand\n3. **Token bucket for burst**: Advanced option for daemon/server mode\n4. **Per-operation granularity**: Rate limit individual USB operations\n5. **Configurable via CLI**: --rate-limit flag on relevant commands\n\n## Success Criteria\n- [ ] RateLimiter struct implemented with wait/check/try_acquire\n- [ ] TokenBucket implemented for burst scenarios\n- [ ] --rate-limit flag available on batch commands\n- [ ] Batch operations use rate limiting by default\n- [ ] Rate limiting is invisible when not needed\n- [ ] Robot mode reports when rate limited\n\n## Files to Create/Modify\n- `src/rate_limit.rs`: New rate limiting module\n- `src/cli/mod.rs`: Add --rate-limit flag to relevant commands\n- `src/main.rs`: Integrate rate limiter into batch operations\n\n## Dependencies\n- Useful for BATCH-OPS (#1) and future daemon mode\n\n## Estimated Subtasks\n1. Implement simple RateLimiter struct\n2. Implement TokenBucket for burst scenarios\n3. Add --rate-limit CLI flag\n4. Integrate into batch set-keys command\n5. Add robot mode rate limit reporting\n6. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:38.963557809Z","created_by":"ubuntu","updated_at":"2026-01-19T18:21:38.996177816Z","compaction_level":0,"original_size":0,"labels":["defensive","priority-13","reliability","usb"]}
{"id":"bd-vh6","title":"Write integration tests for web API","description":"Test coverage:\n1. Device info endpoint\n2. Brightness get/set\n3. Image upload and apply\n4. Color fill\n5. Clear key\n6. Error handling","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.964820103Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:51.981130101Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-vh6","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.981074787Z","created_by":"ubuntu"}]}
{"id":"bd-xjo","title":"Implement brightness endpoint","description":"GET /api/brightness → { \"level\": 80 }\nPUT /api/brightness { \"level\": 50 } → { \"success\": true }\n\nThread-safe device access via Mutex.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.725990551Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.742484065Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-xjo","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.742385780Z","created_by":"ubuntu"}]}
{"id":"bd-ylj","title":"EPIC: Connection Health Monitoring with Auto-Reconnect","description":"## Overview\n**Rank: #3 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDetect USB disconnection/reconnection and handle it gracefully. Add `--retry` flag for commands and robust reconnection in `sd watch` for long-running usage.\n\n## Problem Statement\nStream Decks can disconnect unexpectedly due to:\n- USB power issues (especially on hubs)\n- System sleep/wake cycles\n- USB hub resets\n- Physical cable issues\n- Driver glitches\n\nCurrently, the CLI just fails with a USB error. Users must manually re-run commands. This is especially problematic for:\n- `sd watch` which is designed for long-running event streaming\n- AI agents that expect reliable operation without crash-restart loops\n- Automated scripts that run unattended\n\n## Solution\nIntelligent connection management with configurable retry behavior:\n```bash\n# Retry on connection failure\nsd brightness 50 --retry 3 --retry-delay 1000\n\n# Watch mode with auto-reconnect\nsd watch --reconnect --reconnect-delay 2000\n\n# Monitor connection health\nsd monitor --health-check-interval 5000\n```\n\n## Why This Is #3 Priority\n1. **Real pain point**: USB flakiness is common, especially with hubs\n2. **Essential for `sd watch`**: Long-running monitoring needs resilience\n3. **Robot-mode critical**: Agents need robust operation, not crash loops\n4. **Invisible quality**: Users dont notice it working, but definitely notice failures\n\n## Implementation Approach\n\n### Phase 1: Retry Logic for Single Commands\n```rust\n// In src/device.rs\npub struct ConnectionOptions {\n    pub max_retries: u32,\n    pub retry_delay: Duration,\n    pub backoff_factor: f32,  // Exponential backoff\n}\n\nimpl Device {\n    pub fn open_with_retry(\n        serial: Option<&str>, \n        opts: &ConnectionOptions\n    ) -> Result<Self> {\n        let mut delay = opts.retry_delay;\n        \n        for attempt in 1..=opts.max_retries {\n            match Self::open(serial) {\n                Ok(dev) => return Ok(dev),\n                Err(e) if e.is_connection_error() && attempt < opts.max_retries => {\n                    eprintln!(\"Connection failed, retrying in {:?}...\", delay);\n                    std::thread::sleep(delay);\n                    delay = Duration::from_secs_f32(\n                        delay.as_secs_f32() * opts.backoff_factor\n                    );\n                }\n                Err(e) => return Err(e),\n            }\n        }\n        unreachable!()\n    }\n}\n```\n\n### Phase 2: Auto-Reconnect for Watch Mode\n```rust\n// In main.rs, watch command\nfn cmd_watch(opts: WatchOptions) -> Result<()> {\n    let mut device = Device::open_with_retry(opts.serial, &opts.connection)?;\n    \n    loop {\n        match device.read_input(opts.timeout) {\n            Ok(Some(event)) => emit_event(&event, opts.robot),\n            Ok(None) => continue,  // Timeout, no event\n            Err(e) if e.is_connection_error() && opts.reconnect => {\n                emit_disconnected(opts.robot);\n                device = reconnect_with_backoff(&opts)?;\n                emit_reconnected(opts.robot);\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n\nfn reconnect_with_backoff(opts: &WatchOptions) -> Result<Device> {\n    let mut delay = opts.reconnect_delay;\n    loop {\n        std::thread::sleep(delay);\n        match Device::open(opts.serial) {\n            Ok(dev) => return Ok(dev),\n            Err(_) => {\n                delay = std::cmp::min(\n                    delay * 2,\n                    Duration::from_secs(30)  // Max backoff\n                );\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Connection Health Events\n```json\n// Robot mode output for connection events\n{\"event\": \"disconnected\", \"timestamp\": \"...\", \"reason\": \"usb_error\"}\n{\"event\": \"reconnecting\", \"attempt\": 1, \"delay_ms\": 2000}\n{\"event\": \"reconnected\", \"timestamp\": \"...\", \"downtime_ms\": 4500}\n```\n\n## Key Design Decisions\n1. **Exponential backoff**: Prevents USB flood during recovery\n2. **Maximum backoff cap**: 30 seconds max to balance responsiveness\n3. **Explicit opt-in**: `--retry` and `--reconnect` flags, not default behavior\n4. **Event emission**: Connection state changes are reported in robot mode\n5. **Graceful degradation**: Single commands fail fast by default, long-running commands are resilient\n\n## Error Classification\nNeed to distinguish connection errors from other errors:\n```rust\nimpl SdError {\n    pub fn is_connection_error(&self) -> bool {\n        matches!(self, \n            SdError::DeviceNotFound |\n            SdError::UsbError(_) |\n            SdError::DeviceDisconnected\n        )\n    }\n}\n```\n\n## Success Criteria\n- [ ] `--retry N` flag retries failed connections N times\n- [ ] `--retry-delay MS` controls initial retry delay\n- [ ] `sd watch --reconnect` automatically reconnects on disconnect\n- [ ] Connection events emitted in robot mode JSON\n- [ ] Exponential backoff prevents USB flooding\n- [ ] Maximum backoff prevents infinite slow retries\n- [ ] Works correctly across sleep/wake cycles\n\n## Files to Modify\n- `src/cli/mod.rs`: Add retry/reconnect flags to relevant commands\n- `src/device.rs`: Add open_with_retry and connection options\n- `src/error.rs`: Add is_connection_error classification\n- `src/main.rs`: Update command handlers to use retry logic\n\n## Dependencies\nNone - enhances existing functionality\n\n## Estimated Subtasks\n1. Add error classification (is_connection_error)\n2. Implement open_with_retry in device.rs\n3. Add --retry and --retry-delay CLI flags\n4. Update single commands to use retry logic\n5. Implement auto-reconnect for watch command\n6. Add connection event emission for robot mode\n7. Implement exponential backoff with cap\n8. Test across sleep/wake cycles\n9. Write integration tests","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:10:27.991892800Z","created_by":"ubuntu","updated_at":"2026-01-19T18:10:28.031775261Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","priority-3","reliability","usb"]}
{"id":"bd-ym1","title":"Implement diff command","description":"Implement sd diff <config.yaml>:\n- Load current state (from session or device)\n- Load config file\n- Compare and show differences\n- Format: \"Key 0: (empty) → ~/icons/chrome.png\"\n\nNote: Requires state tracking from SAVE-RESTORE epic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:58.847465402Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:58.864068762Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-ym1","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.863954908Z","created_by":"ubuntu"}]}
{"id":"bd-zcq","title":"Add --rate-limit CLI flag","description":"Add to relevant commands:\n- --rate-limit <MS>: Minimum interval between operations\n\nApply to: set-keys (batch), fill-all, future bulk commands.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:19.669438641Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:19.683910799Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zcq","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:19.683856817Z","created_by":"ubuntu"}]}
{"id":"bd-zg7","title":"Add notify dependency for file watching","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nnotify = \"6\"\n```\n\nThis is the standard Rust crate for cross-platform file system notifications.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.503911483Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:33.533933589Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zg7","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.533892311Z","created_by":"ubuntu"}]}
{"id":"bd-znw","title":"Add installation instructions to help text","description":"Update completions command help to include installation instructions:\n- Bash: ~/.local/share/bash-completion/completions/sd\n- Zsh: ~/.zfunc/_sd (ensure fpath includes this)\n- Fish: ~/.config/fish/completions/sd.fish\n- PowerShell: >> $PROFILE","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.289760717Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:00.299742470Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-znw","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.299695742Z","created_by":"ubuntu"}]}
