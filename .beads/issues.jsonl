{"id":"bd-10c","title":"Add --exec, --on-press, --on-release flags to CLI","description":"Add to Watch command in src/cli/mod.rs:\n- --exec <CMD>: Command for any key event ({key} substituted)\n- --on-press <CMD>: Command for press events only\n- --on-release <CMD>: Command for release events only\n- --exec-timeout <MS>: Timeout for command execution (default: 5000)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.286502630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.315959421Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10c","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.315913896Z","created_by":"ubuntu"}]}
{"id":"bd-10v","title":"Add --no-open flag to serve","description":"By default, open browser to http://localhost:PORT\nWith --no-open, just print URL and dont open browser.\n\nUseful for headless/server scenarios.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.079956565Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:51.093955392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10v","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.093899026Z","created_by":"ubuntu"}]}
{"id":"bd-117","title":"Implement diff-based apply","description":"Only apply changes:\n1. Track previous ConfigState\n2. Load new config\n3. Compute diff (changed keys, brightness)\n4. Apply only changed items\n5. Update tracked state\n\nMore efficient than full re-apply.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.675738818Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.688270112Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-117","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.688223104Z","created_by":"ubuntu"}]}
{"id":"bd-11p","title":"Build frontend JavaScript logic","description":"Create static/app.js:\n- Fetch and display device info\n- Handle image drag-and-drop\n- Brightness slider updates\n- WebSocket for live events\n- Color picker integration","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:48.733315351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:48.749847778Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-11p","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:48.749796221Z","created_by":"ubuntu"}]}
{"id":"bd-123","title":"Test with various editors","description":"Manual testing:\n- VSCode (may write temp files)\n- Vim (backup then write)\n- nano (direct write)\n- sed -i (replace)\n\nEnsure debouncing handles each pattern.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.860516467Z","created_by":"ubuntu","updated_at":"2026-01-19T18:39:15.190193039Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-123","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:15.190158744Z","created_by":"ubuntu"},{"issue_id":"bd-123","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.870801802Z","created_by":"ubuntu"}]}
{"id":"bd-13e","title":"Add font rendering dependencies","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nab_glyph = \"0.2\"      # Modern font rendering\nimageproc = \"0.23\"    # Drawing on images\n```\n\nab_glyph is preferred over rusttype for better performance.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:13.794603556Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:13.823919262Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-13e","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:13.823857295Z","created_by":"ubuntu"}]}
{"id":"bd-156","title":"EPIC: Scripting Hooks on Key Press","description":"## Overview\n**Rank: #8 of 15** | **Impact: High** | **Effort: Low** | **Confidence: Medium-High**\n\nRun shell commands when Stream Deck buttons are pressed, making the device an automation trigger.\n\n## Problem Statement\nCurrently `sd watch` just reports button events to stdout. Users must:\n- Parse the JSON output in another script\n- Build their own event loop\n- Handle the complexity of process management\n\nThis makes the device a passive reporter rather than an active automation tool.\n\n## Solution\nExecute shell commands directly on key press:\n```bash\n# Simple: run a script per key\nsd watch --exec \"~/scripts/key-{key}.sh\"\n\n# Inline command with key substitution\nsd watch --on-press \"notify-send \\\"Key {key} pressed\\\"\"\n\n# Different commands for press vs release\nsd watch \\\n  --on-press \"echo pressed {key}\" \\\n  --on-release \"echo released {key}\"\n\n# With a command map file\nsd watch --keymap ~/keymap.yaml\n```\n\nKeymap file format:\n```yaml\n# ~/keymap.yaml\nkeys:\n  0:\n    press: open -a \"Google Chrome\"\n    release: null  # Optional\n  1:\n    press: osascript -e \"tell application \\\"Spotify\\\" to playpause\"\n  2:\n    press: ~/scripts/toggle-mic.sh\n  \n  # Range with pattern\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\n## Why This Is #8 Priority\n1. **Makes device useful**: Transforms from reporter to automation trigger\n2. **Unix philosophy**: Compose with existing tools, dont reinvent\n3. **Agent-friendly**: AI agents can wire up arbitrary actions\n4. **Low implementation effort**: Fork/exec in watch loop is straightforward\n5. **Immediate value**: Users can automate without writing custom code\n\n## Implementation Approach\n\n### Phase 1: Simple --exec Flag\n```rust\n// In src/cli/mod.rs\nWatch {\n    /// Command to execute on key press ({key} = key index)\n    #[arg(long)]\n    exec: Option<String>,\n    \n    /// Command for press events\n    #[arg(long)]\n    on_press: Option<String>,\n    \n    /// Command for release events  \n    #[arg(long)]\n    on_release: Option<String>,\n    \n    /// Keymap configuration file\n    #[arg(long)]\n    keymap: Option<PathBuf>,\n    \n    /// Timeout for command execution (ms)\n    #[arg(long, default_value = \"5000\")]\n    exec_timeout: u64,\n    \n    // ... existing flags\n}\n\n// In main.rs\nfn cmd_watch(device: &Device, opts: WatchOptions) -> Result<()> {\n    loop {\n        if let Some(event) = device.read_input(opts.timeout)? {\n            // Always emit the event (for robot mode consumers)\n            emit_event(&event, opts.robot);\n            \n            // Execute hooks if configured\n            if let Some(cmd) = resolve_command(&opts, &event) {\n                execute_hook(&cmd, opts.exec_timeout)?;\n            }\n        }\n    }\n}\n\nfn resolve_command(opts: &WatchOptions, event: &KeyEvent) -> Option<String> {\n    // Priority: keymap > on_press/on_release > exec\n    if let Some(keymap) = &opts.keymap {\n        return keymap.get_command(event.key, event.pressed);\n    }\n    \n    let template = match event.pressed {\n        true => opts.on_press.as_ref().or(opts.exec.as_ref()),\n        false => opts.on_release.as_ref(),\n    };\n    \n    template.map(|t| t.replace(\"{key}\", &event.key.to_string()))\n}\n\nfn execute_hook(cmd: &str, timeout_ms: u64) -> Result<()> {\n    use std::process::Command;\n    \n    let child = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .spawn()?;\n    \n    // Non-blocking: dont wait for completion\n    // Or with timeout if configured\n    Ok(())\n}\n```\n\n### Phase 2: Keymap File Support\n```rust\n// In src/config/keymap.rs (new file)\n#[derive(Debug, Deserialize)]\npub struct Keymap {\n    pub keys: HashMap<KeySelector, KeyActions>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct KeyActions {\n    pub press: Option<String>,\n    pub release: Option<String>,\n}\n\nimpl Keymap {\n    pub fn load(path: &Path) -> Result<Self> {\n        let content = std::fs::read_to_string(path)?;\n        Ok(serde_yaml::from_str(&content)?)\n    }\n    \n    pub fn get_command(&self, key: u8, pressed: bool) -> Option<String> {\n        for (selector, actions) in &self.keys {\n            if selector.matches(key) {\n                let template = if pressed { &actions.press } else { &actions.release };\n                return template.as_ref().map(|t| \n                    t.replace(\"{key}\", &key.to_string())\n                );\n            }\n        }\n        None\n    }\n}\n```\n\n## Security Considerations\n1. **No shell injection from device**: Key index is always a number\n2. **User-provided commands only**: We execute what the user configured\n3. **Timeout protection**: Prevent runaway commands\n4. **Non-blocking execution**: Dont block the event loop on slow commands\n5. **Error isolation**: Command failure doesnt crash watch mode\n\n## Key Design Decisions\n1. **Shell execution via sh -c**: Allows pipes, redirects, etc.\n2. **Non-blocking by default**: Fire-and-forget for responsiveness\n3. **{key} substitution**: Simple, predictable placeholder\n4. **Keymap file optional**: Simple use cases dont need files\n5. **Press/release separation**: Different actions for different events\n\n## Robot Mode Integration\n```json\n// Events include hook execution status\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"timestamp\": \"...\",\n  \"hook\": {\n    \"command\": \"~/scripts/key-05.sh\",\n    \"status\": \"started\",\n    \"pid\": 12345\n  }\n}\n\n// Optionally report completion\n{\n  \"event\": \"hook_completed\",\n  \"key\": 5,\n  \"pid\": 12345,\n  \"exit_code\": 0,\n  \"duration_ms\": 150\n}\n```\n\n## Success Criteria\n- [ ] `--exec` flag runs command on any key press\n- [ ] `--on-press` and `--on-release` for event-specific commands\n- [ ] `{key}` placeholder substituted correctly\n- [ ] `--keymap` loads YAML keymap file\n- [ ] Commands execute non-blocking\n- [ ] Timeout prevents runaway commands\n- [ ] Robot mode reports hook execution\n- [ ] Command errors dont crash watch mode\n\n## Files to Create/Modify\n- `src/cli/mod.rs`: Add exec flags to Watch command\n- `src/main.rs`: Implement hook execution in watch loop\n- `src/config/keymap.rs`: New keymap file support\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for keymap schema consistency\n\n## Estimated Subtasks\n1. Add --exec, --on-press, --on-release flags to CLI\n2. Implement command template substitution\n3. Implement non-blocking command execution\n4. Add timeout support for commands\n5. Implement keymap file loading\n6. Integrate hook execution into watch loop\n7. Add robot mode hook status reporting\n8. Handle command errors gracefully\n9. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:18:49.274948425Z","created_by":"ubuntu","updated_at":"2026-01-19T18:18:49.313818630Z","compaction_level":0,"original_size":0,"labels":["automation","priority-8","scripting","watch"]}
{"id":"bd-15d","title":"Add test coverage reporting with tarpaulin","description":"## Purpose\nTrack and enforce test coverage metrics.\n\n## Setup\n```toml\n# Cargo.toml\n[dev-dependencies]\n# ... existing\n\n# .github/workflows/ci.yml (for reference)\n# - cargo install cargo-tarpaulin\n# - cargo tarpaulin --out Html --out Lcov\n```\n\n## Configuration\n```toml\n# tarpaulin.toml\n[default]\nrun-types = [\"Tests\"]\nskip-clean = true\nverbose = true\nall-features = false\nworkspace = false\ntimeout = \"120s\"\nout = [\"Html\", \"Lcov\"]\noutput-dir = \"coverage\"\n\n# Exclude generated code and test utilities\nexclude-files = [\n    \"tests/*\",\n    \"build.rs\",\n]\n```\n\n## Usage\n```bash\n# Generate coverage report\ncargo tarpaulin\n\n# With specific target\ncargo tarpaulin --test integration\n\n# Enforce minimum coverage\ncargo tarpaulin --fail-under 70\n```\n\n## Success Criteria\n- [ ] tarpaulin configured and working\n- [ ] HTML report generated\n- [ ] Coverage badge available\n- [ ] CI integration documented\n- [ ] Minimum coverage threshold defined (suggest: 70%)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:52.660169348Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:52.670162573Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-15d","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:52.670102600Z","created_by":"ubuntu"}]}
{"id":"bd-169","title":"Implement KeyConfig parsing","description":"## Purpose\nImplement KeyConfig enum with serde deserialization for all configuration types (image, pattern, color, clear).\n\n## Implementation\n\n```rust\n// src/config/key_config.rs\nuse std::path::PathBuf;\nuse serde::{Deserialize, Serialize};\nuse crate::error::{Result, SdError};\n\n/// Configuration for a single key or key group\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum KeyConfig {\n    /// Static image from file path\n    Image {\n        image: PathBuf,\n        #[serde(default)]\n        label: Option<String>,  // Future: text overlay\n    },\n    \n    /// Pattern for batch key assignment\n    Pattern {\n        pattern: String,\n        #[serde(default)]\n        missing: MissingBehavior,\n    },\n    \n    /// Solid color fill\n    Color {\n        color: ColorSpec,\n    },\n    \n    /// Clear key (set to black)\n    Clear {\n        clear: bool,\n    },\n}\n\n/// How to handle missing pattern files\n#[derive(Debug, Clone, Default, Deserialize, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum MissingBehavior {\n    #[default]\n    Error,      // Fail if file missing\n    Skip,       // Leave key unchanged\n    Clear,      // Set to black\n}\n\n/// Color specification supporting multiple formats\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum ColorSpec {\n    /// Hex format: \"#FF5500\" or \"FF5500\"\n    Hex(String),\n    \n    /// RGB array: [255, 85, 0]\n    Rgb([u8; 3]),\n    \n    /// Named color: \"red\", \"blue\", etc.\n    Named(String),\n}\n\nimpl ColorSpec {\n    /// Parse to RGB values\n    pub fn to_rgb(&self) -> Result<(u8, u8, u8)> {\n        match self {\n            ColorSpec::Hex(hex) => parse_hex_color(hex),\n            ColorSpec::Rgb([r, g, b]) => Ok((*r, *g, *b)),\n            ColorSpec::Named(name) => named_color_to_rgb(name),\n        }\n    }\n    \n    /// Get normalized hex representation\n    pub fn to_hex(&self) -> Result<String> {\n        let (r, g, b) = self.to_rgb()?;\n        Ok(format!(\"#{:02X}{:02X}{:02X}\", r, g, b))\n    }\n}\n\nfn parse_hex_color(hex: &str) -> Result<(u8, u8, u8)> {\n    let hex = hex.trim_start_matches('#');\n    \n    if hex.len() != 6 {\n        return Err(SdError::ConfigParse(\n            format!(\"Invalid hex color '{}': expected 6 hex digits\", hex)\n        ));\n    }\n    \n    let r = u8::from_str_radix(&hex[0..2], 16)\n        .map_err(|_| SdError::ConfigParse(format!(\"Invalid red component in '{}'\", hex)))?;\n    let g = u8::from_str_radix(&hex[2..4], 16)\n        .map_err(|_| SdError::ConfigParse(format!(\"Invalid green component in '{}'\", hex)))?;\n    let b = u8::from_str_radix(&hex[4..6], 16)\n        .map_err(|_| SdError::ConfigParse(format!(\"Invalid blue component in '{}'\", hex)))?;\n    \n    Ok((r, g, b))\n}\n\nfn named_color_to_rgb(name: &str) -> Result<(u8, u8, u8)> {\n    match name.to_lowercase().as_str() {\n        \"black\" => Ok((0, 0, 0)),\n        \"white\" => Ok((255, 255, 255)),\n        \"red\" => Ok((255, 0, 0)),\n        \"green\" => Ok((0, 255, 0)),\n        \"blue\" => Ok((0, 0, 255)),\n        \"yellow\" => Ok((255, 255, 0)),\n        \"cyan\" => Ok((0, 255, 255)),\n        \"magenta\" => Ok((255, 0, 255)),\n        \"orange\" => Ok((255, 165, 0)),\n        \"purple\" => Ok((128, 0, 128)),\n        \"pink\" => Ok((255, 192, 203)),\n        \"gray\" | \"grey\" => Ok((128, 128, 128)),\n        _ => Err(SdError::ConfigParse(\n            format!(\"Unknown color name '{}'. Use hex (#FF5500) or RGB array [255, 85, 0]\", name)\n        )),\n    }\n}\n\nimpl KeyConfig {\n    /// Validate configuration\n    pub fn validate(&self) -> Result<()> {\n        match self {\n            KeyConfig::Image { image, .. } => {\n                // Path validation happens during resolution\n                if image.as_os_str().is_empty() {\n                    return Err(SdError::ConfigInvalid(\"Empty image path\".to_string()));\n                }\n                Ok(())\n            }\n            KeyConfig::Pattern { pattern, .. } => {\n                if !pattern.contains(\"{index}\") {\n                    return Err(SdError::ConfigInvalid(\n                        \"Pattern must contain {index} placeholder\".to_string()\n                    ));\n                }\n                Ok(())\n            }\n            KeyConfig::Color { color } => {\n                color.to_rgb()?; // Validates color spec\n                Ok(())\n            }\n            KeyConfig::Clear { clear } => {\n                if !clear {\n                    return Err(SdError::ConfigInvalid(\n                        \"clear: false is not allowed; omit the key instead\".to_string()\n                    ));\n                }\n                Ok(())\n            }\n        }\n    }\n    \n    /// Get human-readable description of this config\n    pub fn description(&self) -> String {\n        match self {\n            KeyConfig::Image { image, label } => {\n                let mut desc = format!(\"image: {}\", image.display());\n                if let Some(l) = label {\n                    desc.push_str(&format!(\" (label: {})\", l));\n                }\n                desc\n            }\n            KeyConfig::Pattern { pattern, .. } => format!(\"pattern: {}\", pattern),\n            KeyConfig::Color { color } => {\n                if let Ok(hex) = color.to_hex() {\n                    format!(\"color: {}\", hex)\n                } else {\n                    \"color: (invalid)\".to_string()\n                }\n            }\n            KeyConfig::Clear { .. } => \"clear\".to_string(),\n        }\n    }\n}\n\n/// Resolved key configuration (after path expansion)\n#[derive(Debug, Clone)]\npub enum ResolvedKey {\n    Image(PathBuf),\n    Color(u8, u8, u8),\n    Clear,\n}\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_parse_image_config() {\n        let yaml = r#\"image: ~/icons/test.png\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Image { image, label } => {\n                assert_eq!(image.to_str().unwrap(), \"~/icons/test.png\");\n                assert!(label.is_none());\n            }\n            _ => panic!(\"Expected Image config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_image_with_label() {\n        let yaml = r#\"\nimage: ~/icons/test.png\nlabel: My App\n\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Image { label, .. } => {\n                assert_eq!(label, Some(\"My App\".to_string()));\n            }\n            _ => panic!(\"Expected Image config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_pattern_config() {\n        let yaml = r#\"pattern: ~/icons/{index}.png\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Pattern { pattern, missing } => {\n                assert_eq!(pattern, \"~/icons/{index}.png\");\n                assert!(matches!(missing, MissingBehavior::Error));\n            }\n            _ => panic!(\"Expected Pattern config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_pattern_with_missing() {\n        let yaml = r#\"\npattern: ~/icons/{index}.png\nmissing: skip\n\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Pattern { missing, .. } => {\n                assert!(matches!(missing, MissingBehavior::Skip));\n            }\n            _ => panic!(\"Expected Pattern config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_color_hex() {\n        let yaml = r#\"color: \"#FF5500\"\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Color { color } => {\n                assert_eq!(color.to_rgb().unwrap(), (255, 85, 0));\n            }\n            _ => panic!(\"Expected Color config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_color_hex_no_hash() {\n        let yaml = r#\"color: \"FF5500\"\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Color { color } => {\n                assert_eq!(color.to_rgb().unwrap(), (255, 85, 0));\n            }\n            _ => panic!(\"Expected Color config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_color_rgb_array() {\n        let yaml = r#\"color: [255, 85, 0]\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Color { color } => {\n                assert_eq!(color.to_rgb().unwrap(), (255, 85, 0));\n            }\n            _ => panic!(\"Expected Color config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_color_named() {\n        let yaml = r#\"color: red\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        match config {\n            KeyConfig::Color { color } => {\n                assert_eq!(color.to_rgb().unwrap(), (255, 0, 0));\n            }\n            _ => panic!(\"Expected Color config\"),\n        }\n    }\n    \n    #[test]\n    fn test_parse_clear() {\n        let yaml = r#\"clear: true\"#;\n        let config: KeyConfig = serde_yaml::from_str(yaml).unwrap();\n        \n        assert!(matches!(config, KeyConfig::Clear { clear: true }));\n    }\n    \n    #[test]\n    fn test_validate_empty_image() {\n        let config = KeyConfig::Image { \n            image: PathBuf::from(\"\"), \n            label: None \n        };\n        assert!(config.validate().is_err());\n    }\n    \n    #[test]\n    fn test_validate_pattern_no_placeholder() {\n        let config = KeyConfig::Pattern {\n            pattern: \"~/icons/test.png\".to_string(),\n            missing: MissingBehavior::Error,\n        };\n        assert!(config.validate().is_err());\n    }\n    \n    #[test]\n    fn test_validate_invalid_color() {\n        // This tests that invalid hex colors fail\n        let result = parse_hex_color(\"GGGGGG\");\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_validate_clear_false() {\n        let config = KeyConfig::Clear { clear: false };\n        assert!(config.validate().is_err());\n    }\n    \n    #[test]\n    fn test_color_to_hex() {\n        let color = ColorSpec::Rgb([255, 85, 0]);\n        assert_eq!(color.to_hex().unwrap(), \"#FF5500\");\n        \n        let color = ColorSpec::Named(\"red\".to_string());\n        assert_eq!(color.to_hex().unwrap(), \"#FF0000\");\n    }\n    \n    #[test]\n    fn test_description() {\n        let img = KeyConfig::Image {\n            image: PathBuf::from(\"test.png\"),\n            label: Some(\"Test\".to_string()),\n        };\n        assert!(img.description().contains(\"test.png\"));\n        assert!(img.description().contains(\"Test\"));\n        \n        let color = KeyConfig::Color {\n            color: ColorSpec::Hex(\"#FF0000\".to_string()),\n        };\n        assert!(color.description().contains(\"#FF0000\"));\n    }\n    \n    #[test]\n    fn test_named_colors() {\n        let colors = vec![\n            (\"black\", (0, 0, 0)),\n            (\"white\", (255, 255, 255)),\n            (\"red\", (255, 0, 0)),\n            (\"green\", (0, 255, 0)),\n            (\"blue\", (0, 0, 255)),\n            (\"gray\", (128, 128, 128)),\n            (\"grey\", (128, 128, 128)),\n        ];\n        \n        for (name, expected) in colors {\n            assert_eq!(named_color_to_rgb(name).unwrap(), expected);\n        }\n    }\n    \n    #[test]\n    fn test_unknown_named_color() {\n        assert!(named_color_to_rgb(\"chartreuse\").is_err());\n    }\n}\n```\n\n## Success Criteria\n- [ ] All config types deserialize correctly from YAML\n- [ ] All config types deserialize correctly from TOML  \n- [ ] Hex colors parse with or without #\n- [ ] RGB arrays validate range (0-255)\n- [ ] Named colors resolve correctly\n- [ ] Validation catches invalid configurations\n- [ ] Error messages are helpful\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Config parsing attempts\n- DEBUG: Resolved color values\n- INFO: (none)\n- WARN: Unknown named colors\n- ERROR: Parse failures with context","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.342822871Z","created_by":"ubuntu","updated_at":"2026-01-19T21:41:24.192674431Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-169","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.357886824Z","created_by":"ubuntu"}]}
{"id":"bd-16u","title":"Write tests for export functionality","description":"## Test Coverage for Export to Shell Script\n\n### Unit Tests - Bash Export\n\n1. **Empty Session Tests**\n   - No state = minimal script with shebang only\n   - No brightness set = no brightness command\n   - No keys set = no set-key commands\n   - Shebang and set -e present by default\n\n2. **Brightness Export Tests**\n   - Brightness 0 exported correctly\n   - Brightness 100 exported correctly\n   - Brightness 50 with --serial flag\n   - Only most recent brightness (not history)\n\n3. **Key Image Export Tests**\n   - Image paths exported correctly\n   - Multiple images in key order\n   - Paths with spaces quoted correctly\n   - Paths with quotes escaped correctly\n   - Paths with shell specials ($, `, !) escaped\n   - Absolute paths by default\n   - Relative paths with --relative flag\n\n4. **Key Color Export Tests**\n   - Hex colors exported: #FF5500\n   - Named colors converted: \"red\" → \"#FF0000\"\n   - RGB format preserved or converted\n   - Mixed images and colors ordered correctly\n\n5. **Clear Key Export Tests**\n   - Cleared keys generate clear-key commands\n   - Clear-all if all keys cleared\n   - Interleaved with set commands\n\n6. **Command Ordering Tests**\n   - Brightness first (device setup)\n   - Then key operations (set, fill, clear)\n   - Consistent ordering for reproducibility\n   - Keys sorted by index\n\n### Unit Tests - Path Handling\n\n7. **Special Character Tests**\n   - Space: `/path/my image.png` → `\"/path/my image.png\"`\n   - Quote: `/path/\"quoted\".png` → `\"/path/\\\"quoted\\\".png\"`\n   - Dollar: `/path/$var.png` → `\"/path/\\$var.png\"`\n   - Backtick: `/path/\\`cmd\\`.png` → `\"/path/\\\\\\`cmd\\\\\\`.png\"`\n   - Newline in filename (edge case)\n   - Unicode paths preserved correctly\n\n8. **Absolute vs Relative Paths**\n   - Default: absolute paths\n   - --relative: paths relative to script location\n   - --relative + --embed: irrelevant (embedded)\n   - Symlinks followed for absolute\n\n### Unit Tests - Base64 Embedding\n\n9. **Embed Mode Tests**\n   - Image data base64 encoded inline\n   - Script decodes and pipes to sd\n   - Valid base64 that decodes correctly\n   - Large images (1MB) work without issue\n   - Multiple images each embedded separately\n\n10. **Embed Script Structure**\n    - Uses heredoc for cleanliness\n    - Or inline base64 with pipe\n    - Comments indicate original path\n    - Script works on fresh system (no deps)\n\n### Integration Tests\n\n11. **Roundtrip Tests**\n    - Set up device state\n    - Export to script\n    - Clear device\n    - Run script\n    - Verify state restored exactly\n\n12. **Cross-Device Tests**\n    - Export from XL\n    - Run on Mini (fails gracefully for out-of-range keys)\n    - Warning for key mismatch\n\n### E2E Tests\n\n13. **CLI Output Tests**\n    - `sd export bash` outputs to stdout\n    - `sd export bash -o script.sh` writes to file\n    - `sd export bash --embed` includes base64 data\n    - `sd export bash --serial ABC123` includes serial flag\n\n14. **Shell Execution Tests**\n    - Generated script passes shellcheck\n    - Generated script passes bash -n (syntax check)\n    - Script runs without error on test system\n    - Script is idempotent (run twice = same result)\n\n### Fish/PowerShell Export Tests\n\n15. **Fish Shell Export**\n    - set -x for variables\n    - Command substitution with ()\n    - Proper string quoting rules\n    - Tested with fish --no-execute\n\n16. **PowerShell Export**\n    - Param() block for parameters\n    - $ErrorActionPreference = \"Stop\"\n    - Proper string quoting rules\n    - Tested with pwsh -NoExecute\n\n### Logging Requirements\n- TRACE: Each command added to script, path escaping decisions\n- DEBUG: Export options, file counts\n- INFO: Export started/completed, output location\n- WARN: Missing source images (referenced but not found)\n- ERROR: Write failures, invalid state","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.979294395Z","created_by":"ubuntu","updated_at":"2026-01-19T21:07:18.644852414Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-16u","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:03.246254901Z","created_by":"ubuntu"},{"issue_id":"bd-16u","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.996155501Z","created_by":"ubuntu"},{"issue_id":"bd-16u","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:09.298328669Z","created_by":"ubuntu"}]}
{"id":"bd-17e","title":"Add robot mode hook status reporting","description":"Emit hook execution in robot mode:\n```json\n{\n  \"event\": \"key_press\",\n  \"key\": 5,\n  \"hook\": {\"command\": \"...\", \"status\": \"started\", \"pid\": 12345}\n}\n```\n\nOptionally report completion/timeout.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.271293808Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.283235562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-17e","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.283150772Z","created_by":"ubuntu"}]}
{"id":"bd-180","title":"Implement MockDevice for unit testing","description":"## Purpose\nCreate a mock device implementation that records operations and allows assertions in unit tests.\n\n## Implementation\n\\`\\`\\`rust\n// src/device/mock.rs\nuse std::collections::{HashMap, VecDeque};\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\nuse async_trait::async_trait;\nuse tracing::{debug, trace, instrument};\n\nuse super::{DeviceOperations, DeviceInfo, DeviceModel, KeyEvent};\nuse crate::error::{Result, SdError};\n\n/// Recorded operation for assertions\n#[derive(Debug, Clone, PartialEq)]\npub enum Operation {\n    SetBrightness { level: u8 },\n    SetKeyImageRaw { key: u8, data_len: usize },\n    SetKeyImage { key: u8, path: String },\n    ClearKey { key: u8 },\n    ClearAllKeys,\n    FillKeyColor { key: u8, r: u8, g: u8, b: u8 },\n    ReadInput { timeout: Duration },\n    Flush,\n    Reset,\n}\n\n/// Configuration for mock behavior\n#[derive(Debug, Clone, Default)]\npub struct MockConfig {\n    /// Simulate latency for operations (useful for timing tests)\n    pub operation_latency: Option<Duration>,\n    /// Fail after N operations (for testing error recovery)\n    pub fail_after_ops: Option<usize>,\n    /// Specific keys that should fail\n    pub failing_keys: Vec<u8>,\n    /// Whether device is \"connected\"\n    pub connected: bool,\n}\n\n/// Mock device for testing\npub struct MockDevice {\n    info: DeviceInfo,\n    brightness: u8,\n    keys: HashMap<u8, KeyState>,\n    input_queue: VecDeque<KeyEvent>,\n    operation_log: Vec<Operation>,\n    error_injection: Option<SdError>,\n    config: MockConfig,\n    op_count: usize,\n}\n\n/// State of a key on the mock device\n#[derive(Debug, Clone)]\npub enum KeyState {\n    Clear,\n    Image(Vec<u8>),\n    Color { r: u8, g: u8, b: u8 },\n}\n\nimpl MockDevice {\n    /// Create a new mock device for the specified model\n    pub fn new(model: DeviceModel) -> Self {\n        let (cols, rows) = model.layout();\n        let (width, height) = model.key_dimensions();\n        \n        debug!(model = ?model, \"Creating mock device\");\n        \n        Self {\n            info: DeviceInfo {\n                model,\n                serial: format!(\"MOCK-{:?}-001\", model),\n                firmware: \"1.0.0-mock\".to_string(),\n                key_count: model.key_count(),\n                key_cols: cols,\n                key_rows: rows,\n                key_width: width,\n                key_height: height,\n            },\n            brightness: 100,\n            keys: HashMap::new(),\n            input_queue: VecDeque::new(),\n            operation_log: Vec::new(),\n            error_injection: None,\n            config: MockConfig { connected: true, ..Default::default() },\n            op_count: 0,\n        }\n    }\n    \n    /// Create mock for Stream Deck XL (most common for testing)\n    pub fn xl() -> Self {\n        Self::new(DeviceModel::XL)\n    }\n    \n    /// Create mock for Stream Deck Mini\n    pub fn mini() -> Self {\n        Self::new(DeviceModel::Mini)\n    }\n    \n    /// Create mock for Stream Deck MK2\n    pub fn mk2() -> Self {\n        Self::new(DeviceModel::MK2)\n    }\n    \n    // === Test Configuration ===\n    \n    /// Configure mock behavior\n    pub fn with_config(mut self, config: MockConfig) -> Self {\n        self.config = config;\n        self\n    }\n    \n    /// Inject an error for the next operation\n    pub fn inject_error(&mut self, error: SdError) {\n        self.error_injection = Some(error);\n    }\n    \n    /// Clear injected error\n    pub fn clear_error(&mut self) {\n        self.error_injection = None;\n    }\n    \n    /// Queue a key event for read_input to return\n    pub fn queue_input(&mut self, event: KeyEvent) {\n        self.input_queue.push_back(event);\n    }\n    \n    /// Queue multiple key events\n    pub fn queue_inputs(&mut self, events: impl IntoIterator<Item = KeyEvent>) {\n        self.input_queue.extend(events);\n    }\n    \n    /// Simulate a key press\n    pub fn simulate_press(&mut self, key: u8) {\n        self.queue_input(KeyEvent {\n            key,\n            pressed: true,\n            timestamp: Instant::now(),\n        });\n    }\n    \n    /// Simulate a key release\n    pub fn simulate_release(&mut self, key: u8) {\n        self.queue_input(KeyEvent {\n            key,\n            pressed: false,\n            timestamp: Instant::now(),\n        });\n    }\n    \n    /// Simulate a complete tap (press + release)\n    pub fn simulate_tap(&mut self, key: u8) {\n        self.simulate_press(key);\n        self.simulate_release(key);\n    }\n    \n    /// Set device as disconnected\n    pub fn disconnect(&mut self) {\n        self.config.connected = false;\n    }\n    \n    /// Set device as connected\n    pub fn reconnect(&mut self) {\n        self.config.connected = true;\n    }\n    \n    // === Assertions ===\n    \n    /// Get all recorded operations\n    pub fn operations(&self) -> &[Operation] {\n        &self.operation_log\n    }\n    \n    /// Get operations of a specific type\n    pub fn operations_of_type<F>(&self, filter: F) -> Vec<&Operation>\n    where\n        F: Fn(&Operation) -> bool,\n    {\n        self.operation_log.iter().filter(|op| filter(op)).collect()\n    }\n    \n    /// Assert specific operations were performed\n    pub fn assert_operations(&self, expected: &[Operation]) {\n        assert_eq!(\n            self.operation_log, expected,\n            \"Operation mismatch.\\nExpected: {:#?}\\nActual: {:#?}\",\n            expected, self.operation_log\n        );\n    }\n    \n    /// Assert no operations were performed\n    pub fn assert_no_operations(&self) {\n        assert!(\n            self.operation_log.is_empty(),\n            \"Expected no operations, but found: {:#?}\",\n            self.operation_log\n        );\n    }\n    \n    /// Get the image data for a specific key\n    pub fn get_key_state(&self, key: u8) -> Option<&KeyState> {\n        self.keys.get(&key)\n    }\n    \n    /// Assert key has specific image data\n    pub fn assert_key_has_image(&self, key: u8) {\n        match self.keys.get(&key) {\n            Some(KeyState::Image(_)) => {}\n            other => panic!(\"Key {} expected to have image, but has: {:?}\", key, other),\n        }\n    }\n    \n    /// Assert key has specific color\n    pub fn assert_key_color(&self, key: u8, r: u8, g: u8, b: u8) {\n        match self.keys.get(&key) {\n            Some(KeyState::Color { r: kr, g: kg, b: kb }) if *kr == r && *kg == g && *kb == b => {}\n            other => panic!(\n                \"Key {} expected color ({}, {}, {}), but has: {:?}\",\n                key, r, g, b, other\n            ),\n        }\n    }\n    \n    /// Assert key is cleared\n    pub fn assert_key_cleared(&self, key: u8) {\n        match self.keys.get(&key) {\n            None | Some(KeyState::Clear) => {}\n            other => panic!(\"Key {} expected to be cleared, but has: {:?}\", key, other),\n        }\n    }\n    \n    /// Get current brightness\n    pub fn brightness(&self) -> u8 {\n        self.brightness\n    }\n    \n    /// Clear operation log for fresh assertions\n    pub fn clear_operations(&mut self) {\n        self.operation_log.clear();\n        self.op_count = 0;\n    }\n    \n    // === Internal Helpers ===\n    \n    fn record_op(&mut self, op: Operation) {\n        trace!(operation = ?op, \"Recording operation\");\n        self.operation_log.push(op);\n        self.op_count += 1;\n    }\n    \n    fn check_error(&mut self) -> Result<()> {\n        // Check for injected error\n        if let Some(error) = self.error_injection.take() {\n            return Err(error);\n        }\n        \n        // Check for connection\n        if !self.config.connected {\n            return Err(SdError::DeviceNotFound);\n        }\n        \n        // Check for fail_after_ops\n        if let Some(limit) = self.config.fail_after_ops {\n            if self.op_count >= limit {\n                return Err(SdError::Other(\"Mock failure after ops limit\".to_string()));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    fn check_key_error(&self, key: u8) -> Result<()> {\n        if self.config.failing_keys.contains(&key) {\n            return Err(SdError::Other(format!(\"Mock key {} configured to fail\", key)));\n        }\n        if key >= self.info.key_count {\n            return Err(SdError::InvalidKey(key));\n        }\n        Ok(())\n    }\n    \n    async fn maybe_delay(&self) {\n        if let Some(delay) = self.config.operation_latency {\n            tokio::time::sleep(delay).await;\n        }\n    }\n}\n\n#[async_trait]\nimpl DeviceOperations for MockDevice {\n    fn info(&self) -> &DeviceInfo {\n        &self.info\n    }\n    \n    fn is_connected(&self) -> bool {\n        self.config.connected\n    }\n    \n    #[instrument(skip(self))]\n    async fn set_brightness(&mut self, level: u8) -> Result<()> {\n        self.check_error()?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::SetBrightness { level });\n        self.brightness = level.min(100);\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self, image_data))]\n    async fn set_key_image_raw(&mut self, key: u8, image_data: &[u8]) -> Result<()> {\n        self.check_error()?;\n        self.check_key_error(key)?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::SetKeyImageRaw {\n            key,\n            data_len: image_data.len(),\n        });\n        self.keys.insert(key, KeyState::Image(image_data.to_vec()));\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn set_key_image(&mut self, key: u8, path: &std::path::Path) -> Result<()> {\n        self.check_error()?;\n        self.check_key_error(key)?;\n        self.maybe_delay().await;\n        \n        // In mock, we just record the path - don't actually load the image\n        self.record_op(Operation::SetKeyImage {\n            key,\n            path: path.display().to_string(),\n        });\n        \n        // Simulate having an image (empty data for mock)\n        self.keys.insert(key, KeyState::Image(vec![]));\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn clear_key(&mut self, key: u8) -> Result<()> {\n        self.check_error()?;\n        self.check_key_error(key)?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::ClearKey { key });\n        self.keys.insert(key, KeyState::Clear);\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn clear_all_keys(&mut self) -> Result<()> {\n        self.check_error()?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::ClearAllKeys);\n        for key in 0..self.info.key_count {\n            self.keys.insert(key, KeyState::Clear);\n        }\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn fill_key_color(&mut self, key: u8, r: u8, g: u8, b: u8) -> Result<()> {\n        self.check_error()?;\n        self.check_key_error(key)?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::FillKeyColor { key, r, g, b });\n        self.keys.insert(key, KeyState::Color { r, g, b });\n        \n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn read_input(&mut self, timeout: Duration) -> Result<Option<KeyEvent>> {\n        self.check_error()?;\n        \n        self.record_op(Operation::ReadInput { timeout });\n        \n        // Return queued event if available\n        if let Some(event) = self.input_queue.pop_front() {\n            return Ok(Some(event));\n        }\n        \n        // Simulate timeout\n        if timeout > Duration::ZERO {\n            tokio::time::sleep(timeout.min(Duration::from_millis(10))).await;\n        }\n        \n        Ok(None)\n    }\n    \n    #[instrument(skip(self))]\n    async fn flush(&mut self) -> Result<()> {\n        self.check_error()?;\n        self.record_op(Operation::Flush);\n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    async fn reset(&mut self) -> Result<()> {\n        self.check_error()?;\n        self.maybe_delay().await;\n        \n        self.record_op(Operation::Reset);\n        self.brightness = 100;\n        self.keys.clear();\n        \n        Ok(())\n    }\n}\n\n/// Builder for creating MockDevice with common configurations\npub struct MockDeviceBuilder {\n    model: DeviceModel,\n    config: MockConfig,\n    initial_brightness: u8,\n    queued_inputs: Vec<KeyEvent>,\n}\n\nimpl MockDeviceBuilder {\n    pub fn new(model: DeviceModel) -> Self {\n        Self {\n            model,\n            config: MockConfig { connected: true, ..Default::default() },\n            initial_brightness: 100,\n            queued_inputs: Vec::new(),\n        }\n    }\n    \n    pub fn xl() -> Self {\n        Self::new(DeviceModel::XL)\n    }\n    \n    pub fn with_latency(mut self, latency: Duration) -> Self {\n        self.config.operation_latency = Some(latency);\n        self\n    }\n    \n    pub fn fail_after(mut self, ops: usize) -> Self {\n        self.config.fail_after_ops = Some(ops);\n        self\n    }\n    \n    pub fn with_failing_keys(mut self, keys: Vec<u8>) -> Self {\n        self.config.failing_keys = keys;\n        self\n    }\n    \n    pub fn disconnected(mut self) -> Self {\n        self.config.connected = false;\n        self\n    }\n    \n    pub fn with_brightness(mut self, level: u8) -> Self {\n        self.initial_brightness = level;\n        self\n    }\n    \n    pub fn with_queued_inputs(mut self, inputs: Vec<KeyEvent>) -> Self {\n        self.queued_inputs = inputs;\n        self\n    }\n    \n    pub fn build(self) -> MockDevice {\n        let mut device = MockDevice::new(self.model).with_config(self.config);\n        device.brightness = self.initial_brightness;\n        device.input_queue = self.queued_inputs.into();\n        device\n    }\n}\n\\`\\`\\`\n\n## Unit Tests for MockDevice Itself\n\\`\\`\\`rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_set_brightness() {\n        let mut mock = MockDevice::xl();\n        mock.set_brightness(50).await.unwrap();\n        \n        assert_eq!(mock.brightness(), 50);\n        mock.assert_operations(&[Operation::SetBrightness { level: 50 }]);\n    }\n    \n    #[tokio::test]\n    async fn test_set_key_image() {\n        let mut mock = MockDevice::xl();\n        mock.set_key_image(5, std::path::Path::new(\"/test/image.png\")).await.unwrap();\n        \n        mock.assert_key_has_image(5);\n        assert!(matches!(\n            mock.operations()[0],\n            Operation::SetKeyImage { key: 5, .. }\n        ));\n    }\n    \n    #[tokio::test]\n    async fn test_error_injection() {\n        let mut mock = MockDevice::xl();\n        mock.inject_error(SdError::DeviceNotFound);\n        \n        let result = mock.set_brightness(50).await;\n        assert!(result.is_err());\n    }\n    \n    #[tokio::test]\n    async fn test_input_queue() {\n        let mut mock = MockDevice::xl();\n        mock.simulate_tap(5);\n        \n        let event1 = mock.read_input(Duration::from_millis(100)).await.unwrap();\n        assert!(event1.is_some());\n        assert_eq!(event1.unwrap().key, 5);\n        assert!(event1.unwrap().pressed);\n        \n        let event2 = mock.read_input(Duration::from_millis(100)).await.unwrap();\n        assert!(event2.is_some());\n        assert!(!event2.unwrap().pressed);\n    }\n    \n    #[tokio::test]\n    async fn test_disconnected_device() {\n        let mut mock = MockDeviceBuilder::xl().disconnected().build();\n        \n        let result = mock.set_brightness(50).await;\n        assert!(matches!(result, Err(SdError::DeviceNotFound)));\n    }\n    \n    #[tokio::test]\n    async fn test_failing_keys() {\n        let mut mock = MockDeviceBuilder::xl()\n            .with_failing_keys(vec![5, 10])\n            .build();\n        \n        // Key 0 should work\n        mock.clear_key(0).await.unwrap();\n        \n        // Key 5 should fail\n        let result = mock.clear_key(5).await;\n        assert!(result.is_err());\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] MockDevice implements DeviceOperations trait (async)\n- [ ] Supports all device models (XL, Mini, MK2, etc.)\n- [ ] Records all operations for assertion\n- [ ] Provides convenient assertion helpers\n- [ ] Supports error injection (one-time and persistent)\n- [ ] Supports input event queuing and simulation\n- [ ] Supports latency simulation for timing tests\n- [ ] Builder pattern for complex configurations\n- [ ] Thread-safe for concurrent test execution\n\n## Logging Requirements\n- TRACE: Each operation recorded\n- DEBUG: Mock device creation, configuration\n- INFO: (none - tests shouldn't log at INFO)\n- WARN: (none)\n- ERROR: (none)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:49.917342512Z","created_by":"ubuntu","updated_at":"2026-01-21T11:29:52.209902747Z","closed_at":"2026-01-21T11:29:52.209814851Z","close_reason":"Implemented MockDevice with: DeviceOperations trait implementation, operation recording, assertion helpers (assert_operations, assert_key_color, etc.), error injection, disconnect/reconnect simulation, failing keys configuration, fail_after_ops, button state simulation, MockDeviceBuilder pattern. All 17 mock tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-180","depends_on_id":"bd-21o","type":"blocks","created_at":"2026-01-19T21:48:07.723281227Z","created_by":"ubuntu"},{"issue_id":"bd-180","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:49.928687102Z","created_by":"ubuntu"}]}
{"id":"bd-18h","title":"Integrate rate limiter into batch set-keys","description":"## Purpose\nIntegrate rate limiting into batch operations to prevent USB flooding on rapid operations.\n\n## Implementation\n\\`\\`\\`rust\n// src/batch.rs\nuse std::time::Duration;\nuse tracing::{debug, trace, info, instrument};\n\nuse crate::rate_limit::{RateLimiter, TokenBucket};\n\n/// Trait for rate limiting implementations\npub trait RateLimiting: Send {\n    /// Wait until operation is allowed (async)\n    async fn wait(&mut self);\n    \n    /// Check if operation is allowed (non-blocking)\n    fn check(&mut self) -> bool;\n    \n    /// Get status for robot mode\n    fn status(&mut self) -> RateLimitStatus;\n}\n\nimpl RateLimiting for RateLimiter {\n    async fn wait(&mut self) {\n        RateLimiter::wait(self).await\n    }\n    \n    fn check(&mut self) -> bool {\n        RateLimiter::check(self)\n    }\n    \n    fn status(&mut self) -> RateLimitStatus {\n        RateLimiter::status(self).into()\n    }\n}\n\nimpl RateLimiting for TokenBucket {\n    async fn wait(&mut self) {\n        TokenBucket::wait(self).await\n    }\n    \n    fn check(&mut self) -> bool {\n        TokenBucket::check(self)\n    }\n    \n    fn status(&mut self) -> RateLimitStatus {\n        TokenBucket::status(self).into()\n    }\n}\n\n/// Create appropriate rate limiter based on CLI flags\npub fn create_rate_limiter(rate_limit_ms: u64, burst: Option<usize>) -> Option<Box<dyn RateLimiting>> {\n    if rate_limit_ms == 0 {\n        trace!(\"Rate limiting disabled\");\n        return None;\n    }\n    \n    let interval = Duration::from_millis(rate_limit_ms);\n    \n    match burst {\n        Some(capacity) => {\n            let rate = 1000.0 / rate_limit_ms as f64;\n            debug!(\n                interval_ms = %rate_limit_ms,\n                burst_capacity = %capacity,\n                \"Using TokenBucket rate limiter\"\n            );\n            Some(Box::new(TokenBucket::new(capacity, rate)))\n        }\n        None => {\n            debug!(interval_ms = %rate_limit_ms, \"Using simple rate limiter\");\n            Some(Box::new(RateLimiter::new(interval)))\n        }\n    }\n}\n\n/// Execute batch set-keys with rate limiting\n#[instrument(skip(device, operations, rate_limiter), fields(op_count = %operations.len()))]\npub async fn execute_set_keys_batch(\n    device: &mut Device,\n    operations: Vec<SetKeyOperation>,\n    mut rate_limiter: Option<Box<dyn RateLimiting>>,\n    opts: &BatchOptions,\n) -> Result<BatchResult, BatchError> {\n    let mut results = Vec::with_capacity(operations.len());\n    let start = std::time::Instant::now();\n    \n    info!(count = %operations.len(), \"Starting batch set-keys operation\");\n    \n    for (i, op) in operations.iter().enumerate() {\n        let op_start = std::time::Instant::now();\n        let mut was_rate_limited = false;\n        let mut wait_time = Duration::ZERO;\n        \n        // Apply rate limiting\n        if let Some(ref mut limiter) = rate_limiter {\n            if !limiter.check() {\n                was_rate_limited = true;\n                let before_wait = std::time::Instant::now();\n                limiter.wait().await;\n                wait_time = before_wait.elapsed();\n                trace!(\n                    key = %op.key,\n                    waited_ms = %wait_time.as_millis(),\n                    \"Rate limit wait completed\"\n                );\n            }\n        }\n        \n        // Execute operation\n        let result = device.set_key_image(op.key, &op.image_data).await;\n        \n        let op_result = OperationResult {\n            key: op.key,\n            status: match &result {\n                Ok(_) => OperationStatus::Success,\n                Err(e) => OperationStatus::Failed(e.to_string()),\n            },\n            rate_limited: was_rate_limited,\n            wait_ms: wait_time.as_millis() as u64,\n            duration_ms: op_start.elapsed().as_millis() as u64,\n        };\n        \n        results.push(op_result);\n        \n        // Handle errors based on continue_on_error flag\n        if result.is_err() && !opts.continue_on_error {\n            return Err(BatchError::OperationFailed {\n                key: op.key,\n                source: result.unwrap_err(),\n            });\n        }\n        \n        // Progress callback\n        if let Some(ref callback) = opts.progress_callback {\n            callback(i + 1, operations.len());\n        }\n    }\n    \n    let total_duration = start.elapsed();\n    let successful = results.iter().filter(|r| r.status == OperationStatus::Success).count();\n    \n    info!(\n        total = %operations.len(),\n        successful = %successful,\n        duration_ms = %total_duration.as_millis(),\n        \"Batch set-keys completed\"\n    );\n    \n    Ok(BatchResult {\n        operations: results,\n        total_duration_ms: total_duration.as_millis() as u64,\n        rate_limited_count: results.iter().filter(|r| r.rate_limited).count(),\n    })\n}\n\n/// Batch operation result\n#[derive(Debug, serde::Serialize)]\npub struct BatchResult {\n    pub operations: Vec<OperationResult>,\n    pub total_duration_ms: u64,\n    pub rate_limited_count: usize,\n}\n\n/// Single operation result\n#[derive(Debug, serde::Serialize)]\npub struct OperationResult {\n    pub key: u8,\n    pub status: OperationStatus,\n    pub rate_limited: bool,\n    pub wait_ms: u64,\n    pub duration_ms: u64,\n}\n\n#[derive(Debug, PartialEq, serde::Serialize)]\npub enum OperationStatus {\n    Success,\n    Failed(String),\n    Skipped(String),\n}\n\\`\\`\\`\n\n### Default Rate Limiting for Large Batches\n\\`\\`\\`rust\n/// Suggest rate limit for batch size\npub fn suggest_rate_limit(batch_size: usize) -> Option<u64> {\n    match batch_size {\n        0..=5 => None,      // No rate limiting needed\n        6..=15 => Some(20), // 20ms between operations\n        16..=32 => Some(30), // 30ms for larger batches\n        _ => Some(50),      // 50ms for very large batches\n    }\n}\n\n// In batch operation handler, if no explicit rate limit:\nif rate_limit_ms == 0 && !opts.no_rate_limit {\n    if let Some(suggested) = suggest_rate_limit(operations.len()) {\n        debug!(\n            suggested_ms = %suggested,\n            batch_size = %operations.len(),\n            \"Using suggested rate limit for batch\"\n        );\n        rate_limiter = Some(Box::new(RateLimiter::new(Duration::from_millis(suggested))));\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Rate limiter integration works with set-keys\n- [ ] Integration works with clear-keys and fill-keys\n- [ ] Trait abstraction allows RateLimiter or TokenBucket\n- [ ] Progress reporting includes rate limit status\n- [ ] Robot mode output includes per-operation rate limit info\n- [ ] Suggested rate limiting for large batches\n\n## Logging Requirements\n- TRACE: Rate limit wait completed for each key\n- DEBUG: Rate limiter type and configuration\n- INFO: Batch operation start/complete with stats\n- WARN: (none)\n- ERROR: (none - errors in BatchError)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:20.391609830Z","created_by":"ubuntu","updated_at":"2026-01-19T21:28:54.342384177Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-18h","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:20.408634585Z","created_by":"ubuntu"}]}
{"id":"bd-1bgd","title":"Create E2E integration tests for rich_rust CLI output","description":"# Create E2E integration tests for rich_rust CLI output\n\n## Purpose\nImplement end-to-end tests that exercise the complete CLI flow from command parsing through output generation. Unlike unit tests that test components in isolation, these tests verify the integrated system works correctly.\n\n## Background\nUnit tests verify individual components (RobotOutput, HumanOutput) work correctly. E2E tests verify:\n- CLI argument parsing produces correct OutputMode\n- Commands flow through to correct output handlers\n- Full output matches expectations\n- Error handling works end-to-end\n- Environment variables affect output correctly\n- Watch command streaming behavior\n\n## Test Strategy\n\n### Approach: CLI Subprocess Testing\nRun the actual CLI binary as a subprocess and capture stdout/stderr:\n- Provides true end-to-end verification\n- Tests the actual release binary behavior\n- Catches integration issues unit tests miss\n\n### Test Organization\n```\ntests/\n└── e2e/\n    ├── mod.rs          # CliRunner helper\n    ├── robot_mode.rs   # E2E tests for --robot mode\n    ├── human_mode.rs   # E2E tests for human mode\n    ├── environment.rs  # E2E tests for env var behavior\n    └── watch_cmd.rs    # E2E tests for watch command streaming\n```\n\n## Technical Details\n\n### CLI Runner Helper (tests/e2e/mod.rs)\n```rust\nuse std::process::{Command, Output, Stdio};\nuse std::io::{BufRead, BufReader};\nuse std::time::{Duration, Instant};\nuse tracing::{info, debug, error, instrument};\n\npub struct CliRunner {\n    bin_path: String,\n}\n\nimpl CliRunner {\n    #[instrument]\n    pub fn new() -> Self {\n        info!(\"Initializing CLI runner\");\n        let bin_path = env!(\"CARGO_BIN_EXE_sd\").to_string();\n        debug!(bin_path, \"Using binary\");\n        Self { bin_path }\n    }\n    \n    #[instrument(skip(self))]\n    pub fn run(&self, args: &[&str]) -> CliResult {\n        self.run_with_env(args, &[])\n    }\n    \n    #[instrument(skip(self))]\n    pub fn run_with_env(&self, args: &[&str], env: &[(&str, &str)]) -> CliResult {\n        info!(?args, ?env, \"Running CLI command\");\n        \n        let mut cmd = Command::new(&self.bin_path);\n        cmd.args(args);\n        \n        for (key, value) in env {\n            cmd.env(key, value);\n        }\n        \n        let output = cmd.output().expect(\"Failed to execute CLI\");\n        \n        let result = CliResult {\n            stdout: String::from_utf8_lossy(&output.stdout).to_string(),\n            stderr: String::from_utf8_lossy(&output.stderr).to_string(),\n            exit_code: output.status.code().unwrap_or(-1),\n        };\n        \n        debug!(\n            exit_code = result.exit_code,\n            stdout_len = result.stdout.len(),\n            stderr_len = result.stderr.len(),\n            \"Command completed\"\n        );\n        \n        result\n    }\n    \n    /// Run a streaming command with timeout, collecting lines\n    #[instrument(skip(self))]\n    pub fn run_streaming(&self, args: &[&str], timeout: Duration) -> StreamingResult {\n        info!(?args, ?timeout, \"Running streaming command\");\n        \n        let mut cmd = Command::new(&self.bin_path);\n        cmd.args(args)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n        \n        let mut child = cmd.spawn().expect(\"Failed to spawn CLI\");\n        let stdout = child.stdout.take().expect(\"No stdout\");\n        let reader = BufReader::new(stdout);\n        \n        let start = Instant::now();\n        let mut lines = Vec::new();\n        \n        for line in reader.lines() {\n            if start.elapsed() > timeout {\n                debug!(\"Timeout reached, killing process\");\n                let _ = child.kill();\n                break;\n            }\n            \n            match line {\n                Ok(l) => {\n                    debug!(line = %l, \"Received line\");\n                    lines.push(l);\n                }\n                Err(e) => {\n                    error!(error = %e, \"Read error\");\n                    break;\n                }\n            }\n        }\n        \n        let status = child.wait().ok();\n        let exit_code = status.and_then(|s| s.code()).unwrap_or(-1);\n        \n        StreamingResult {\n            lines,\n            exit_code,\n            timed_out: start.elapsed() > timeout,\n        }\n    }\n}\n\npub struct CliResult {\n    pub stdout: String,\n    pub stderr: String,\n    pub exit_code: i32,\n}\n\nimpl CliResult {\n    pub fn success(&self) -> bool {\n        self.exit_code == 0\n    }\n    \n    pub fn assert_success(&self) {\n        if !self.success() {\n            error!(\n                exit_code = self.exit_code,\n                stderr = %self.stderr,\n                \"Command failed\"\n            );\n            panic!(\"CLI command failed with exit code {}\", self.exit_code);\n        }\n    }\n    \n    pub fn assert_json(&self) -> serde_json::Value {\n        serde_json::from_str(&self.stdout)\n            .expect(\"Failed to parse JSON output\")\n    }\n}\n\npub struct StreamingResult {\n    pub lines: Vec<String>,\n    pub exit_code: i32,\n    pub timed_out: bool,\n}\n```\n\n### Robot Mode E2E Tests (tests/e2e/robot_mode.rs)\n```rust\nuse super::*;\nuse tracing::{info, instrument};\n\n#[test]\n#[instrument]\nfn robot_list_outputs_json_array() {\n    init_test_logging();\n    info!(\"Testing robot mode list output\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run(&[\"list\", \"--robot\"]);\n    \n    // Should succeed or fail gracefully\n    let json = result.assert_json();\n    \n    // Should be an array (empty if no devices)\n    assert!(json.is_array(), \"Device list should be JSON array\");\n    \n    info!(\"✓ Robot list JSON validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_format_flag_works() {\n    init_test_logging();\n    info!(\"Testing --format=json flag\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run(&[\"version\", \"--format=json\"]);\n    \n    result.assert_success();\n    let json = result.assert_json();\n    \n    assert!(json.get(\"version\").is_some(), \"Version should be present\");\n    \n    info!(\"✓ --format=json validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_error_includes_suggestion() {\n    init_test_logging();\n    info!(\"Testing robot mode error output\");\n    \n    let runner = CliRunner::new();\n    // Info without device should error\n    let result = runner.run(&[\"info\", \"--robot\"]);\n    \n    let json = result.assert_json();\n    \n    assert_eq!(json.get(\"error\"), Some(&serde_json::json!(true)));\n    assert!(json.get(\"message\").is_some());\n    assert!(json.get(\"suggestion\").is_some(), \n        \"Recoverable errors should include suggestion\");\n    \n    info!(\"✓ Robot error suggestion validated\");\n}\n```\n\n### Human Mode E2E Tests (tests/e2e/human_mode.rs)\n```rust\nuse super::*;\nuse tracing::{info, instrument};\n\n#[test]\n#[instrument]\nfn human_version_has_ansi() {\n    init_test_logging();\n    info!(\"Testing human mode has ANSI codes\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run_with_env(&[\"version\"], &[(\"FORCE_COLOR\", \"1\")]);\n    \n    result.assert_success();\n    \n    // Human mode should have ANSI escape codes\n    assert!(result.stdout.contains('\\x1b'), \n        \"Human mode should contain ANSI codes\");\n    \n    info!(\"✓ Human mode ANSI validated\");\n}\n\n#[test]\n#[instrument]\nfn human_mode_no_json() {\n    init_test_logging();\n    info!(\"Testing human mode is not JSON\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run(&[\"version\"]);\n    \n    result.assert_success();\n    \n    // Should NOT be valid JSON\n    assert!(serde_json::from_str::<serde_json::Value>(&result.stdout).is_err(),\n        \"Human mode output should not be JSON\");\n    \n    info!(\"✓ Human mode non-JSON validated\");\n}\n```\n\n### Environment E2E Tests (tests/e2e/environment.rs)\n```rust\nuse super::*;\nuse tracing::{info, instrument};\n\n#[test]\n#[instrument]\nfn no_color_removes_ansi() {\n    init_test_logging();\n    info!(\"Testing NO_COLOR env var\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run_with_env(&[\"version\"], &[(\"NO_COLOR\", \"1\")]);\n    \n    result.assert_success();\n    \n    // Should NOT contain ANSI codes\n    assert!(!result.stdout.contains('\\x1b'), \n        \"NO_COLOR should suppress ANSI codes\");\n    \n    info!(\"✓ NO_COLOR validated\");\n}\n\n#[test]\n#[instrument]\nfn sd_format_env_sets_json() {\n    init_test_logging();\n    info!(\"Testing SD_FORMAT env var\");\n    \n    let runner = CliRunner::new();\n    let result = runner.run_with_env(&[\"version\"], &[(\"SD_FORMAT\", \"json\")]);\n    \n    result.assert_success();\n    let json = result.assert_json();\n    \n    assert!(json.get(\"version\").is_some());\n    \n    info!(\"✓ SD_FORMAT=json validated\");\n}\n\n#[test]\n#[instrument]\nfn cli_flag_overrides_env() {\n    init_test_logging();\n    info!(\"Testing CLI flag overrides env var\");\n    \n    let runner = CliRunner::new();\n    // Set env to json but CLI to text\n    let result = runner.run_with_env(\n        &[\"version\", \"--format=text\"],\n        &[(\"SD_FORMAT\", \"json\")]\n    );\n    \n    result.assert_success();\n    \n    // CLI flag should win - output should be text not JSON\n    assert!(serde_json::from_str::<serde_json::Value>(&result.stdout).is_err(),\n        \"CLI flag --format=text should override SD_FORMAT=json\");\n    \n    info!(\"✓ CLI flag override validated\");\n}\n```\n\n### Watch Command E2E Tests (tests/e2e/watch_cmd.rs)\n```rust\nuse super::*;\nuse std::time::Duration;\nuse tracing::{info, debug, instrument};\n\n/// Watch command E2E tests\n/// \n/// NOTE: These tests require either:\n/// 1. A connected Stream Deck device\n/// 2. A mock/test mode (--test-events flag)\n/// \n/// Tests are skipped if no device available.\n\n#[test]\n#[instrument]\nfn watch_robot_outputs_jsonl() {\n    init_test_logging();\n    info!(\"Testing watch robot mode JSONL output\");\n    \n    let runner = CliRunner::new();\n    \n    // Use timeout to prevent infinite blocking\n    // Note: This test requires device or test mode\n    let result = runner.run_streaming(\n        &[\"watch\", \"--robot\", \"--timeout=1\"],\n        Duration::from_secs(2)\n    );\n    \n    // If we got any output, verify it's valid JSONL\n    for line in &result.lines {\n        if !line.is_empty() {\n            let json: serde_json::Value = serde_json::from_str(line)\n                .expect(\"Watch output should be valid JSON per line\");\n            \n            debug!(?json, \"Parsed watch event\");\n            \n            // Should have button event structure\n            assert!(json.get(\"key\").is_some() || json.get(\"event\").is_some(),\n                \"Watch event should have key or event field\");\n        }\n    }\n    \n    info!(lines = result.lines.len(), \"✓ Watch JSONL validated\");\n}\n\n#[test]\n#[instrument]\nfn watch_timeout_flag_exits() {\n    init_test_logging();\n    info!(\"Testing watch --timeout flag\");\n    \n    let runner = CliRunner::new();\n    \n    let start = std::time::Instant::now();\n    let result = runner.run(&[\"watch\", \"--robot\", \"--timeout=1\"]);\n    let elapsed = start.elapsed();\n    \n    // Should exit within reasonable time of timeout\n    assert!(elapsed < Duration::from_secs(5),\n        \"Watch with --timeout=1 should exit within 5 seconds\");\n    \n    debug!(elapsed_ms = elapsed.as_millis(), \"Watch completed\");\n    \n    info!(\"✓ Watch timeout validated\");\n}\n\n#[test]\n#[instrument]\nfn watch_human_mode_has_header() {\n    init_test_logging();\n    info!(\"Testing watch human mode header\");\n    \n    let runner = CliRunner::new();\n    \n    let result = runner.run_with_env(\n        &[\"watch\", \"--timeout=1\"],\n        &[(\"FORCE_COLOR\", \"1\")]\n    );\n    \n    // Human mode should have header\n    assert!(result.stdout.contains(\"Watch\") || \n            result.stdout.contains(\"Button\") ||\n            result.stdout.contains(\"Event\") ||\n            result.stdout.contains('─'),  // Rule character\n        \"Watch human mode should show header\");\n    \n    info!(\"✓ Watch human header validated\");\n}\n\n#[test]\n#[instrument]\nfn watch_once_exits_after_event() {\n    init_test_logging();\n    info!(\"Testing watch --once flag\");\n    \n    // This test can only fully verify if events occur\n    // Without a device, just verify the flag is accepted\n    \n    let runner = CliRunner::new();\n    let result = runner.run(&[\"watch\", \"--once\", \"--robot\", \"--timeout=1\"]);\n    \n    // Should not error due to unknown flag\n    // Exit code depends on whether event occurred or timeout\n    debug!(exit_code = result.exit_code, \"Watch --once completed\");\n    \n    info!(\"✓ Watch --once flag validated\");\n}\n```\n\n## Test Prerequisites\n```rust\n// tests/common/mod.rs additions\n\n/// Initialize test logging (call once per test)\npub fn init_test_logging() {\n    use tracing_subscriber::{fmt, EnvFilter};\n    \n    let _ = fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .with_test_writer()\n        .try_init();\n}\n\n/// Check if a real device is available for testing\npub fn has_device() -> bool {\n    // Quick check - try to list devices\n    let output = std::process::Command::new(env!(\"CARGO_BIN_EXE_sd\"))\n        .args([\"list\", \"--robot\"])\n        .output()\n        .ok();\n    \n    output\n        .and_then(|o| serde_json::from_slice::<Vec<serde_json::Value>>(&o.stdout).ok())\n        .map(|devices| !devices.is_empty())\n        .unwrap_or(false)\n}\n\n/// Skip test if no device available\n#[macro_export]\nmacro_rules! skip_without_device {\n    () => {\n        if !crate::common::has_device() {\n            eprintln!(\"Skipping: No Stream Deck device connected\");\n            return;\n        }\n    };\n}\n```\n\n## Acceptance Criteria\n- [ ] CliRunner helper handles subprocess execution\n- [ ] CliRunner.run_streaming handles timeout-based streaming tests\n- [ ] Robot mode E2E tests verify JSON structure\n- [ ] Human mode E2E tests verify ANSI presence\n- [ ] Environment variable tests verify NO_COLOR, SD_FORMAT\n- [ ] Watch command E2E tests verify JSONL streaming\n- [ ] Watch --timeout flag tests verify exit behavior\n- [ ] Watch --once flag tests verify acceptance\n- [ ] All tests include tracing instrumentation\n- [ ] Tests handle device presence gracefully (skip or mock)\n- [ ] All tests pass in CI","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:23:52.344509332Z","created_by":"ubuntu","updated_at":"2026-01-19T21:31:42.432295030Z","compaction_level":0,"original_size":0,"labels":["e2e","phase-4","rich-rust","testing"],"dependencies":[{"issue_id":"bd-1bgd","depends_on_id":"bd-1gx6","type":"blocks","created_at":"2026-01-19T21:24:00.455355464Z","created_by":"ubuntu"},{"issue_id":"bd-1bgd","depends_on_id":"bd-2ui5","type":"blocks","created_at":"2026-01-19T21:24:01.302040786Z","created_by":"ubuntu"},{"issue_id":"bd-1bgd","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:23:59.566340963Z","created_by":"ubuntu"}]}
{"id":"bd-1ch","title":"Add error handling and continue-on-error","description":"## Purpose\nImplement robust error handling for batch operations with configurable failure behavior.\n\n## Implementation\n\n```rust\n// src/commands/batch.rs\nuse crate::error::{Result, SdError};\nuse tracing::{debug, warn, error, instrument};\n\n#[derive(Debug, Clone)]\npub struct BatchConfig {\n    /// If true, continue processing after errors\n    pub continue_on_error: bool,\n    /// Maximum number of errors before aborting (0 = unlimited)\n    pub max_errors: usize,\n    /// Collect errors for summary reporting\n    pub collect_errors: bool,\n}\n\nimpl Default for BatchConfig {\n    fn default() -> Self {\n        Self {\n            continue_on_error: false,\n            max_errors: 0,\n            collect_errors: true,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct BatchResult {\n    pub total: usize,\n    pub succeeded: usize,\n    pub failed: usize,\n    pub skipped: usize,\n    pub errors: Vec<BatchError>,\n}\n\n#[derive(Debug, Clone)]\npub struct BatchError {\n    pub key: u8,\n    pub file: Option<String>,\n    pub error: SdError,\n    pub recoverable: bool,\n}\n\nimpl BatchResult {\n    pub fn new(total: usize) -> Self {\n        Self {\n            total,\n            succeeded: 0,\n            failed: 0,\n            skipped: 0,\n            errors: Vec::new(),\n        }\n    }\n    \n    pub fn record_success(&mut self) {\n        self.succeeded += 1;\n    }\n    \n    pub fn record_failure(&mut self, key: u8, file: Option<&str>, error: SdError) {\n        let recoverable = error.is_retryable();\n        self.failed += 1;\n        self.errors.push(BatchError {\n            key,\n            file: file.map(String::from),\n            error,\n            recoverable,\n        });\n    }\n    \n    pub fn record_skip(&mut self) {\n        self.skipped += 1;\n    }\n    \n    pub fn is_complete_success(&self) -> bool {\n        self.failed == 0 && self.skipped == 0\n    }\n    \n    pub fn is_partial_success(&self) -> bool {\n        self.succeeded > 0 && (self.failed > 0 || self.skipped > 0)\n    }\n    \n    pub fn is_complete_failure(&self) -> bool {\n        self.succeeded == 0 && self.failed > 0\n    }\n}\n\n/// Execute a batch operation with error handling\n#[instrument(skip(operation))]\npub async fn execute_batch<F, Fut>(\n    items: Vec<(u8, Option<PathBuf>)>,\n    config: &BatchConfig,\n    mut operation: F,\n) -> Result<BatchResult>\nwhere\n    F: FnMut(u8, Option<&Path>) -> Fut,\n    Fut: std::future::Future<Output = Result<()>>,\n{\n    let mut result = BatchResult::new(items.len());\n    let mut error_count = 0;\n    \n    for (key, file) in items {\n        let file_path = file.as_ref().map(|p| p.as_path());\n        \n        debug!(key, file = ?file_path, \"Processing batch item\");\n        \n        match operation(key, file_path).await {\n            Ok(()) => {\n                result.record_success();\n            }\n            Err(e) => {\n                let file_str = file_path.map(|p| p.display().to_string());\n                \n                error!(\n                    key,\n                    file = ?file_str,\n                    error = %e,\n                    \"Batch item failed\"\n                );\n                \n                result.record_failure(key, file_str.as_deref(), e.clone());\n                error_count += 1;\n                \n                // Check abort conditions\n                if !config.continue_on_error {\n                    warn!(\"Aborting batch due to error (continue_on_error=false)\");\n                    break;\n                }\n                \n                if config.max_errors > 0 && error_count >= config.max_errors {\n                    warn!(\n                        max_errors = config.max_errors,\n                        \"Aborting batch: max errors reached\"\n                    );\n                    break;\n                }\n            }\n        }\n    }\n    \n    Ok(result)\n}\n```\n\n## CLI Integration\n\n```rust\n// In src/cli/mod.rs\n#[derive(Args)]\npub struct SetKeysArgs {\n    /// Directory containing key images\n    pub directory: PathBuf,\n    \n    /// Continue processing after errors\n    #[arg(long)]\n    pub continue_on_error: bool,\n    \n    /// Maximum errors before aborting (0 = unlimited)\n    #[arg(long, default_value = \"0\")]\n    pub max_errors: usize,\n}\n```\n\n## Robot Mode JSON Output\n\n### Partial Success\n```json\n{\n  \"success\": true,\n  \"partial\": true,\n  \"results\": {\n    \"total\": 32,\n    \"succeeded\": 28,\n    \"failed\": 2,\n    \"skipped\": 2,\n    \"errors\": [\n      {\n        \"key\": 5,\n        \"file\": \"/path/to/key-05.png\",\n        \"error\": \"Image file corrupted\",\n        \"error_type\": \"image_format\",\n        \"recoverable\": false\n      },\n      {\n        \"key\": 12,\n        \"file\": null,\n        \"error\": \"No matching file for key 12\",\n        \"error_type\": \"file_not_found\",\n        \"recoverable\": false\n      }\n    ]\n  }\n}\n```\n\n### Aborted Due to Error\n```json\n{\n  \"success\": false,\n  \"aborted\": true,\n  \"abort_reason\": \"continue_on_error=false\",\n  \"results\": {\n    \"total\": 32,\n    \"succeeded\": 4,\n    \"failed\": 1,\n    \"skipped\": 27,\n    \"errors\": [\n      {\n        \"key\": 5,\n        \"file\": \"/path/to/key-05.png\",\n        \"error\": \"Permission denied\",\n        \"error_type\": \"permission_denied\",\n        \"recoverable\": true\n      }\n    ]\n  }\n}\n```\n\n## Human Mode Output\n\n### Partial Success\n```\nSetting 32 keys from ~/layout/...\n\n✓ key-00.png → key 0\n✓ key-01.png → key 1\n✓ key-02.png → key 2\n✓ key-03.png → key 3\n✓ key-04.png → key 4\n✗ key-05.png → key 5: Image file corrupted\n✓ key-06.png → key 6\n...\n⊘ key 12: No matching file\n...\n\nSummary: 28 succeeded, 2 failed, 2 skipped\n```\n\n### Aborted\n```\nSetting 32 keys from ~/layout/...\n\n✓ key-00.png → key 0\n✓ key-01.png → key 1\n✓ key-02.png → key 2\n✓ key-03.png → key 3\n✓ key-04.png → key 4\n✗ key-05.png → key 5: Permission denied\n\nAborted: Use --continue-on-error to process remaining keys\n\nSummary: 5 succeeded, 1 failed, 26 not attempted\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_batch_continue_on_error() {\n        let items = vec![\n            (0, Some(PathBuf::from(\"a.png\"))),\n            (1, Some(PathBuf::from(\"b.png\"))), // Will fail\n            (2, Some(PathBuf::from(\"c.png\"))),\n        ];\n        \n        let config = BatchConfig {\n            continue_on_error: true,\n            ..Default::default()\n        };\n        \n        let mut call_count = 0;\n        let result = execute_batch(items, &config, |key, _| {\n            call_count += 1;\n            async move {\n                if key == 1 {\n                    Err(SdError::ImageFormat(\"test\".to_string()))\n                } else {\n                    Ok(())\n                }\n            }\n        }).await.unwrap();\n        \n        assert_eq!(call_count, 3); // All items processed\n        assert_eq!(result.succeeded, 2);\n        assert_eq!(result.failed, 1);\n    }\n    \n    #[tokio::test]\n    async fn test_batch_fail_fast() {\n        let items = vec![\n            (0, Some(PathBuf::from(\"a.png\"))),\n            (1, Some(PathBuf::from(\"b.png\"))), // Will fail\n            (2, Some(PathBuf::from(\"c.png\"))),\n        ];\n        \n        let config = BatchConfig {\n            continue_on_error: false,\n            ..Default::default()\n        };\n        \n        let mut call_count = 0;\n        let result = execute_batch(items, &config, |key, _| {\n            call_count += 1;\n            async move {\n                if key == 1 {\n                    Err(SdError::ImageFormat(\"test\".to_string()))\n                } else {\n                    Ok(())\n                }\n            }\n        }).await.unwrap();\n        \n        assert_eq!(call_count, 2); // Stopped after error\n        assert_eq!(result.succeeded, 1);\n        assert_eq!(result.failed, 1);\n    }\n    \n    #[tokio::test]\n    async fn test_batch_max_errors() {\n        let items: Vec<_> = (0..10).map(|i| (i, None)).collect();\n        \n        let config = BatchConfig {\n            continue_on_error: true,\n            max_errors: 3,\n            ..Default::default()\n        };\n        \n        let result = execute_batch(items, &config, |_, _| {\n            async { Err(SdError::Other(\"fail\".to_string())) }\n        }).await.unwrap();\n        \n        assert_eq!(result.failed, 3); // Stopped at max_errors\n    }\n    \n    #[test]\n    fn test_batch_result_states() {\n        let mut result = BatchResult::new(10);\n        \n        // All success\n        for _ in 0..10 {\n            result.record_success();\n        }\n        assert!(result.is_complete_success());\n        assert!(!result.is_partial_success());\n        \n        // Partial success\n        let mut result = BatchResult::new(10);\n        for _ in 0..8 {\n            result.record_success();\n        }\n        result.record_failure(8, None, SdError::Other(\"test\".to_string()));\n        result.record_skip();\n        assert!(!result.is_complete_success());\n        assert!(result.is_partial_success());\n        \n        // Complete failure\n        let mut result = BatchResult::new(10);\n        for i in 0..10 {\n            result.record_failure(i, None, SdError::Other(\"test\".to_string()));\n        }\n        assert!(result.is_complete_failure());\n    }\n}\n```\n\n## Success Criteria\n- [ ] continue_on_error=false aborts on first error\n- [ ] continue_on_error=true processes all items\n- [ ] max_errors limit respected\n- [ ] Error details include key index and file path\n- [ ] Robot mode JSON shows all errors\n- [ ] Human mode shows clear progress\n- [ ] Partial success distinguished from complete success\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Individual item processing\n- DEBUG: Batch configuration, item counts\n- INFO: Batch start/complete with summary\n- WARN: Errors when continuing, abort conditions\n- ERROR: Individual item failures with details","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.535377378Z","created_by":"ubuntu","updated_at":"2026-01-21T10:58:08.965091205Z","closed_at":"2026-01-21T10:58:08.965035540Z","close_reason":"Already implemented in cmd_set_keys() - continue_on_error flag","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ch","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.551895849Z","created_by":"ubuntu"}]}
{"id":"bd-1dc","title":"Add state tracking to all mutating commands","description":"Modify each command handler to track state:\n- brightness: track_brightness(level)\n- set-key: track_set_key(key, path)\n- fill-key: track_fill_key(key, color)\n- clear-key: track_clear_key(key)\n- clear-all: track_clear_all(key_count)\n\nCall after successful device operation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.467962903Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.478565857Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1dc","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.478517055Z","created_by":"ubuntu"}]}
{"id":"bd-1es","title":"Create output module structure with Output trait","description":"# Create output module structure with Output trait\n\n## Purpose\nCreate the src/output/ module that defines the Output trait abstraction. This trait is the cornerstone of the entire integration - it allows commands to output data without knowing whether they are in robot mode or human mode.\n\n## Background\nThe current codebase has output logic scattered throughout main.rs with direct println! calls for JSON and colored output. This task centralizes all output behind a trait, enabling:\n1. Clean separation of concerns\n2. Easy testing (mock output implementations)\n3. Future extensibility (e.g., file output, remote logging)\n\n## Technical Details\n\n### Module Structure\n```\nsrc/output/\n├── mod.rs      # OutputMode enum, Output trait, re-exports\n├── robot.rs    # RobotOutput implementation (JSON)\n└── human.rs    # HumanOutput implementation (rich_rust)\n```\n\n### OutputMode Enum (src/output/mod.rs)\n```rust\nuse rich_rust::prelude::*;\n\n/// Determines how command output is rendered\npub enum OutputMode {\n    /// JSON output for AI agents and scripting\n    Robot(RobotFormat),\n    /// Styled terminal output for human users\n    Human(Console),\n}\n\n/// JSON formatting options\npub enum RobotFormat {\n    /// Pretty-printed JSON (default for --robot)\n    Json,\n    /// Single-line JSON (--format=json-compact)\n    JsonCompact,\n}\n\nimpl OutputMode {\n    /// Create OutputMode from CLI arguments\n    pub fn from_cli(cli: &Cli) -> Self {\n        if cli.use_json() {\n            let format = if cli.use_compact_json() {\n                RobotFormat::JsonCompact\n            } else {\n                RobotFormat::Json\n            };\n            Self::Robot(format)\n        } else {\n            // rich_rust Console auto-detects:\n            // - TTY vs pipe (disables colors when piped)\n            // - NO_COLOR env var\n            // - Terminal color capabilities (4/8/24-bit)\n            let console = Console::builder()\n                .safe_box(cli.no_color)  // ASCII fallback if requested\n                .build();\n            Self::Human(console)\n        }\n    }\n    \n    pub fn is_robot(&self) -> bool {\n        matches!(self, Self::Robot(_))\n    }\n    \n    /// Get the appropriate Output implementation\n    pub fn as_output(&self) -> Box<dyn Output> {\n        match self {\n            Self::Robot(format) => Box::new(RobotOutput::new(*format)),\n            Self::Human(console) => Box::new(HumanOutput::new(console.clone())),\n        }\n    }\n}\n```\n\n### Output Trait (src/output/mod.rs)\n```rust\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse std::path::Path;\n\n/// Trait for all output operations\n/// \n/// This trait abstracts over robot mode (JSON) and human mode (rich_rust).\n/// Commands call these methods without knowing the output mode.\npub trait Output {\n    // Basic messages\n    fn success(&self, message: &str);\n    fn error(&self, error: &SdError);\n    fn warning(&self, message: &str);\n    fn info(&self, message: &str);\n    \n    // Device operations\n    fn device_list(&self, devices: &[DeviceInfo]);\n    fn device_info(&self, info: &DeviceInfo);\n    \n    // Button events (for watch command)\n    fn button_event(&self, event: &ButtonEvent);\n    fn button_states(&self, states: &[bool]);\n    \n    // Display operations\n    fn brightness_set(&self, level: u8);\n    fn key_set(&self, key: u8, image: &Path);\n    fn key_cleared(&self, key: u8);\n    fn key_filled(&self, key: u8, color: &str);\n    fn all_cleared(&self);\n    fn all_filled(&self, color: &str);\n    \n    // Metadata\n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>);\n    \n    // Visual separators (no-op in robot mode)\n    fn rule(&self, title: Option<&str>);\n    fn newline(&self);\n}\n```\n\n### Re-exports\n```rust\npub mod robot;\npub mod human;\n\npub use robot::RobotOutput;\npub use human::HumanOutput;\n```\n\n## Design Decisions\n\n### Why a Trait Instead of Enum Methods?\nA trait allows:\n1. Open extension (new output modes without modifying enum)\n2. Mock implementations for testing\n3. Dynamic dispatch when output mode varies at runtime\n\n### Why Clone Console?\nThe Console from rich_rust is cheap to clone (it's mostly Rc<RefCell<...>>). Cloning allows HumanOutput to own its console.\n\n### Why Box<dyn Output>?\nCommands receive &dyn Output for maximum flexibility. The boxing happens once at startup.\n\n## Implementation Steps\n1. Create src/output/ directory\n2. Create src/output/mod.rs with OutputMode and Output trait\n3. Add placeholder modules for robot.rs and human.rs\n4. Add mod output; to src/lib.rs or src/main.rs\n5. Verify compilation\n\n## Verification\n```bash\ncargo check --all-targets\n```\n\n## Acceptance Criteria\n- [ ] src/output/mod.rs exists with OutputMode and Output trait\n- [ ] Output trait has all methods listed above\n- [ ] OutputMode::from_cli() correctly detects robot vs human mode\n- [ ] Module compiles without errors\n- [ ] No changes to existing command behavior (yet)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:58.061089633Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:58.106837677Z","compaction_level":0,"original_size":0,"labels":["architecture","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-1es","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:02:58.101765117Z","created_by":"ubuntu"},{"issue_id":"bd-1es","depends_on_id":"bd-pnk","type":"blocks","created_at":"2026-01-19T21:02:58.106797001Z","created_by":"ubuntu"}]}
{"id":"bd-1eu","title":"Add robot mode cache hit/miss reporting","description":"## Purpose\nAdd robot mode cache hit/miss reporting for performance diagnostics.\n\n## Implementation\n\\`\\`\\`rust\n// src/output/robot.rs\nuse serde::Serialize;\n\n/// Cache status for robot mode output\n#[derive(Debug, Serialize)]\npub struct CacheStatus {\n    /// Whether the image was found in cache\n    pub hit: bool,\n    /// Cache key (content hash)\n    pub cache_key: String,\n    /// Path to cached file (if hit)\n    pub cached_path: Option<String>,\n    /// Original file path\n    pub source_path: String,\n    /// Source file size in bytes\n    pub source_size: u64,\n    /// Cached size in bytes (may differ due to format conversion)\n    pub cached_size: Option<u64>,\n    /// Time saved by cache hit (estimated)\n    pub time_saved_ms: Option<u64>,\n}\n\n/// Key operation result with cache info\n#[derive(Debug, Serialize)]\npub struct SetKeyResultRobot {\n    pub key: u8,\n    pub status: String,\n    pub source: String,\n    pub cache: CacheStatus,\n    pub resize_needed: bool,\n    pub target_dimensions: (u32, u32),\n    pub duration_ms: u64,\n}\n\n/// Batch operation with cache summary\n#[derive(Debug, Serialize)]\npub struct BatchSetKeysResultRobot {\n    pub command: String,\n    pub operations: Vec<SetKeyResultRobot>,\n    pub cache_summary: CacheSummaryRobot,\n    pub total_duration_ms: u64,\n}\n\n#[derive(Debug, Serialize)]\npub struct CacheSummaryRobot {\n    pub hits: usize,\n    pub misses: usize,\n    pub hit_rate: f64,\n    pub estimated_time_saved_ms: u64,\n    pub cache_size_bytes: u64,\n}\n\\`\\`\\`\n\n### Example Robot Mode Output\n\\`\\`\\`json\n{\n  \"command\": \"set-key\",\n  \"key\": 5,\n  \"status\": \"success\",\n  \"source\": \"/home/user/icons/chrome.png\",\n  \"cache\": {\n    \"hit\": true,\n    \"cache_key\": \"a1b2c3d4e5f6...\",\n    \"cached_path\": \"/home/user/.cache/sd/images/a1b2c3d4e5f6.bin\",\n    \"source_path\": \"/home/user/icons/chrome.png\",\n    \"source_size\": 24576,\n    \"cached_size\": 147456,\n    \"time_saved_ms\": 45\n  },\n  \"resize_needed\": true,\n  \"target_dimensions\": [72, 72],\n  \"duration_ms\": 12\n}\n\\`\\`\\`\n\n### Batch Output with Cache Summary\n\\`\\`\\`json\n{\n  \"command\": \"set-keys\",\n  \"operations\": [\n    {\"key\": 0, \"status\": \"success\", \"cache\": {\"hit\": true, ...}},\n    {\"key\": 1, \"status\": \"success\", \"cache\": {\"hit\": false, ...}},\n    {\"key\": 2, \"status\": \"success\", \"cache\": {\"hit\": true, ...}}\n  ],\n  \"cache_summary\": {\n    \"hits\": 2,\n    \"misses\": 1,\n    \"hit_rate\": 0.667,\n    \"estimated_time_saved_ms\": 90,\n    \"cache_size_bytes\": 1048576\n  },\n  \"total_duration_ms\": 250\n}\n\\`\\`\\`\n\n### Integration with set-key Handler\n\\`\\`\\`rust\nasync fn set_key_with_cache(\n    device: &mut Device,\n    key: u8,\n    image_path: &Path,\n    cache: &mut ImageCache,\n    robot_mode: bool,\n) -> Result<SetKeyResult> {\n    let start = Instant::now();\n    let source_size = std::fs::metadata(image_path)?.len();\n    \n    // Compute cache key\n    let cache_key = cache.compute_key(image_path)?;\n    \n    // Check cache\n    let (image_data, cache_hit, cached_path, cached_size) = match cache.get(&cache_key)? {\n        Some(cached) => {\n            trace!(key = %key, cache_key = %cache_key, \"Cache hit\");\n            (cached.data, true, Some(cached.path), Some(cached.size))\n        }\n        None => {\n            trace!(key = %key, cache_key = %cache_key, \"Cache miss\");\n            let processed = process_image(image_path)?;\n            cache.put(&cache_key, &processed)?;\n            (processed, false, None, None)\n        }\n    };\n    \n    // Apply to device\n    device.set_key_image(key, &image_data).await?;\n    \n    let duration = start.elapsed();\n    let time_saved = if cache_hit {\n        // Estimate processing time saved\n        Some((source_size as f64 * 0.002) as u64) // ~2ms per KB\n    } else {\n        None\n    };\n    \n    Ok(SetKeyResult {\n        key,\n        cache_status: CacheStatus {\n            hit: cache_hit,\n            cache_key,\n            cached_path,\n            source_path: image_path.display().to_string(),\n            source_size,\n            cached_size,\n            time_saved_ms: time_saved,\n        },\n        duration_ms: duration.as_millis() as u64,\n    })\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Cache hit/miss reported for each key operation\n- [ ] Cache key (content hash) included\n- [ ] Cached path included when available\n- [ ] Batch operations include cache summary\n- [ ] Hit rate calculated correctly\n- [ ] Estimated time saved provided\n\n## Logging Requirements\n- TRACE: Cache hit/miss for each key\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:40.506479431Z","created_by":"ubuntu","updated_at":"2026-01-19T21:31:17.976874227Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1eu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:40.520564341Z","created_by":"ubuntu"}]}
{"id":"bd-1fd","title":"Implement text positioning","description":"Add TextPosition enum:\n- Top: centered at top with padding\n- Center: centered both ways\n- Bottom: centered at bottom with padding\n- Custom { x, y }: explicit coordinates\n\nCalculate position based on text metrics.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.298548355Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.309658684Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1fd","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.309593942Z","created_by":"ubuntu"}]}
{"id":"bd-1g6","title":"Write tests for image caching","description":"## Test Coverage for Image Caching\n\n### Unit Tests - Cache Key Generation\n\n1. **Content-Based Hashing**\n   - Same content = same hash\n   - Different content = different hash\n   - Hash includes file content (not path)\n   - Hash includes target dimensions\n   - Hash is deterministic\n\n2. **Dimension Handling**\n   - 72x72 (XL keys) and 96x96 (MK2 keys) are different\n   - Same image at different sizes = different entries\n   - Hash format: `{content_sha256}-{width}x{height}.bin`\n\n3. **Path Independence**\n   - `/path/a/icon.png` and `/path/b/icon.png` with same content → same hash\n   - Renaming file doesn't change hash\n   - Moving file doesn't change hash\n\n### Unit Tests - Cache Operations\n\n4. **Cache Miss Behavior**\n   - get() returns None for missing entry\n   - put() stores data correctly\n   - Data retrievable immediately after put()\n   - File created with correct name\n\n5. **Cache Hit Behavior**\n   - get() returns exact stored data\n   - Data matches what was put()\n   - No reprocessing of image\n   - File timestamp unchanged\n\n6. **Cache Invalidation (Implicit)**\n   - Modified source file → new hash → cache miss\n   - Old entry becomes orphan (not deleted)\n   - New entry created for modified file\n\n### Unit Tests - Cache Management\n\n7. **Stats Accuracy**\n   - Entry count matches actual files\n   - Size sum matches actual disk usage\n   - Empty cache shows zero entries/size\n   - Stats reflect recent operations\n\n8. **Clear Operation**\n   - Removes all .bin files\n   - Directory structure preserved\n   - Stats shows zero after clear\n   - Safe with concurrent access\n\n9. **Directory Management**\n   - Creates cache dir if not exists\n   - Handles missing parent directories\n   - Respects XDG_CACHE_HOME\n   - Handles permission errors gracefully\n\n### Integration Tests (require MockDevice)\n\n1. **Full Workflow - Cold Cache**\n   - Clear cache\n   - Set key with image\n   - Verify image processed\n   - Verify cache entry created\n   - Check stats shows 1 entry\n\n2. **Full Workflow - Warm Cache**\n   - Set same key with same image again\n   - Verify no reprocessing (fast)\n   - Verify cache hit logged\n   - Check stats unchanged\n\n3. **Multiple Images**\n   - Set 10 different images\n   - Verify 10 cache entries\n   - Clear and set same 10 again\n   - Verify all 10 cache hits\n\n4. **Device Model Differences**\n   - Same image for XL (72x72) and MK2 (96x96)\n   - Verify 2 different cache entries\n   - Verify correct entry used per device\n\n5. **Performance Comparison**\n   - Time to set 32 keys, cold cache\n   - Time to set 32 keys, warm cache\n   - Warm should be > 5x faster\n\n### E2E Tests (require E2E harness)\n\n1. **Cache Commands**\n   ```bash\n   # Show stats\n   sd cache stats\n   # Output: Cache location: ~/.cache/sd/images/\n   #         Entries: 47\n   #         Size: 2.3 MB\n   \n   # Clear cache\n   sd cache clear\n   # Output: Cleared 47 entries (2.3 MB)\n   \n   # Verify cleared\n   sd cache stats\n   # Output: Cache location: ~/.cache/sd/images/\n   #         Entries: 0\n   #         Size: 0 B\n   ```\n\n2. **Robot Mode Stats**\n   ```json\n   {\n     \"command\": \"cache_stats\",\n     \"cache\": {\n       \"location\": \"/home/user/.cache/sd/images\",\n       \"entries\": 47,\n       \"size_bytes\": 2412345\n     }\n   }\n   ```\n\n3. **Cache Performance Logging**\n   ```bash\n   RUST_LOG=sd=debug sd set-key 0 icon.png\n   # Shows: cache_miss, processing_ms, stored_bytes\n   \n   RUST_LOG=sd=debug sd set-key 0 icon.png  # again\n   # Shows: cache_hit, retrieved_bytes\n   ```\n\n### Edge Case Tests\n\n1. **Disk Full**\n   - Cache gracefully handles disk full\n   - Operation completes (without caching)\n   - Warning logged\n\n2. **Corrupted Cache Entry**\n   - Detect corrupted .bin file\n   - Regenerate from source\n   - Log warning about corruption\n\n3. **Concurrent Access**\n   - Multiple sd processes writing cache\n   - No data corruption\n   - Atomic writes (write to temp, rename)\n\n4. **Large Images**\n   - 4K image cached correctly\n   - Memory usage reasonable during processing\n   - Cached size is post-resize (small)\n\n### Test Fixtures\n\n```\ntests/fixtures/images/\n├── icon-72x72.png       # Pre-sized for XL\n├── icon-256x256.png     # Needs resize\n├── icon-4k.png          # Large image test\n├── duplicate/\n│   ├── a/icon.png       # Same content as b/\n│   └── b/icon.png       # Same content as a/\n└── formats/\n    ├── test.png\n    ├── test.jpg\n    └── test.webp\n```\n\n### Performance Targets\n- Cache lookup: < 1ms\n- Cache storage: < 10ms\n- Hash computation: < 5ms for 1MB image\n- Memory: < 10MB for cache operations","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:41.073285158Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:09.864888670Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1g6","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:51.427266969Z","created_by":"ubuntu"},{"issue_id":"bd-1g6","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:09.864841551Z","created_by":"ubuntu"},{"issue_id":"bd-1g6","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:41.087502506Z","created_by":"ubuntu"}]}
{"id":"bd-1go","title":"Implement simple RateLimiter struct","description":"## Purpose\nSimple rate limiter for controlling the pace of key operations to prevent device overload.\n\n## Implementation\n\\`\\`\\`rust\n// src/rate_limit.rs\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, instrument};\n\n/// Simple interval-based rate limiter\n#[derive(Debug)]\npub struct RateLimiter {\n    /// Minimum time between operations\n    min_interval: Duration,\n    /// When the last operation was allowed\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    /// Create a new rate limiter with the specified minimum interval\n    #[instrument]\n    pub fn new(min_interval: Duration) -> Self {\n        debug!(interval_ms = %min_interval.as_millis(), \"Rate limiter created\");\n        Self {\n            min_interval,\n            last_action: None,\n        }\n    }\n    \n    /// Create from operations per second\n    pub fn from_ops_per_second(ops: f64) -> Self {\n        let interval = Duration::from_secs_f64(1.0 / ops);\n        Self::new(interval)\n    }\n    \n    /// Check if an operation is currently allowed (non-blocking)\n    pub fn check(&self) -> bool {\n        match self.last_action {\n            None => true,\n            Some(last) => last.elapsed() >= self.min_interval,\n        }\n    }\n    \n    /// Try to acquire permission for an operation (non-blocking)\n    /// Returns true if allowed, false if rate limited\n    pub fn try_acquire(&mut self) -> bool {\n        if self.check() {\n            self.last_action = Some(Instant::now());\n            trace!(\"Operation permitted\");\n            true\n        } else {\n            trace!(\"Operation rate-limited\");\n            false\n        }\n    }\n    \n    /// Wait until an operation is allowed, then acquire\n    #[instrument(skip(self))]\n    pub async fn wait(&mut self) {\n        if let Some(last) = self.last_action {\n            let elapsed = last.elapsed();\n            if elapsed < self.min_interval {\n                let wait_time = self.min_interval - elapsed;\n                trace!(wait_ms = %wait_time.as_millis(), \"Waiting for rate limit\");\n                tokio::time::sleep(wait_time).await;\n            }\n        }\n        self.last_action = Some(Instant::now());\n    }\n    \n    /// Synchronous wait (blocking)\n    pub fn wait_blocking(&mut self) {\n        if let Some(last) = self.last_action {\n            let elapsed = last.elapsed();\n            if elapsed < self.min_interval {\n                let wait_time = self.min_interval - elapsed;\n                trace!(wait_ms = %wait_time.as_millis(), \"Blocking wait for rate limit\");\n                std::thread::sleep(wait_time);\n            }\n        }\n        self.last_action = Some(Instant::now());\n    }\n    \n    /// Time until next operation is allowed\n    pub fn time_until_allowed(&self) -> Duration {\n        match self.last_action {\n            None => Duration::ZERO,\n            Some(last) => {\n                let elapsed = last.elapsed();\n                if elapsed >= self.min_interval {\n                    Duration::ZERO\n                } else {\n                    self.min_interval - elapsed\n                }\n            }\n        }\n    }\n    \n    /// Reset the rate limiter\n    pub fn reset(&mut self) {\n        self.last_action = None;\n        debug!(\"Rate limiter reset\");\n    }\n    \n    /// Get current interval\n    pub fn interval(&self) -> Duration {\n        self.min_interval\n    }\n}\n\n/// Robot mode rate limit status\n#[derive(serde::Serialize)]\npub struct RateLimitStatus {\n    pub limited: bool,\n    pub wait_ms: u64,\n    pub interval_ms: u64,\n}\n\nimpl RateLimiter {\n    /// Get status for robot mode output\n    pub fn status(&self) -> RateLimitStatus {\n        RateLimitStatus {\n            limited: !self.check(),\n            wait_ms: self.time_until_allowed().as_millis() as u64,\n            interval_ms: self.min_interval.as_millis() as u64,\n        }\n    }\n}\n\\`\\`\\`\n\n## Unit Tests\n\\`\\`\\`rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_first_operation_allowed() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(100));\n        assert!(limiter.check());\n        assert!(limiter.try_acquire());\n    }\n    \n    #[test]\n    fn test_immediate_second_blocked() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(100));\n        assert!(limiter.try_acquire());\n        assert!(!limiter.try_acquire()); // Should be blocked\n    }\n    \n    #[test]\n    fn test_allowed_after_interval() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(10));\n        assert!(limiter.try_acquire());\n        std::thread::sleep(Duration::from_millis(15));\n        assert!(limiter.try_acquire()); // Should be allowed\n    }\n    \n    #[test]\n    fn test_from_ops_per_second() {\n        let limiter = RateLimiter::from_ops_per_second(10.0);\n        assert_eq!(limiter.interval().as_millis(), 100);\n    }\n    \n    #[test]\n    fn test_time_until_allowed() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(100));\n        assert_eq!(limiter.time_until_allowed(), Duration::ZERO);\n        \n        limiter.try_acquire();\n        let time = limiter.time_until_allowed();\n        assert!(time > Duration::ZERO && time <= Duration::from_millis(100));\n    }\n    \n    #[test]\n    fn test_reset() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(100));\n        limiter.try_acquire();\n        assert!(!limiter.check());\n        \n        limiter.reset();\n        assert!(limiter.check());\n    }\n    \n    #[tokio::test]\n    async fn test_async_wait() {\n        let mut limiter = RateLimiter::new(Duration::from_millis(10));\n        limiter.try_acquire();\n        \n        let start = Instant::now();\n        limiter.wait().await;\n        assert!(start.elapsed() >= Duration::from_millis(10));\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] RateLimiter correctly limits operation frequency\n- [ ] Non-blocking check() and try_acquire() work correctly\n- [ ] Async wait() sleeps for correct duration\n- [ ] Blocking wait_blocking() works for sync contexts\n- [ ] Robot mode status reporting works\n- [ ] Reset functionality clears state\n\n## Logging Requirements\n- TRACE: Operation permitted/rate-limited, wait durations\n- DEBUG: Rate limiter created, reset\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.219455612Z","created_by":"ubuntu","updated_at":"2026-01-19T21:26:03.798745649Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1go","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.249333887Z","created_by":"ubuntu"}]}
{"id":"bd-1gx6","title":"Create test utilities and fixtures module","description":"# Create test utilities and fixtures module\n\n## Purpose\nEstablish a comprehensive test infrastructure that all other tests depend on. This module provides:\n- Output capture utilities (both stdout and rich_rust Console capture)\n- Mock device data factories\n- Environment variable helpers for NO_COLOR, FORCE_COLOR testing\n- Test Console configuration helpers\n- Assertion helpers for JSON structure validation\n\n## Background\nMultiple test beads (bd-i146, bd-usa2, bd-2lfp) reference utilities like capture_stdout(), mock_device_info(), etc. without a dedicated place to create them. This bead creates that foundation.\n\n## Location\ntests/common/mod.rs (standard Rust test utilities location)\n\n## Technical Details\n\n### File Structure\ntests/\n├── common/\n│   ├── mod.rs         # Main exports\n│   ├── capture.rs     # Output capture utilities\n│   ├── mocks.rs       # Mock data factories\n│   ├── env.rs         # Environment variable helpers\n│   └── assertions.rs  # Custom assertion helpers\n└── integration/\n    └── mod.rs         # Integration test harness\n\n### Output Capture (tests/common/capture.rs)\nImplements thread-safe stdout capture using gag crate or pipe-based redirection.\nAll capture functions include tracing instrumentation for debugging.\n\n### Mock Data Factories (tests/common/mocks.rs)\n- mock_device_xl() - Stream Deck XL with 32 keys\n- mock_device_mini() - Stream Deck Mini with 6 keys  \n- mock_device_with_serial(serial) - Custom serial number\n- mock_button_press(key) / mock_button_release(key)\n- mock_multiple_devices() - Returns vec of 3 devices\n\n### Environment Variable Helpers (tests/common/env.rs)\nRAII EnvGuard that restores environment on drop:\n- EnvGuard::set(key, value) \n- EnvGuard::remove(key)\nHelper functions: with_no_color(), with_force_color(), with_sd_format()\n\n### Custom Assertions (tests/common/assertions.rs)\n- assert_json_has_fields(json_str, fields)\n- assert_json_array_len(json_str, len)\n- assert_no_ansi(output)\n- assert_has_ansi(output)\n- assert_contains_all(output, expected)\n- assert_has_box_chars(output)\n- assert_has_ascii_box(output)\n\nAll assertions include error! logging before panic for debugging.\n\n### Test Console Factory\n- test_console() - 80 cols, TrueColor, forced terminal\n- test_console_no_color() - no color mode\n- test_console_ascii() - safe_box ASCII mode\n- init_test_logging() - initialize tracing for tests\n\n## Logging Integration\nAll test utilities include tracing instrumentation:\n- trace! for data creation details\n- debug! for operation flow\n- info! for significant events\n- error! for assertion failures\n\nRun tests with logging: RUST_LOG=debug cargo test\n\n## Implementation Steps\n1. Create tests/common/ directory structure\n2. Implement capture.rs with stdout capture\n3. Implement mocks.rs with device factories\n4. Implement env.rs with EnvGuard RAII helper\n5. Implement assertions.rs with custom assertions\n6. Create mod.rs with re-exports and console factories\n7. Add init_test_logging() for tracing integration\n8. Verify all helpers compile and work\n\n## Acceptance Criteria\n- [ ] All mock factories create valid test data\n- [ ] capture_stdout() correctly captures output  \n- [ ] EnvGuard properly restores environment\n- [ ] Custom assertions provide helpful error messages\n- [ ] Tracing integration works with RUST_LOG\n- [ ] Test helpers are documented with examples","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:22:24.306625979Z","created_by":"ubuntu","updated_at":"2026-01-19T21:48:10.534441388Z","compaction_level":0,"original_size":0,"labels":["infrastructure","phase-4","rich-rust","testing"],"dependencies":[{"issue_id":"bd-1gx6","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T21:48:10.534367208Z","created_by":"ubuntu"},{"issue_id":"bd-1gx6","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:22:56.859511712Z","created_by":"ubuntu"}]}
{"id":"bd-1gy","title":"Add PowerShell output format","description":"With --format powershell:\n- Use PowerShell syntax\n- Proper escaping for Windows paths\n- Different comment style","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:04.318755708Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:04.335099500Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1gy","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:04.335053844Z","created_by":"ubuntu"}]}
{"id":"bd-1he","title":"Write tests with sample profile files","description":"## Test Coverage for Elgato Profile Import\n\n### Unit Tests\n\n1. **ZIP Structure Validation**\n   - Valid .streamDeckProfile opens without error\n   - Invalid ZIP (corrupted) returns clear error\n   - Missing manifest.json returns error with suggestion\n   - Missing Profiles/ directory returns error\n   - Extra files in ZIP ignored (forward compat)\n\n2. **Manifest Parsing Tests**\n   - Parse Version field\n   - Parse DeviceUUID field\n   - Parse DeviceModel field (StreamDeckXL, StreamDeckMK2, etc.)\n   - Unknown DeviceModel logged as warning, proceeds\n   - Missing required fields return clear error\n\n3. **Profile JSON Parsing Tests**\n   - Parse profile Name and UUID\n   - Parse Keys array with all properties\n   - Parse Actions array (even if unsupported)\n   - Handle missing optional fields gracefully\n   - Handle extra unknown fields (forward compat)\n\n4. **Key Type Mapping Tests**\n   - Static image → KeyConfig::Image\n   - Solid color → KeyConfig::Color\n   - Website URL → log warning, convert to label or skip\n   - Folder → log warning, note nested structure\n   - Multi-action → log warning, list actions\n   - System action → map to shell command where possible\n\n5. **Image Extraction Tests**\n   - PNG images extracted correctly\n   - JPG images extracted correctly  \n   - Animated GIF → extract first frame, warn about animation\n   - Missing referenced image → clear error with path\n   - Image path resolution from relative to absolute\n\n### Integration Tests (require MockDevice)\n\n1. **Full Import Workflow**\n   - Import valid profile\n   - Verify all keys stored in config DB\n   - Verify images copied to config storage\n   - Apply imported profile to MockDevice\n   - Verify MockDevice state matches profile\n\n2. **Partial Import (Unsupported Features)**\n   - Import profile with folders\n   - Verify supported keys imported\n   - Verify warnings logged for unsupported\n   - Verify apply works for supported keys\n\n3. **Profile Management**\n   - `sd init --import profile.streamDeckProfile`\n   - `sd config list` shows imported profile\n   - `sd config show <name>` displays contents\n   - `sd apply <name>` applies to device\n\n4. **Image Storage Tests**\n   - Images stored with content-addressable names\n   - Duplicate images deduplicated\n   - Image retrieval works after import\n   - Storage handles large images\n\n### E2E Tests (require E2E harness)\n\n1. **CLI Import Flow**\n   - `sd init --import ~/Downloads/MySetup.streamDeckProfile`\n   - Verify exit code 0 on success\n   - Verify human-readable summary output\n   - Robot mode returns structured JSON\n\n2. **Error Handling**\n   - Non-existent file → clear error\n   - Non-ZIP file → \"not a valid profile\" error\n   - Profile for different device model → warning + proceed\n   - Permission denied → clear error\n\n3. **Round-Trip Test**\n   - Export profile from Elgato software\n   - Import to sd\n   - Apply to device\n   - Save as sd snapshot\n   - Compare snapshot to original profile\n\n### Test Fixtures (tests/fixtures/profiles/)\n\n```\nprofiles/\n├── valid/\n│   ├── minimal.streamDeckProfile     # Just manifest + 1 key\n│   ├── full-xl.streamDeckProfile     # 32 keys, various types\n│   ├── mk2-layout.streamDeckProfile  # 15 keys for MK2\n│   └── with-folders.streamDeckProfile # Nested folder structure\n├── unsupported/\n│   ├── with-multiaction.streamDeckProfile\n│   ├── with-animation.streamDeckProfile\n│   └── with-system-actions.streamDeckProfile\n├── invalid/\n│   ├── corrupted.streamDeckProfile   # Invalid ZIP\n│   ├── missing-manifest.streamDeckProfile\n│   ├── bad-json.streamDeckProfile    # Invalid JSON in profile\n│   └── missing-images.streamDeckProfile\n└── README.md                          # How to create test fixtures\n```\n\n### Fixture Creation Guide\n\nTo create test fixtures from Elgato software:\n1. Create profile in Stream Deck software\n2. Right-click profile → Export\n3. Copy to tests/fixtures/profiles/\n4. Document what's in the profile\n\n### Logging Requirements\n- DEBUG: Each file extracted from ZIP\n- INFO: Profile loaded, key count, device model\n- WARN: Unsupported features with feature name and impact\n- ERROR: Parse failures with location and suggestion","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.811560473Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:06.368185167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1he","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:47.355684984Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:06.368148297Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-2ky","type":"blocks","created_at":"2026-01-19T18:39:18.590934320Z","created_by":"ubuntu"},{"issue_id":"bd-1he","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.820941004Z","created_by":"ubuntu"}]}
{"id":"bd-1hi","title":"Implement dry-run for brightness command","description":"When dry_run=true:\n- Show current brightness (if readable)\n- Show target brightness\n- Show device info\n- Return without calling device\n\nRobot mode: JSON with action details\nHuman mode: formatted preview text","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.986179469Z","created_by":"ubuntu","updated_at":"2026-01-19T21:46:06.026038758Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1hi","depends_on_id":"bd-1uz","type":"blocks","created_at":"2026-01-19T21:46:05.352273194Z","created_by":"ubuntu"},{"issue_id":"bd-1hi","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.996911625Z","created_by":"ubuntu"},{"issue_id":"bd-1hi","depends_on_id":"bd-3lf","type":"blocks","created_at":"2026-01-19T21:46:06.025985197Z","created_by":"ubuntu"}]}
{"id":"bd-1im","title":"Add cache clear command","description":"Implement sd cache clear:\n- Remove all .bin files from cache directory\n- Report number of entries removed\n- Confirm before clearing (unless --force)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.939628450Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.957039341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1im","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.956989828Z","created_by":"ubuntu"}]}
{"id":"bd-1jf","title":"Obtain and bundle Inter font (OFL licensed)","description":"Add Inter font to binary:\n1. Download Inter-Regular.ttf from Google Fonts\n2. Place in assets/ directory\n3. Embed with include_bytes!()\n\nInter is OFL licensed - free to bundle.\nAlternative: Roboto, Source Sans Pro.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.288939436Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.299350899Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jf","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.299283902Z","created_by":"ubuntu"}]}
{"id":"bd-1jk","title":"Test generated completions for fish","description":"Manual testing (if fish available):\n1. Generate: sd completions fish > /tmp/sd.fish\n2. Source: source /tmp/sd.fish\n3. Test completion\n4. Verify no errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.082684903Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:12.269301415Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1jk","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:12.269263674Z","created_by":"ubuntu"},{"issue_id":"bd-1jk","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.091697852Z","created_by":"ubuntu"}]}
{"id":"bd-1kd","title":"Implement non-blocking command execution","description":"## Purpose\nExecute commands without blocking the watch loop so button events are always responsive.\n\n## Implementation\n```rust\n// src/hooks/executor.rs\nuse std::process::{Command, Child, Stdio};\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, warn, error, info, instrument};\n\n/// Manages background command execution with optional tracking\npub struct CommandExecutor {\n    /// Active child processes by key\n    active_children: HashMap<u8, TrackedChild>,\n    /// Maximum concurrent commands per key (prevents spam)\n    max_per_key: usize,\n    /// Default timeout for commands\n    default_timeout: Duration,\n}\n\nstruct TrackedChild {\n    child: Child,\n    started_at: Instant,\n    command: String,\n    key: u8,\n}\n\nimpl CommandExecutor {\n    pub fn new(default_timeout: Duration) -> Self {\n        Self {\n            active_children: HashMap::new(),\n            max_per_key: 1,  // One command per key at a time\n            default_timeout,\n        }\n    }\n    \n    /// Execute a command non-blocking, optionally tracking it\n    #[instrument(skip(self), fields(key = %key))]\n    pub fn execute(&mut self, key: u8, command: &str, track: bool) -> Result<Option<u32>> {\n        // Check if a command is already running for this key\n        if let Some(existing) = self.active_children.get(&key) {\n            warn!(\n                key = %key,\n                existing_pid = %existing.child.id(),\n                elapsed_ms = %existing.started_at.elapsed().as_millis(),\n                \"Command already running for key, skipping\"\n            );\n            return Ok(None);\n        }\n        \n        trace!(command = %command, \"Spawning command\");\n        \n        let child = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(command)\n            .stdin(Stdio::null())\n            .stdout(Stdio::piped())  // Capture for logging\n            .stderr(Stdio::piped())\n            .spawn()?;\n        \n        let pid = child.id();\n        info!(pid = %pid, key = %key, \"Command started\");\n        \n        if track {\n            self.active_children.insert(key, TrackedChild {\n                child,\n                started_at: Instant::now(),\n                command: command.to_string(),\n                key,\n            });\n        }\n        \n        Ok(Some(pid))\n    }\n    \n    /// Check for completed commands and log their results\n    #[instrument(skip(self))]\n    pub fn reap_completed(&mut self) -> Vec<CommandResult> {\n        let mut results = Vec::new();\n        let mut completed_keys = Vec::new();\n        \n        for (key, tracked) in &mut self.active_children {\n            match tracked.child.try_wait() {\n                Ok(Some(status)) => {\n                    let duration = tracked.started_at.elapsed();\n                    let exit_code = status.code().unwrap_or(-1);\n                    \n                    if status.success() {\n                        debug!(\n                            key = %key,\n                            exit_code = %exit_code,\n                            duration_ms = %duration.as_millis(),\n                            \"Command completed successfully\"\n                        );\n                    } else {\n                        warn!(\n                            key = %key,\n                            exit_code = %exit_code,\n                            duration_ms = %duration.as_millis(),\n                            command = %tracked.command,\n                            \"Command failed\"\n                        );\n                    }\n                    \n                    results.push(CommandResult {\n                        key: *key,\n                        exit_code,\n                        duration,\n                        command: tracked.command.clone(),\n                    });\n                    completed_keys.push(*key);\n                }\n                Ok(None) => {\n                    // Still running, check for timeout\n                    if tracked.started_at.elapsed() > self.default_timeout {\n                        error!(\n                            key = %key,\n                            pid = %tracked.child.id(),\n                            timeout_ms = %self.default_timeout.as_millis(),\n                            \"Command timed out, killing\"\n                        );\n                        let _ = tracked.child.kill();\n                        completed_keys.push(*key);\n                    }\n                }\n                Err(e) => {\n                    error!(key = %key, error = %e, \"Failed to check command status\");\n                    completed_keys.push(*key);\n                }\n            }\n        }\n        \n        for key in completed_keys {\n            self.active_children.remove(&key);\n        }\n        \n        results\n    }\n    \n    /// Kill all active commands (for cleanup)\n    pub fn kill_all(&mut self) {\n        for (key, mut tracked) in self.active_children.drain() {\n            warn!(\n                key = %key,\n                pid = %tracked.child.id(),\n                \"Killing active command on shutdown\"\n            );\n            let _ = tracked.child.kill();\n        }\n    }\n}\n\npub struct CommandResult {\n    pub key: u8,\n    pub exit_code: i32,\n    pub duration: Duration,\n    pub command: String,\n}\n```\n\n## Integration with Watch Loop\n```rust\n// In watch command handler\nlet mut executor = CommandExecutor::new(Duration::from_millis(opts.exec_timeout));\n\nloop {\n    // Reap any completed commands first\n    let completed = executor.reap_completed();\n    for result in completed {\n        if opts.robot {\n            emit_hook_result(&result);\n        }\n    }\n    \n    // Read device input\n    if let Some(event) = device.read_input(timeout)? {\n        // ... emit event ...\n        \n        if let Some(cmd) = resolve_command(&opts, &event) {\n            match executor.execute(event.key, &cmd, opts.robot) {\n                Ok(Some(pid)) => {\n                    if opts.robot {\n                        emit_hook_started(event.key, &cmd, pid);\n                    }\n                }\n                Ok(None) => { /* Skipped - already running */ }\n                Err(e) => error!(error = %e, \"Failed to execute command\"),\n            }\n        }\n    }\n}\n\n// On shutdown (Ctrl+C)\nexecutor.kill_all();\n```\n\n## Success Criteria\n- [ ] Commands execute without blocking event reading\n- [ ] Duplicate commands for same key are prevented\n- [ ] Timed out commands are killed\n- [ ] Completed commands are reaped and logged\n- [ ] All child processes cleaned up on shutdown\n\n## Logging Requirements\n- TRACE: Command being spawned, argument details\n- DEBUG: Command completed successfully, exit code, duration\n- INFO: Command started with PID\n- WARN: Command already running for key (skipped), command failed with non-zero exit\n- ERROR: Command timed out, failed to check status, failed to spawn","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.147168248Z","created_by":"ubuntu","updated_at":"2026-01-19T20:49:50.361905834Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kd","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.161513186Z","created_by":"ubuntu"}]}
{"id":"bd-1kw","title":"Write tests for batch operations","description":"## Test Coverage for All Batch Operations\n\n### Unit Tests - set-keys (require MockDevice - bd-180)\n\n1. **Pattern Parsing Tests**\n   - `key-{index}.png` parses correctly\n   - `icon_{index:02d}.jpg` with format specifiers\n   - Invalid patterns return clear errors\n   - Empty pattern handling\n\n2. **Directory Scanning Tests**\n   - Finds all matching files in flat directory\n   - Handles nested directories (should not recurse by default)\n   - Handles empty directories gracefully\n   - Handles non-existent directories with clear error\n   - Handles permission denied with clear error\n\n3. **Image Validation Tests**\n   - Valid PNG files accepted\n   - Valid JPG files accepted\n   - Corrupted images return specific error\n   - Non-image files (text, binary) rejected with clear error\n   - Zero-byte files rejected\n\n4. **Key Mapping Tests**\n   - key-00.png maps to key 0\n   - key-31.png maps to key 31\n   - key-32.png rejected (out of range for XL)\n   - Gaps handled correctly (key-00 and key-05 with nothing between)\n\n5. **Continue-On-Error Tests**\n   - Without flag: first error aborts entire operation\n   - With flag: collects all errors, continues processing\n   - Error report includes all failed keys and reasons\n   - Successful keys still applied even when some fail\n\n### Unit Tests - clear-keys\n\n6. **Range Parsing Tests**\n   - \"0-7\" parses to [0,1,2,3,4,5,6,7]\n   - \"0-31\" covers full XL device\n   - \"0-5\" on Mini (6 keys) works correctly\n   - \"0-10\" on Mini returns out-of-range error\n   - Invalid range \"7-0\" (reversed) handled\n\n7. **Clear Selection Tests**\n   - --all clears all keys for device model\n   - --range clears specified range\n   - Specific keys clear only those keys\n   - Conflicting options rejected\n\n### Unit Tests - fill-keys\n\n8. **Color Parsing Tests**\n   - \"#FF0000\" parses to red\n   - \"#F00\" shorthand parses correctly\n   - \"rgb(255,0,0)\" parses correctly\n   - \"red\" named color parses correctly\n   - Invalid \"#GGGGGG\" returns clear error\n   - Empty color returns error\n\n9. **Batch Fill Tests**\n   - All keys filled with same color\n   - Range filled correctly\n   - Specific keys filled correctly\n\n### Integration Tests (require MockDevice)\n\n10. **Full Device Operations**\n    - set-keys: Load 32 images for XL\n    - clear-keys --all: Clear all 32 keys\n    - fill-keys --all: Fill all 32 keys\n    - Verify via MockDevice assertions\n\n11. **Partial Operations**\n    - set-keys with gaps\n    - clear-keys --range 0-7 (first row only)\n    - fill-keys --keys 0 5 10 15 (specific keys)\n    - Verify untouched keys unchanged\n\n12. **Robot Mode Output**\n    - All batch commands return per-key status\n    - Summary includes total/success/failed counts\n    - Timing information included\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n13. **CLI Invocations**\n    - `sd set-keys ./test-dir/` \n    - `sd clear-keys --all`\n    - `sd clear-keys --range 0-7`\n    - `sd fill-keys \"#FF0000\" --all`\n    - `sd fill-keys \"blue\" --range 0-7`\n    - All with --robot flag variants\n\n14. **Error Handling**\n    - Invalid directory for set-keys\n    - Invalid range for clear-keys\n    - Invalid color for fill-keys\n    - All return appropriate exit codes\n\n### Logging Requirements\n- TRACE: Each key operation\n- DEBUG: Selection resolution, validation steps\n- INFO: Operation start/complete with counts\n- WARN: Skipped items with continue-on-error\n- ERROR: Failed operations with context","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:23:43.108243605Z","created_by":"ubuntu","updated_at":"2026-01-19T21:22:52.259793806Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1kw","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:34.167591460Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:49.161941811Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-2ky","type":"blocks","created_at":"2026-01-19T21:02:50.955950906Z","created_by":"ubuntu"},{"issue_id":"bd-1kw","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:43.117865321Z","created_by":"ubuntu"}]}
{"id":"bd-1lk","title":"Create theme system with SdTheme struct","description":"# Create theme system with SdTheme struct\n\n## Purpose\nDefine a cohesive visual identity for the Stream Deck CLI through a centralized theme system. This ensures consistent colors, styles, and visual elements across all commands.\n\n## Background\n\n### Why a Theme System?\nWithout centralized theme management:\n- Colors would be scattered across multiple files\n- Changing the visual identity would require editing many places\n- Inconsistent styling would create a disjointed experience\n\n### Design Philosophy\nThe theme should feel:\n- **Premium**: High-quality, polished appearance\n- **Technical**: Appropriate for a developer tool\n- **Branded**: Subtle Stream Deck identity (blue accent)\n- **Accessible**: Works on various terminal color schemes\n\n## Technical Details\n\n### Module Structure\n```\nsrc/theme/\n├── mod.rs       # SdTheme struct and Default impl\n└── (future: additional themes if needed)\n```\n\n### SdTheme Struct (src/theme/mod.rs)\n```rust\nuse rich_rust::prelude::*;\n\n/// Visual theme for Stream Deck CLI human-mode output\n/// \n/// This struct centralizes all colors and styles used throughout\n/// the CLI, ensuring visual consistency and easy customization.\npub struct SdTheme {\n    // ═══════════════════════════════════════════════════════\n    // Brand Colors\n    // ═══════════════════════════════════════════════════════\n    \n    /// Primary accent color (Stream Deck blue)\n    /// Used for: headers, panel borders, highlights\n    pub accent: Color,\n    \n    /// Success color (green)\n    /// Used for: success messages, checkmarks, positive states\n    pub success: Color,\n    \n    /// Error color (red)\n    /// Used for: error messages, X marks, negative states\n    pub error: Color,\n    \n    /// Warning color (amber)\n    /// Used for: warnings, key indices, attention items\n    pub warning: Color,\n    \n    /// Muted color (gray)\n    /// Used for: timestamps, secondary info, hints\n    pub muted: Color,\n    \n    // ═══════════════════════════════════════════════════════\n    // Component Styles\n    // ═══════════════════════════════════════════════════════\n    \n    /// Style for section headers\n    /// Applied to: device names, section titles\n    pub header: Style,\n    \n    /// Style for labels/keys in key-value pairs\n    /// Applied to: \"Serial:\", \"Firmware:\", etc.\n    pub label: Style,\n    \n    /// Style for values in key-value pairs\n    /// Applied to: actual serial numbers, versions, etc.\n    pub value: Style,\n    \n    /// Style for key indices (0-31)\n    /// Applied to: key numbers in events and operations\n    pub key_index: Style,\n    \n    /// Style for device serial numbers\n    /// Applied to: serial number display\n    pub device_serial: Style,\n    \n    /// Style for brightness values\n    /// Applied to: brightness percentage\n    pub brightness: Style,\n    \n    /// Style for button press events\n    /// Applied to: \"pressed\" state indicator\n    pub button_pressed: Style,\n    \n    /// Style for button release events\n    /// Applied to: \"released\" state indicator\n    pub button_released: Style,\n    \n    // ═══════════════════════════════════════════════════════\n    // Box Drawing\n    // ═══════════════════════════════════════════════════════\n    \n    /// Box character set for panels and tables\n    /// Default: ROUNDED (╭─╮) for modern terminals\n    /// Fallback: ASCII (+--+) when safe_box is enabled\n    pub box_style: &'static BoxChars,\n}\n```\n\n### Color Palette\n```rust\nimpl Default for SdTheme {\n    fn default() -> Self {\n        // Helper to parse color or panic (these are constants, so safe)\n        let color = |hex: &str| Color::parse(hex).expect(\"invalid theme color\");\n        \n        Self {\n            // Brand colors - carefully chosen for terminal visibility\n            accent: color(\"#0080FF\"),     // Stream Deck blue\n            success: color(\"#00D26A\"),    // Vibrant green\n            error: color(\"#FF4757\"),      // Soft red (not harsh)\n            warning: color(\"#FFA502\"),    // Amber/orange\n            muted: color(\"#747D8C\"),      // Medium gray\n            \n            // Component styles built from brand colors\n            header: Style::new()\n                .bold()\n                .color(color(\"#0080FF\")),\n            \n            label: Style::new()\n                .dim(),\n            \n            value: Style::new()\n                .bold(),\n            \n            key_index: Style::new()\n                .bold()\n                .color(color(\"#FFA502\")),\n            \n            device_serial: Style::new()\n                .italic()\n                .color(color(\"#747D8C\")),\n            \n            brightness: Style::new()\n                .bold()\n                .color(color(\"#00D26A\")),\n            \n            button_pressed: Style::new()\n                .bold()\n                .color(color(\"#00D26A\")),\n            \n            button_released: Style::new()\n                .dim(),\n            \n            box_style: &BoxChars::ROUNDED,\n        }\n    }\n}\n```\n\n### Usage Pattern\n```rust\nlet theme = SdTheme::default();\n\n// Use in output formatting\nlet mut text = Text::new(\"\");\ntext.append_styled(\"Serial: \", theme.label.clone());\ntext.append_styled(&device.serial, theme.device_serial.clone());\n\n// Use colors for panels\nlet panel = Panel::from_text(\"content\")\n    .border_style(Style::new().color(theme.accent));\n```\n\n## Color Selection Rationale\n\n### Accent (#0080FF)\n- Stream Deck devices feature blue LED backlighting\n- Blue conveys technology, reliability, precision\n- High visibility on both light and dark backgrounds\n\n### Success (#00D26A)\n- Standard \"green = good\" convention\n- Bright enough to stand out\n- Not so bright as to be harsh\n\n### Error (#FF4757)\n- Soft red that draws attention without being alarming\n- Readable against dark backgrounds\n- Not pure red (#FF0000) which can be harsh\n\n### Warning (#FFA502)\n- Amber/orange for caution\n- Distinct from both error (red) and success (green)\n- Used for key indices to make them pop\n\n### Muted (#747D8C)\n- Medium gray for secondary information\n- Readable but doesn't compete with primary content\n- Works on both light and dark terminals\n\n## Implementation Steps\n1. Create src/theme/ directory\n2. Create src/theme/mod.rs with SdTheme struct\n3. Implement Default trait with color palette\n4. Add mod theme; to main module\n5. Test color rendering in terminal\n\n## Verification\n```bash\ncargo check --all-targets\n# Manual: Create a test that prints all theme colors\n```\n\n## Future Considerations\n- Environment variable for theme selection (e.g., SD_THEME=dark)\n- High-contrast theme for accessibility\n- Theme customization via config file\n\n## Acceptance Criteria\n- [ ] src/theme/mod.rs exists with SdTheme struct\n- [ ] All colors parse correctly\n- [ ] Default implementation provides complete theme\n- [ ] Theme is usable from other modules\n- [ ] Colors render correctly in 24-bit terminal","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:03:31.559055622Z","created_by":"ubuntu","updated_at":"2026-01-19T21:48:08.434162318Z","compaction_level":0,"original_size":0,"labels":["design","phase-1","rich-rust","theme"],"dependencies":[{"issue_id":"bd-1lk","depends_on_id":"bd-1es","type":"blocks","created_at":"2026-01-19T21:48:08.434119587Z","created_by":"ubuntu"},{"issue_id":"bd-1lk","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:03:31.602205695Z","created_by":"ubuntu"},{"issue_id":"bd-1lk","depends_on_id":"bd-pnk","type":"blocks","created_at":"2026-01-19T21:03:31.606756994Z","created_by":"ubuntu"}]}
{"id":"bd-1mz","title":"Write tests for text rendering","description":"Test coverage:\n1. Basic text rendering produces valid image\n2. Positioning calculations\n3. Color parsing\n4. Multi-line handling\n5. Custom font loading\n6. Overlay on existing image","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:18.486160476Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:07.381545144Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1mz","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:49.883258559Z","created_by":"ubuntu"},{"issue_id":"bd-1mz","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:18.495504950Z","created_by":"ubuntu"},{"issue_id":"bd-1mz","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:07.381508044Z","created_by":"ubuntu"}]}
{"id":"bd-1n3","title":"Write tests for rate limiting","description":"## Purpose\nComprehensive test coverage for rate limiting functionality.\n\n## Test Coverage\n\n### Unit Tests - RateLimiter\n\n1. **Basic Operation Tests**\n\\`\\`\\`rust\n#[test]\nfn test_first_operation_allowed() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(100));\n    assert!(limiter.try_acquire());\n}\n\n#[test]\nfn test_immediate_second_blocked() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(100));\n    limiter.try_acquire();\n    assert!(!limiter.try_acquire());\n}\n\n#[test]\nfn test_check_is_readonly() {\n    let limiter = RateLimiter::new(Duration::from_millis(100));\n    assert!(limiter.check());\n    assert!(limiter.check()); // Still allowed after check\n}\n\\`\\`\\`\n\n2. **Timing Tests**\n\\`\\`\\`rust\n#[test]\nfn test_allowed_after_exact_interval() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(50));\n    limiter.try_acquire();\n    std::thread::sleep(Duration::from_millis(55));\n    assert!(limiter.try_acquire());\n}\n\n#[test]\nfn test_blocked_before_interval() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(100));\n    limiter.try_acquire();\n    std::thread::sleep(Duration::from_millis(50));\n    assert!(!limiter.try_acquire());\n}\n\n#[test]\nfn test_time_until_allowed_accuracy() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(100));\n    limiter.try_acquire();\n    let time = limiter.time_until_allowed();\n    assert!(time.as_millis() >= 95 && time.as_millis() <= 100);\n}\n\\`\\`\\`\n\n3. **Constructor Tests**\n\\`\\`\\`rust\n#[test]\nfn test_from_ops_per_second() {\n    let limiter = RateLimiter::from_ops_per_second(10.0);\n    assert_eq!(limiter.interval().as_millis(), 100);\n}\n\n#[test]\nfn test_from_ops_per_second_high_rate() {\n    let limiter = RateLimiter::from_ops_per_second(1000.0);\n    assert_eq!(limiter.interval().as_millis(), 1);\n}\n\\`\\`\\`\n\n4. **Async Tests**\n\\`\\`\\`rust\n#[tokio::test]\nasync fn test_async_wait_blocks() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(50));\n    limiter.try_acquire();\n    \n    let start = Instant::now();\n    limiter.wait().await;\n    assert!(start.elapsed() >= Duration::from_millis(45));\n}\n\n#[tokio::test]\nasync fn test_async_wait_immediate_if_allowed() {\n    let mut limiter = RateLimiter::new(Duration::from_millis(50));\n    \n    let start = Instant::now();\n    limiter.wait().await;\n    assert!(start.elapsed() < Duration::from_millis(10));\n}\n\\`\\`\\`\n\n### Unit Tests - TokenBucket\n\n5. **Burst Tests**\n\\`\\`\\`rust\n#[test]\nfn test_burst_capacity_exhausted() {\n    let mut bucket = TokenBucket::new(5, 1.0);\n    for _ in 0..5 {\n        assert!(bucket.try_acquire());\n    }\n    assert!(!bucket.try_acquire());\n}\n\n#[test]\nfn test_acquire_many_within_capacity() {\n    let mut bucket = TokenBucket::new(10, 1.0);\n    assert!(bucket.try_acquire_many(5));\n    assert!(bucket.try_acquire_many(5));\n    assert!(!bucket.try_acquire());\n}\n\n#[test]\nfn test_acquire_many_exceeds_capacity() {\n    let mut bucket = TokenBucket::new(5, 1.0);\n    assert!(!bucket.try_acquire_many(6));\n    assert_eq!(bucket.available(), 5.0); // Unchanged\n}\n\\`\\`\\`\n\n6. **Refill Tests**\n\\`\\`\\`rust\n#[test]\nfn test_refill_rate() {\n    let mut bucket = TokenBucket::new(10, 100.0); // 100/sec\n    for _ in 0..10 {\n        bucket.try_acquire();\n    }\n    \n    std::thread::sleep(Duration::from_millis(55));\n    let available = bucket.available();\n    assert!(available >= 4.5 && available <= 6.0);\n}\n\n#[test]\nfn test_refill_capped_at_capacity() {\n    let mut bucket = TokenBucket::new(5, 100.0);\n    std::thread::sleep(Duration::from_millis(100));\n    assert_eq!(bucket.available(), 5.0);\n}\n\n#[test]\nfn test_fractional_tokens() {\n    let mut bucket = TokenBucket::new(10, 10.0); // 10/sec\n    bucket.try_acquire_many(10);\n    \n    std::thread::sleep(Duration::from_millis(50)); // 0.5 tokens\n    assert!(!bucket.check()); // Need 1.0\n    \n    std::thread::sleep(Duration::from_millis(55)); // 0.5 more\n    assert!(bucket.check()); // Now have >= 1.0\n}\n\\`\\`\\`\n\n### Integration Tests - CLI\n\n7. **Rate Limit Flag Tests**\n\\`\\`\\`rust\n#[test]\nfn test_rate_limit_flag_parsing() {\n    // sd set-keys --rate-limit 50 ...\n    // Should create 50ms interval limiter\n}\n\n#[test]\nfn test_rate_limit_flag_default() {\n    // Without flag, no rate limiting\n}\n\\`\\`\\`\n\n8. **Batch Operations with Rate Limiting**\n\\`\\`\\`rust\n#[tokio::test]\nasync fn test_set_keys_with_rate_limit() {\n    let runner = CliRunner::new();\n    let mock = MockDevice::new();\n    \n    let start = Instant::now();\n    runner.run_with_device(mock, &[\n        \"set-keys\", \"--rate-limit\", \"100\", // 100ms between ops\n        \"images/*.png\"\n    ]).await;\n    \n    let elapsed = start.elapsed();\n    // 10 images * 100ms = ~1000ms\n    assert!(elapsed >= Duration::from_millis(900));\n}\n\\`\\`\\`\n\n### Robot Mode Tests\n\n9. **Rate Limit Status Reporting**\n\\`\\`\\`rust\n#[test]\nfn test_robot_mode_rate_limit_status() {\n    // When rate limited, robot mode output includes:\n    // { \"rate_limit\": { \"limited\": true, \"wait_ms\": 50, \"interval_ms\": 100 } }\n}\n\n#[test]\nfn test_robot_mode_includes_rate_info() {\n    let runner = CliRunner::new();\n    let output = runner.run(&[\n        \"--robot\", \"set-keys\", \"--rate-limit\", \"100\",\n        \"images/*.png\"\n    ]);\n    \n    let json: Value = serde_json::from_str(&output).unwrap();\n    assert!(json[\"operations\"][0][\"rate_limited\"].is_boolean());\n}\n\\`\\`\\`\n\n### Edge Case Tests\n\n10. **Boundary Conditions**\n\\`\\`\\`rust\n#[test]\nfn test_zero_interval_allowed() {\n    let mut limiter = RateLimiter::new(Duration::ZERO);\n    for _ in 0..100 {\n        assert!(limiter.try_acquire());\n    }\n}\n\n#[test]\nfn test_very_large_interval() {\n    let mut limiter = RateLimiter::new(Duration::from_secs(3600));\n    assert!(limiter.try_acquire());\n    assert_eq!(limiter.time_until_allowed().as_secs(), 3600);\n}\n\n#[test]\nfn test_token_bucket_zero_capacity() {\n    // Edge case: should this panic or always block?\n    // Document behavior\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] All RateLimiter methods tested\n- [ ] All TokenBucket methods tested\n- [ ] Timing tests pass within reasonable tolerance (±10ms)\n- [ ] CLI flag integration tested\n- [ ] Robot mode output verified\n- [ ] Edge cases documented and tested","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.853066162Z","created_by":"ubuntu","updated_at":"2026-01-19T21:28:01.344565907Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1n3","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:01.679672417Z","created_by":"ubuntu"},{"issue_id":"bd-1n3","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:08.720488751Z","created_by":"ubuntu"},{"issue_id":"bd-1n3","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.870109300Z","created_by":"ubuntu"}]}
{"id":"bd-1os","title":"Implement open_with_retry in device.rs","description":"## Purpose\nAdd robust connection retry logic to handle USB flakiness and disconnections.\n\n## Implementation\n\n### ConnectionOptions Struct\n```rust\n// src/device.rs\nuse std::time::Duration;\n\n#[derive(Debug, Clone)]\npub struct ConnectionOptions {\n    /// Maximum number of connection attempts (default: 3)\n    pub max_retries: u32,\n    /// Initial delay between retries (default: 1000ms)\n    pub retry_delay: Duration,\n    /// Exponential backoff factor (default: 1.5)\n    pub backoff_factor: f32,\n    /// Maximum delay cap (default: 10000ms)\n    pub max_delay: Duration,\n}\n\nimpl Default for ConnectionOptions {\n    fn default() -> Self {\n        Self {\n            max_retries: 3,\n            retry_delay: Duration::from_millis(1000),\n            backoff_factor: 1.5,\n            max_delay: Duration::from_millis(10000),\n        }\n    }\n}\n```\n\n### open_with_retry Method\n```rust\nimpl Device {\n    #[instrument(skip(self), fields(serial = ?serial, max_retries = %opts.max_retries))]\n    pub fn open_with_retry(\n        serial: Option<&str>,\n        opts: &ConnectionOptions,\n    ) -> Result<Self, DeviceError> {\n        let mut delay = opts.retry_delay;\n        \n        for attempt in 1..=opts.max_retries {\n            let span = span!(Level::DEBUG, \"connection_attempt\", attempt = %attempt);\n            let _enter = span.enter();\n            \n            match Self::open(serial) {\n                Ok(device) => {\n                    info!(attempt = %attempt, \"Device connected successfully\");\n                    return Ok(device);\n                }\n                Err(e) if e.is_connection_error() && attempt < opts.max_retries => {\n                    warn!(\n                        attempt = %attempt,\n                        max = %opts.max_retries,\n                        error = %e,\n                        delay_ms = %delay.as_millis(),\n                        \"Connection failed, retrying\"\n                    );\n                    std::thread::sleep(delay);\n                    delay = Duration::from_secs_f32(\n                        (delay.as_secs_f32() * opts.backoff_factor)\n                            .min(opts.max_delay.as_secs_f32())\n                    );\n                }\n                Err(e) => {\n                    error!(\n                        attempt = %attempt,\n                        error = %e,\n                        \"Connection failed, no more retries\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n        unreachable!()\n    }\n}\n```\n\n## Edge Cases\n- First attempt succeeds immediately (common case)\n- All retries exhausted → return final error with context\n- Non-connection errors (permission, etc.) → fail fast, no retry\n- Ctrl+C during sleep → propagate interrupt\n\n## Logging Requirements\n- TRACE: Entry/exit of retry loop iterations\n- DEBUG: Connection attempt start, delay calculation\n- INFO: Successful connection (with attempt count)\n- WARN: Failed attempt with retry pending\n- ERROR: Final failure after all retries exhausted\n\n## Success Criteria\n- [ ] Retries up to configured max\n- [ ] Exponential backoff applied correctly\n- [ ] Delay capped at max_delay\n- [ ] Connection errors trigger retry, others fail fast\n- [ ] Robot mode emits retry events as JSON","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.758006167Z","created_by":"ubuntu","updated_at":"2026-01-21T10:54:29.008246499Z","closed_at":"2026-01-21T10:54:29.008200603Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1os","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.774281400Z","created_by":"ubuntu"}]}
{"id":"bd-1po","title":"Test on different platforms","description":"Verify text rendering:\n1. Linux (font rendering consistency)\n2. macOS (different gamma/anti-aliasing)\n3. Windows (if applicable)\n\nBundled font should ensure consistent results.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.929869687Z","created_by":"ubuntu","updated_at":"2026-01-19T18:39:13.984774287Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1po","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.940706621Z","created_by":"ubuntu"},{"issue_id":"bd-1po","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:13.984739381Z","created_by":"ubuntu"}]}
{"id":"bd-1q4","title":"EPIC: Export to Shell Script","description":"## Overview\n**Rank: #10 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Medium**\n\nGenerate a shell script that recreates the current configuration.\n\n## Problem Statement\nUsers want to:\n- Share their Stream Deck setup with others\n- Back up their configuration in a portable format\n- Reproduce their setup on a new machine\n- Understand exactly what commands created their current state\n\nCurrently theres no way to export the configuration in a reproducible format.\n\n## Solution\nExport command that generates a self-contained shell script:\n```bash\nsd export-script > setup.sh\n# Generates:\n#!/bin/bash\n# Stream Deck configuration exported by sd\n# Device: Stream Deck XL (serial: ABC123)\n# Exported: 2024-01-15T10:30:00Z\n\nset -e\n\nsd brightness 80\nsd set-key 0 /absolute/path/to/chrome.png\nsd set-key 1 /absolute/path/to/slack.png\nsd fill-key 2 \"#FF5500\"\nsd set-key 3 /absolute/path/to/terminal.png\n# ... remaining keys\nsd clear-key 31\n\necho \"Configuration applied successfully\"\n```\n\nAdvanced options:\n```bash\n# Include images as base64 (self-contained)\nsd export-script --embed-images > setup.sh\n\n# Export specific profile\nsd export-script --profile work > work-setup.sh\n\n# Export as different format\nsd export-script --format makefile > Makefile.streamdeck\n```\n\n## Why This Is #10 Priority\n1. **Reproducibility**: Share and restore configurations easily\n2. **Backup strategy**: Simple text file captures everything\n3. **Debugging**: See exactly what commands create the state\n4. **Low effort**: ~60 lines if we track applied state\n5. **Complementary**: Works alongside other features\n\n## Technical Challenge: State Tracking\nLike SAVE-RESTORE, we face the challenge that Stream Deck hardware doesnt allow reading back the current state. Two approaches:\n\n### Approach A: Session History\nTrack commands applied during the current session:\n```rust\nstruct SessionHistory {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyCommand>,\n}\n\nenum KeyCommand {\n    SetImage(PathBuf),\n    FillColor(String),\n    Clear,\n}\n```\n- Pro: Accurate for current session\n- Con: Lost on restart\n\n### Approach B: Config-Based Export\nExport from declarative config or saved snapshot:\n```bash\nsd export-script --profile work  # Export from saved profile\nsd export-script --config work.yaml  # Export from config file\n```\n- Pro: Persistent, accurate\n- Con: Requires config system\n\n### Recommended: Support Both\n1. Session history for `sd export-script` (current session)\n2. Config-based for `sd export-script --profile <name>`\n\n## Implementation Approach\n\n### Phase 1: Session History Tracking\n```rust\n// In src/state.rs (new file, shared with SAVE-RESTORE)\nuse std::sync::Mutex;\nuse once_cell::sync::Lazy;\n\nstatic SESSION_STATE: Lazy<Mutex<SessionState>> = Lazy::new(|| {\n    Mutex::new(SessionState::default())\n});\n\n#[derive(Default)]\npub struct SessionState {\n    pub brightness: Option<u8>,\n    pub keys: HashMap<u8, KeyState>,\n}\n\npub enum KeyState {\n    Image(PathBuf),\n    Color(String),\n    Cleared,\n}\n\nimpl SessionState {\n    pub fn record_brightness(&mut self, level: u8) {\n        self.brightness = Some(level);\n    }\n    \n    pub fn record_set_key(&mut self, key: u8, path: PathBuf) {\n        self.keys.insert(key, KeyState::Image(path));\n    }\n    \n    pub fn record_fill_key(&mut self, key: u8, color: String) {\n        self.keys.insert(key, KeyState::Color(color));\n    }\n    \n    pub fn record_clear_key(&mut self, key: u8) {\n        self.keys.insert(key, KeyState::Cleared);\n    }\n}\n\n// Call from command handlers\npub fn track_brightness(level: u8) {\n    SESSION_STATE.lock().unwrap().record_brightness(level);\n}\n```\n\n### Phase 2: Export Command\n```rust\n// In src/cli/mod.rs\nExportScript {\n    /// Embed images as base64 (makes script self-contained)\n    #[arg(long)]\n    embed_images: bool,\n    \n    /// Export from saved profile instead of session\n    #[arg(long)]\n    profile: Option<String>,\n    \n    /// Output format\n    #[arg(long, default_value = \"bash\")]\n    format: ExportFormat,\n}\n\n#[derive(ValueEnum, Clone)]\nenum ExportFormat {\n    Bash,\n    Fish,\n    PowerShell,\n    Makefile,\n}\n\n// In main.rs\nfn cmd_export_script(opts: ExportOptions) -> Result<()> {\n    let state = if let Some(profile) = &opts.profile {\n        load_profile_state(profile)?\n    } else {\n        SESSION_STATE.lock().unwrap().clone()\n    };\n    \n    let script = generate_script(&state, &opts)?;\n    println!(\"{}\", script);\n    Ok(())\n}\n\nfn generate_script(state: &SessionState, opts: &ExportOptions) -> String {\n    let mut lines = vec![\n        \"#!/bin/bash\".to_string(),\n        format!(\"# Stream Deck configuration exported by sd\"),\n        format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()),\n        \"\".to_string(),\n        \"set -e\".to_string(),\n        \"\".to_string(),\n    ];\n    \n    if let Some(brightness) = state.brightness {\n        lines.push(format!(\"sd brightness {}\", brightness));\n    }\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => {\n                if opts.embed_images {\n                    let b64 = base64_encode_image(path)?;\n                    lines.push(format!(\n                        \"echo \\\"{}\\\" | base64 -d | sd set-key {} -\",\n                        b64, key\n                    ));\n                } else {\n                    lines.push(format!(\"sd set-key {} \\\"{}\\\"\", key, path.display()));\n                }\n            }\n            KeyState::Color(color) => {\n                lines.push(format!(\"sd fill-key {} \\\"{}\\\"\", key, color));\n            }\n            KeyState::Cleared => {\n                lines.push(format!(\"sd clear-key {}\", key));\n            }\n        }\n    }\n    \n    lines.push(\"\".to_string());\n    lines.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    lines.join(\"\\n\")\n}\n```\n\n## Key Design Decisions\n1. **Shell script default**: Most portable, universally understood\n2. **Absolute paths**: Avoid relative path confusion\n3. **Embed option**: Self-contained scripts for sharing\n4. **Multiple formats**: Bash, Fish, PowerShell for cross-platform\n5. **set -e**: Fail fast on errors\n\n## Success Criteria\n- [ ] Session commands are tracked in memory\n- [ ] `sd export-script` generates valid bash script\n- [ ] Generated script reproduces device state when run\n- [ ] `--embed-images` creates self-contained script\n- [ ] `--profile` exports from saved profile\n- [ ] Multiple output formats supported\n- [ ] Robot mode outputs structured JSON instead of script\n\n## Files to Create/Modify\n- `src/state.rs`: New session state tracking (shared with SAVE-RESTORE)\n- `src/cli/mod.rs`: Add ExportScript command\n- `src/main.rs`: Add state tracking calls, implement export\n- All command handlers: Add state tracking calls\n\n## Dependencies\n- Shares state tracking with SAVE-RESTORE epic\n- Benefits from DECLARATIVE-CONFIG for profile-based export\n\n## Estimated Subtasks\n1. Implement SessionState struct\n2. Add state tracking to all mutating commands\n3. Implement basic bash export\n4. Add --embed-images with base64 encoding\n5. Add --profile support (requires saved profiles)\n6. Add Fish output format\n7. Add PowerShell output format\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:57.831756849Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.230684166Z","compaction_level":0,"original_size":0,"labels":["backup","priority-10","reproducibility","sharing"],"dependencies":[{"issue_id":"bd-1q4","depends_on_id":"bd-34i","type":"blocks","created_at":"2026-01-19T18:23:22.230653178Z","created_by":"ubuntu"}]}
{"id":"bd-1q8","title":"Implement batch application loop","description":"Implement the main loop that:\n1. Iterates over matched key-file pairs\n2. Calls existing set_key_image for each\n3. Collects results (success/failure per key)\n4. Respects continue_on_error flag\n\nReuse existing image loading and device communication code.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.335879502Z","created_by":"ubuntu","updated_at":"2026-01-21T10:58:07.056598657Z","closed_at":"2026-01-21T10:58:07.056553071Z","close_reason":"Already implemented in cmd_set_keys() in main.rs:375-433","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1q8","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.356950264Z","created_by":"ubuntu"}]}
{"id":"bd-1r4","title":"EPIC: Declarative YAML/TOML Configuration","description":"## Overview\n**Rank: #7 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDefine device state in human-readable configuration files instead of imperative commands.\n\n## Problem Statement\nThe current CLI is imperative: users run commands to change state. This has limitations:\n- No single source of truth for desired configuration\n- Cant version control device setup\n- Cant easily share configurations\n- Cant diff or merge configurations\n- No way to declare \"this is what I want\" and have the tool figure out how to get there\n\n## Solution\nDeclarative configuration files in YAML or TOML:\n```yaml\n# ~/.config/sd/profiles/work.yaml\nname: Work Mode\nbrightness: 80\n\nkeys:\n  # Individual keys\n  0:\n    image: ~/icons/chrome.png\n    label: Browser  # Optional text overlay (future)\n  \n  1:\n    image: ~/icons/slack.png\n  \n  2:\n    color: \"#FF5500\"\n  \n  # Ranges with patterns\n  8-15:\n    pattern: ~/icons/apps/{index}.png\n  \n  # Rows\n  row-3:\n    color: \"#333333\"  # Fill entire row with color\n```\n\nUsage:\n```bash\nsd apply work.yaml           # Apply configuration\nsd apply work                # Apply from ~/.config/sd/profiles/work.yaml\nsd diff work.yaml            # Show what would change\nsd validate work.yaml        # Check configuration is valid\n```\n\n## Why This Is #7 Priority\n1. **Desired-state model**: Declare what you want, not how to get there\n2. **Version controllable**: Check your config into git\n3. **Composable**: Layer configs, override specific keys\n4. **Human-readable**: YAML/TOML are familiar and editable\n5. **Foundation for other features**: Hot-reload, profiles, etc.\n\n## Configuration Schema Design\n\n### YAML Format (Preferred for Readability)\n```yaml\n# Profile metadata\nname: My Profile\ndescription: Optional description\nbrightness: 80\n\n# Key definitions\nkeys:\n  # Explicit key index\n  0:\n    image: /absolute/path/to/image.png\n  \n  # Relative path (resolved from config file location)\n  1:\n    image: ./icons/slack.png\n  \n  # Home directory expansion\n  2:\n    image: ~/stream-deck/chrome.png\n  \n  # Solid color (hex)\n  3:\n    color: \"#FF5500\"\n  \n  # RGB color\n  4:\n    color: [255, 85, 0]\n  \n  # Clear key explicitly\n  5:\n    clear: true\n  \n  # Range with pattern\n  8-15:\n    pattern: ~/icons/row2/{index}.png\n    # Expands to: row2/08.png, row2/09.png, etc.\n  \n  # Named row (device-specific mapping)\n  row-0:\n    color: \"#222222\"  # Fill entire row\n  \n  # All remaining keys\n  default:\n    color: \"#000000\"  # Black background for unspecified keys\n\n# Optional: Device targeting\ndevice:\n  model: StreamDeckXL  # Only apply to this model\n  serial: ABC123       # Only apply to this serial\n```\n\n### TOML Format (Alternative)\n```toml\nname = \"My Profile\"\nbrightness = 80\n\n[keys.0]\nimage = \"~/icons/chrome.png\"\n\n[keys.1]\ncolor = \"#FF5500\"\n\n[keys.\"8-15\"]\npattern = \"~/icons/row2/{index}.png\"\n```\n\n## Implementation Approach\n\n### Phase 1: Schema Definition and Parsing\n```rust\n// In src/config/declarative.rs (new file)\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ProfileConfig {\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub brightness: Option<u8>,\n    pub keys: HashMap<KeySelector, KeyConfig>,\n    pub device: Option<DeviceFilter>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum KeySelector {\n    Single(u8),           // \"0\", \"15\"\n    Range(u8, u8),        // \"8-15\"\n    Row(u8),              // \"row-0\"\n    Default,              // \"default\"\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum KeyConfig {\n    Image { image: PathBuf },\n    Pattern { pattern: String },\n    Color { color: ColorSpec },\n    Clear { clear: bool },\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum ColorSpec {\n    Hex(String),          // \"#FF5500\"\n    Rgb([u8; 3]),         // [255, 85, 0]\n}\n```\n\n### Phase 2: Config Resolution\n```rust\nimpl ProfileConfig {\n    /// Resolve all selectors and patterns to concrete key assignments\n    pub fn resolve(&self, device: &DeviceInfo) -> Result<ResolvedProfile> {\n        let mut keys = HashMap::new();\n        \n        for (selector, config) in &self.keys {\n            let indices = selector.resolve(device)?;\n            for index in indices {\n                let resolved = config.resolve_for_key(index)?;\n                keys.insert(index, resolved);\n            }\n        }\n        \n        Ok(ResolvedProfile {\n            brightness: self.brightness,\n            keys,\n        })\n    }\n}\n```\n\n### Phase 3: Apply Logic\n```rust\nfn cmd_apply(device: &Device, config_path: &Path) -> Result<()> {\n    let config = load_config(config_path)?;\n    let resolved = config.resolve(device.info())?;\n    \n    // Apply brightness if specified\n    if let Some(brightness) = resolved.brightness {\n        device.set_brightness(brightness)?;\n    }\n    \n    // Apply keys\n    for (index, key_config) in &resolved.keys {\n        match key_config {\n            ResolvedKey::Image(path) => set_key_image(device, *index, path)?,\n            ResolvedKey::Color(color) => fill_key_color(device, *index, color)?,\n            ResolvedKey::Clear => clear_key(device, *index)?,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **YAML primary, TOML supported**: YAML is more readable for this use case\n2. **Flexible selectors**: Support individual keys, ranges, rows, and defaults\n3. **Pattern expansion**: `{index}` placeholder for batch definitions\n4. **Path resolution**: Support absolute, relative, and ~ paths\n5. **Device filtering**: Configs can target specific devices\n6. **Additive application**: Only touch keys that are specified\n\n## Diff and Validate Commands\n```bash\nsd diff work.yaml\n# Output:\n# Key 0: (empty) → ~/icons/chrome.png\n# Key 1: ~/icons/old.png → ~/icons/slack.png\n# Key 2: (no change)\n# Brightness: 50 → 80\n\nsd validate work.yaml\n# Output:\n# ✓ Valid YAML syntax\n# ✓ All image paths exist\n# ✓ All color values valid\n# ✓ Key indices within device range\n# ⚠ Key 33 out of range for Stream Deck XL (0-31)\n```\n\n## Success Criteria\n- [ ] YAML configuration files parsed correctly\n- [ ] TOML configuration files parsed correctly\n- [ ] Key selectors (single, range, row) resolve correctly\n- [ ] Pattern expansion works with {index} placeholder\n- [ ] Path expansion (~, relative) works correctly\n- [ ] `sd apply <config>` applies configuration to device\n- [ ] `sd validate <config>` checks configuration validity\n- [ ] `sd diff <config>` shows what would change\n- [ ] Robot mode returns structured JSON\n\n## Files to Create/Modify\n- `src/config/declarative.rs`: New module for declarative config\n- `src/cli/mod.rs`: Add Apply, Validate, Diff commands\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- Soft: ELGATO-IMPORT can generate declarative configs\n- Soft: SAVE-RESTORE can use declarative configs as storage format\n\n## Estimated Subtasks\n1. Design and document config schema\n2. Implement KeySelector parsing and resolution\n3. Implement KeyConfig parsing\n4. Implement path resolution (absolute, relative, ~)\n5. Implement pattern expansion\n6. Implement config loading (YAML + TOML)\n7. Implement apply command\n8. Implement validate command\n9. Implement diff command\n10. Write comprehensive tests","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:43.071432352Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:43.111176112Z","compaction_level":0,"original_size":0,"labels":["config","declarative","priority-7","user-experience"]}
{"id":"bd-1rhq","title":"Phase 3: Main.rs Integration and Wiring","description":"# Phase 3: Main.rs Integration and Wiring\n\n## Purpose\nWire up the new output system into main.rs, replacing scattered output logic with unified trait-based dispatch. This is the culmination of the architectural work - where everything comes together.\n\n## Background\nAfter Phase 1 (infrastructure) and Phase 2 (command implementations), we have:\n- Output trait with RobotOutput and HumanOutput implementations\n- Detailed formatting for all output types\n- Theme system for consistent styling\n\nPhase 3 connects these pieces to the actual CLI command dispatch.\n\n## Deliverables\n1. Refactored main.rs using OutputMode and Output trait\n2. Each command function updated to accept &dyn Output\n3. Removal of direct println! calls for output\n4. Removal of colored crate dependency\n\n## Architecture After Integration\n```\nmain() \n  → parse CLI args\n  → create OutputMode (robot or human)\n  → get Box<dyn Output>\n  → run(cli, output)\n      → match command\n          → cmd_list(cli, args, output)\n          → cmd_info(cli, output)\n          → cmd_brightness(cli, args, output)\n          → ...\n      → output.error(e) on failure\n```\n\n## Success Criteria\n- [ ] All output flows through Output trait\n- [ ] Robot mode produces identical JSON to before\n- [ ] Human mode produces beautiful styled output\n- [ ] No direct println! for user-facing output\n- [ ] colored crate removed from Cargo.toml\n- [ ] All tests pass\n- [ ] cargo clippy clean","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:08:31.378087425Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:31.417017362Z","compaction_level":0,"original_size":0,"labels":["integration","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-1rhq","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:08:31.411390127Z","created_by":"ubuntu"},{"issue_id":"bd-1rhq","depends_on_id":"bd-533","type":"blocks","created_at":"2026-01-19T21:08:31.416984520Z","created_by":"ubuntu"}]}
{"id":"bd-1rm","title":"Integrate hook execution into watch loop","description":"Modify watch command handler:\n1. Load keymap if specified\n2. On each event, resolve command\n3. Substitute placeholders\n4. Execute if command found\n5. Continue watching\n\nPriority: keymap > on-press/on-release > exec","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.736317029Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.751530874Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1rm","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.751477624Z","created_by":"ubuntu"}]}
{"id":"bd-1sb","title":"Add multi-line support","description":"Handle newlines in text:\n- Split on \\\\n\n- Calculate line height (font_size * 1.2)\n- Render each line\n- Adjust vertical positioning\n\nExample: sd text-key 0 \"Line 1\\\\nLine 2\"","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:17.397910630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:17.408254937Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1sb","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:17.408193742Z","created_by":"ubuntu"}]}
{"id":"bd-1sl","title":"EPIC: Dynamic Text Overlay on Images","description":"## Overview\n**Rank: #15 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nGenerate key images with text labels programmatically, without external image editing.\n\n## Problem Statement\nMost Stream Deck keys need labels. Currently users must:\n- Create images externally with text baked in\n- Use image editing software for simple text\n- Maintain separate image files for each variation\n- Manually update when text needs to change\n\nThis is especially painful for:\n- Dynamic content (build status, counters, time)\n- Localization (different languages)\n- AI agents that can generate text but not images\n\n## Solution\nText rendering commands and options:\n```bash\n# Text-only key (auto-generated background)\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n\n# Text overlay on existing image\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n\n# Multi-line text\nsd text-key 0 \"Line 1\\nLine 2\" --font-size 18\n\n# Dynamic text in declarative config\nkeys:\n  0:\n    image: ~/icons/cpu.png\n    text: \"${CPU_USAGE}%\"\n    text_position: center\n    text_color: white\n```\n\n## Why This Is #15 Priority\n1. **Font complexity**: Text rendering requires font handling\n2. **Platform differences**: Font availability varies by OS\n3. **Scope creep risk**: Leads toward full image editor\n4. **Medium effort**: ~150 lines plus dependencies\n5. **Workaround exists**: External image editing works today\n\n## Implementation Approach\n\n### Font Handling Strategy\nOptions:\n1. **Bundled font**: Include a single font (e.g., Inter, Roboto) in binary\n2. **System fonts**: Use fontconfig to find system fonts\n3. **User-specified**: `--font /path/to/font.ttf`\n\nRecommended: Bundle one good font, allow override.\n\n### Text Rendering with imageproc\n```rust\n// Add to Cargo.toml\n[dependencies]\nimageproc = \"0.23\"\nrusttype = \"0.9\"\n\n// Or use ab_glyph (more modern)\nab_glyph = \"0.2\"\n\n// In src/text.rs (new file)\nuse ab_glyph::{FontRef, PxScale};\nuse image::{Rgba, RgbaImage};\nuse imageproc::drawing::draw_text_mut;\n\npub struct TextOverlay {\n    pub text: String,\n    pub font_size: f32,\n    pub color: Rgba<u8>,\n    pub position: TextPosition,\n    pub font: Option<PathBuf>,\n}\n\npub enum TextPosition {\n    Top,\n    Center,\n    Bottom,\n    Custom { x: i32, y: i32 },\n}\n\n// Bundled font (embedded in binary)\nconst BUNDLED_FONT: &[u8] = include_bytes\\!(\"../assets/Inter-Regular.ttf\");\n\npub fn render_text_key(\n    width: u32,\n    height: u32,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = RgbaImage::from_pixel(width, height, opts.background);\n    \n    let font_data = opts.font\n        .as_ref()\n        .map(|p| std::fs::read(p).unwrap())\n        .unwrap_or_else(|| BUNDLED_FONT.to_vec());\n    \n    let font = FontRef::try_from_slice(&font_data).unwrap();\n    let scale = PxScale::from(opts.font_size);\n    \n    let (text_width, text_height) = measure_text(&font, scale, text);\n    let (x, y) = calculate_position(\n        width, height, \n        text_width, text_height, \n        &opts.position\n    );\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\npub fn overlay_text_on_image(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage {\n    let mut img = base.clone();\n    \n    // Similar to render_text_key but overlays on existing image\n    let font = load_font(&opts.font)?;\n    let scale = PxScale::from(opts.font_size);\n    \n    let (x, y) = calculate_position(\n        img.width(), img.height(),\n        measure_text(&font, scale, text),\n        &opts.position\n    );\n    \n    // Optional: draw background rectangle for readability\n    if opts.text_background {\n        draw_filled_rect_mut(&mut img, text_rect, opts.text_bg_color);\n    }\n    \n    draw_text_mut(&mut img, opts.color, x, y, scale, &font, text);\n    \n    img\n}\n\nfn calculate_position(\n    img_w: u32, img_h: u32,\n    text_w: u32, text_h: u32,\n    position: &TextPosition,\n) -> (i32, i32) {\n    match position {\n        TextPosition::Top => ((img_w - text_w) / 2, 2),\n        TextPosition::Center => ((img_w - text_w) / 2, (img_h - text_h) / 2),\n        TextPosition::Bottom => ((img_w - text_w) / 2, img_h - text_h - 2),\n        TextPosition::Custom { x, y } => (*x, *y),\n    }\n}\n```\n\n### CLI Integration\n```rust\n// In src/cli/mod.rs\nTextKey {\n    /// Key index (0-31)\n    key: u8,\n    /// Text to display\n    text: String,\n    /// Font size in pixels\n    #[arg(long, default_value = \"24\")]\n    font_size: f32,\n    /// Text color (hex)\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n    /// Background color (hex)\n    #[arg(long, default_value = \"#333333\")]\n    bg_color: String,\n    /// Text position (top, center, bottom)\n    #[arg(long, default_value = \"center\")]\n    position: TextPosition,\n    /// Custom font file path\n    #[arg(long)]\n    font: Option<PathBuf>,\n}\n\n// Add --text flag to SetKey\nSetKey {\n    key: u8,\n    image: PathBuf,\n    /// Overlay text on image\n    #[arg(long)]\n    text: Option<String>,\n    /// Text position for overlay\n    #[arg(long, default_value = \"bottom\")]\n    text_position: TextPosition,\n    /// Text color for overlay\n    #[arg(long, default_value = \"#FFFFFF\")]\n    text_color: String,\n}\n```\n\n## Key Design Decisions\n1. **Bundle one font**: Guaranteed availability, no system dependency\n2. **Allow font override**: Power users can specify custom fonts\n3. **Simple positioning**: Top/center/bottom covers 95% of use cases\n4. **Optional background**: Text background for readability on busy images\n5. **Hex colors**: Consistent with fill-key command\n\n## Multi-Line Text Support\n```rust\nfn render_multiline(text: &str, opts: &TextOverlay) -> RgbaImage {\n    let lines: Vec<&str> = text.split(n).collect();\n    let line_height = opts.font_size * 1.2;  // 120% line height\n    \n    // Calculate total height\n    let total_height = lines.len() as f32 * line_height;\n    \n    // Render each line\n    for (i, line) in lines.iter().enumerate() {\n        let y = start_y + (i as f32 * line_height);\n        draw_text_mut(&mut img, opts.color, x, y as i32, scale, &font, line);\n    }\n}\n```\n\n## Success Criteria\n- [ ] `sd text-key` creates text-only key images\n- [ ] `sd set-key --text` overlays text on images\n- [ ] Bundled font works on all platforms\n- [ ] Custom font via --font flag\n- [ ] Text positioning (top, center, bottom)\n- [ ] Hex color support for text and background\n- [ ] Multi-line text support\n- [ ] Robot mode reports text rendering details\n\n## Files to Create/Modify\n- `Cargo.toml`: Add ab_glyph, imageproc dependencies\n- `assets/Inter-Regular.ttf`: Bundled font file\n- `src/text.rs`: New text rendering module\n- `src/cli/mod.rs`: Add TextKey command, --text flag to SetKey\n- `src/main.rs`: Implement command handlers\n\n## Dependencies\n- None (standalone feature)\n\n## Estimated Subtasks\n1. Add font rendering dependencies\n2. Obtain and bundle Inter font (OFL licensed)\n3. Implement basic text rendering\n4. Implement text positioning\n5. Implement text overlay on images\n6. Add text-key command\n7. Add --text flag to set-key\n8. Add multi-line support\n9. Test on different platforms\n10. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:55.996344390Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:56.029651662Z","compaction_level":0,"original_size":0,"labels":["generation","images","priority-15","text"]}
{"id":"bd-1ur","title":"Design and document config schema","description":"## Purpose\nCreate formal schema documentation for declarative config files, serving as the reference for implementation.\n\n## Deliverables\n\n### 1. Schema Reference Document\nCreate `docs/config-schema.md`:\n\n```markdown\n# Stream Deck Configuration Schema\n\n## File Formats\nBoth YAML and TOML are supported. YAML is recommended for readability.\n\n## Top-Level Fields\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `name` | string | No | filename | Human-readable profile name |\n| `description` | string | No | null | Optional description |\n| `brightness` | integer | No | null | 0-100, null means don't change |\n| `keys` | map | No | {} | Key definitions (see below) |\n| `device` | object | No | null | Device filter (see below) |\n\n## Key Selectors\n\nKeys in the `keys` map use selector syntax:\n\n| Selector | Example | Matches | Description |\n|----------|---------|---------|-------------|\n| Single | `\"0\"`, `\"15\"` | One key | Direct key index |\n| Range | `\"8-15\"` | Multiple | Inclusive range |\n| Row | `\"row-0\"` | Varies | All keys in row (device-dependent) |\n| Column | `\"col-2\"` | Varies | All keys in column |\n| Default | `\"default\"` | Remaining | Keys not otherwise specified |\n\n**Resolution Order**: Single > Range > Row/Col > Default\n\n## Key Configuration\n\nEach key selector maps to one of these configurations:\n\n### Image\n```yaml\n0:\n  image: ~/icons/chrome.png\n```\n\n### Pattern (for ranges)\n```yaml\n8-15:\n  pattern: ~/icons/row2/{index}.png\n  # {index} expands to 08, 09, ..., 15\n```\n\n### Color\n```yaml\n# Hex format\n3:\n  color: \"#FF5500\"\n\n# RGB array\n4:\n  color: [255, 85, 0]\n\n# Named colors (optional enhancement)\n5:\n  color: red\n```\n\n### Clear\n```yaml\n6:\n  clear: true\n```\n\n## Path Resolution\n\nPaths are resolved in order:\n1. Absolute paths: Used as-is\n2. Home expansion: `~` expands to $HOME\n3. Relative paths: Resolved from config file's directory\n\n## Device Filter\n\n```yaml\ndevice:\n  model: StreamDeckXL      # Optional: only match this model\n  serial: \"ABC123\"         # Optional: only match this serial\n```\n\n## Full Example\n\n```yaml\nname: Work Profile\ndescription: My daily work setup\nbrightness: 80\n\ndevice:\n  model: StreamDeckXL\n\nkeys:\n  # App launchers (row 0)\n  0:\n    image: ~/icons/chrome.png\n  1:\n    image: ~/icons/slack.png\n  2:\n    image: ~/icons/terminal.png\n  3:\n    color: \"#FF5500\"  # Orange indicator\n  \n  # Numbered keys (row 1)\n  8-15:\n    pattern: ./numbers/{index}.png\n  \n  # Status row\n  row-3:\n    color: \"#222222\"\n  \n  # Everything else\n  default:\n    clear: true\n```\n```\n\n### 2. JSON Schema (for validation tools)\nCreate `schema/config.schema.json`:\n```json\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"Stream Deck Configuration\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"description\": { \"type\": \"string\" },\n    \"brightness\": { \"type\": \"integer\", \"minimum\": 0, \"maximum\": 100 },\n    \"keys\": {\n      \"type\": \"object\",\n      \"additionalProperties\": { \"$ref\": \"#/$defs/keyConfig\" }\n    },\n    \"device\": { \"$ref\": \"#/$defs/deviceFilter\" }\n  },\n  \"$defs\": {\n    \"keyConfig\": {\n      \"oneOf\": [\n        { \"type\": \"object\", \"properties\": { \"image\": { \"type\": \"string\" } }, \"required\": [\"image\"] },\n        { \"type\": \"object\", \"properties\": { \"pattern\": { \"type\": \"string\" } }, \"required\": [\"pattern\"] },\n        { \"type\": \"object\", \"properties\": { \"color\": {} }, \"required\": [\"color\"] },\n        { \"type\": \"object\", \"properties\": { \"clear\": { \"type\": \"boolean\" } }, \"required\": [\"clear\"] }\n      ]\n    },\n    \"deviceFilter\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"model\": { \"type\": \"string\" },\n        \"serial\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n```\n\n## Success Criteria\n- [ ] Schema document covers all field types\n- [ ] JSON Schema validates correctly\n- [ ] Examples are complete and correct\n- [ ] Edge cases documented (empty config, overlapping selectors)\n- [ ] Path resolution rules unambiguous\n\n## Logging Requirements\n- TRACE: (none - documentation task)\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.473608969Z","created_by":"ubuntu","updated_at":"2026-01-19T21:40:03.409822855Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ur","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.487834763Z","created_by":"ubuntu"}]}
{"id":"bd-1uz","title":"Add global --dry-run flag to CLI","description":"## Add Global CLI Flags\n\n### Complete Global Flags (src/cli/mod.rs)\n\n```rust\n#[derive(Parser, Debug)]\n#[command(name = \"sd\", version, about = \"Stream Deck CLI\")]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Command,\n\n    // === Output Control ===\n    \n    /// Output format: human or json\n    #[arg(long, short = 'f', global = true, value_enum, default_value = \"human\")]\n    pub format: OutputFormat,\n\n    /// Alias for --format=json (machine-readable output)\n    #[arg(long, short = 'r', global = true)]\n    pub robot: bool,\n\n    /// Preview what would happen without making changes\n    #[arg(long, short = 'n', global = true)]\n    pub dry_run: bool,\n\n    // === Verbosity ===\n    \n    /// Increase logging verbosity (-v = debug, -vv = trace)\n    #[arg(long, short = 'v', global = true, action = ArgAction::Count)]\n    pub verbose: u8,\n\n    /// Suppress non-error output\n    #[arg(long, short = 'q', global = true)]\n    pub quiet: bool,\n\n    // === Color Control ===\n    \n    /// Control color output: auto, always, never\n    #[arg(long, global = true, value_enum, default_value = \"auto\")]\n    pub color: ColorChoice,\n\n    // === Device Selection ===\n    \n    /// Select device by serial number\n    #[arg(long, short = 's', global = true)]\n    pub serial: Option<String>,\n\n    /// Select device by index (if multiple connected)\n    #[arg(long, short = 'd', global = true)]\n    pub device: Option<usize>,\n\n    // === Configuration ===\n    \n    /// Config directory (default: ~/.config/sd)\n    #[arg(long, global = true, env = \"SD_CONFIG_DIR\")]\n    pub config_dir: Option<PathBuf>,\n\n    /// Cache directory (default: ~/.cache/sd)\n    #[arg(long, global = true, env = \"SD_CACHE_DIR\")]\n    pub cache_dir: Option<PathBuf>,\n}\n\n#[derive(ValueEnum, Clone, Debug, Default)]\npub enum OutputFormat {\n    #[default]\n    Human,\n    Json,\n}\n\n#[derive(ValueEnum, Clone, Debug, Default)]\npub enum ColorChoice {\n    #[default]\n    Auto,\n    Always,\n    Never,\n}\n```\n\n### Flag Validation\n\n```rust\nimpl Cli {\n    pub fn validate(&self) -> Result<()> {\n        // Can't be quiet and verbose at the same time\n        if self.quiet && self.verbose > 0 {\n            return Err(CliError::ConflictingFlags(\"--quiet and --verbose\"));\n        }\n        \n        // Robot mode implies JSON format\n        // (handled by merging robot into format)\n        \n        Ok(())\n    }\n    \n    pub fn effective_format(&self) -> OutputFormat {\n        if self.robot {\n            OutputFormat::Json\n        } else {\n            self.format.clone()\n        }\n    }\n    \n    pub fn should_use_color(&self) -> bool {\n        match self.color {\n            ColorChoice::Always => true,\n            ColorChoice::Never => false,\n            ColorChoice::Auto => {\n                std::io::stdout().is_terminal() && \n                std::env::var(\"NO_COLOR\").is_err()\n            }\n        }\n    }\n}\n```\n\n### Environment Variable Support\n\n| Flag | Environment Variable | Description |\n|------|---------------------|-------------|\n| `--config-dir` | `SD_CONFIG_DIR` | Config directory |\n| `--cache-dir` | `SD_CACHE_DIR` | Cache directory |\n| `--color` | `NO_COLOR` | Disable color (if set) |\n| N/A | `RUST_LOG` | Logging level |\n\n### Help Text Integration\n\n```\nsd 0.1.0\nStream Deck CLI - Control your Elgato Stream Deck\n\nUSAGE:\n    sd [OPTIONS] <COMMAND>\n\nOPTIONS:\n    -f, --format <FORMAT>    Output format [default: human] [values: human, json]\n    -r, --robot              Machine-readable JSON output (same as --format=json)\n    -n, --dry-run            Preview changes without applying\n    -v, --verbose            Increase verbosity (-v, -vv)\n    -q, --quiet              Suppress non-error output\n        --color <WHEN>       Color output [default: auto] [values: auto, always, never]\n    -s, --serial <SERIAL>    Select device by serial number\n    -d, --device <INDEX>     Select device by index\n        --config-dir <DIR>   Config directory\n        --cache-dir <DIR>    Cache directory\n    -h, --help               Print help\n    -V, --version            Print version\n\nCOMMANDS:\n    list        List connected Stream Deck devices\n    info        Show device information\n    brightness  Set display brightness\n    ...\n```\n\n### Implementation Notes\n\n1. All global flags must be accessible in every command handler\n2. Robot mode (-r) should be shorthand for --format=json\n3. Verbose/quiet affect logging level via tracing initialization\n4. Color choice affects `colored` crate output\n5. Config/cache dirs should have XDG-compliant defaults","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:43.771173494Z","created_by":"ubuntu","updated_at":"2026-01-19T20:42:18.924419277Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1uz","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:43.800752005Z","created_by":"ubuntu"}]}
{"id":"bd-1v8","title":"EPIC: Gesture Support (Long-Press, Double-Tap)","description":"## Overview\n**Rank: #12 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium**\n\nDetect and report gesture events beyond simple press/release: long-press, double-tap, and hold.\n\n## Problem Statement\nStream Deck has 32 keys (on XL model). Currently each key can only do one thing: trigger on press. Users want more actions without more keys:\n- Tap for quick action, long-press for settings\n- Double-tap for alternate action\n- Hold for continuous/repeated action\n\n## Solution\nEnhanced event detection in watch mode:\n```bash\nsd watch --gestures\n\n# Output includes gesture classification:\n{\"key\": 5, \"gesture\": \"tap\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"long_press\", \"duration_ms\": 1200}\n{\"key\": 5, \"gesture\": \"double_tap\", \"interval_ms\": 150}\n{\"key\": 5, \"gesture\": \"hold_start\", \"timestamp\": \"...\"}\n{\"key\": 5, \"gesture\": \"hold_tick\", \"held_ms\": 500}\n{\"key\": 5, \"gesture\": \"hold_end\", \"total_ms\": 2500}\n```\n\nConfigurable thresholds:\n```bash\nsd watch --gestures \\\n  --long-press-ms 800 \\\n  --double-tap-ms 300 \\\n  --hold-tick-ms 100\n```\n\nIntegration with scripting hooks:\n```bash\nsd watch --gestures --keymap gestures.yaml\n```\n\n```yaml\n# gestures.yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: osascript -e \"tell Chrome to make new window\"\n  1:\n    tap: ~/scripts/toggle-mic.sh\n    hold: ~/scripts/push-to-talk.sh  # Runs while held\n```\n\n## Why This Is #12 Priority\n1. **Expressiveness**: 32 keys become 96+ possible actions\n2. **Standard UX pattern**: Users expect gesture support\n3. **Differentiator**: Most Stream Deck tools lack this\n4. **Moderate complexity**: State machine logic is fiddly\n5. **Subjective tuning**: \"Long press\" timing is personal preference\n\n## Implementation Approach\n\n### Gesture State Machine\n```rust\n// In src/gestures.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct GestureConfig {\n    pub long_press_threshold: Duration,   // Default: 800ms\n    pub double_tap_window: Duration,      // Default: 300ms\n    pub hold_tick_interval: Duration,     // Default: 100ms\n}\n\npub struct GestureDetector {\n    config: GestureConfig,\n    key_states: HashMap<u8, KeyGestureState>,\n}\n\nstruct KeyGestureState {\n    press_time: Option<Instant>,\n    last_tap_time: Option<Instant>,\n    is_held: bool,\n    last_tick: Option<Instant>,\n}\n\npub enum Gesture {\n    Tap { key: u8 },\n    DoubleTap { key: u8, interval: Duration },\n    LongPress { key: u8, duration: Duration },\n    HoldStart { key: u8 },\n    HoldTick { key: u8, held_for: Duration },\n    HoldEnd { key: u8, total: Duration },\n}\n\nimpl GestureDetector {\n    pub fn process_event(&mut self, event: &RawKeyEvent) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        let state = self.key_states.entry(event.key).or_default();\n        \n        match event.pressed {\n            true => {\n                // Key pressed\n                state.press_time = Some(Instant::now());\n                state.is_held = false;\n            }\n            false => {\n                // Key released\n                if let Some(press_time) = state.press_time.take() {\n                    let duration = press_time.elapsed();\n                    \n                    if duration >= self.config.long_press_threshold {\n                        // Long press\n                        gestures.push(Gesture::LongPress { \n                            key: event.key, \n                            duration \n                        });\n                    } else if state.is_held {\n                        // End of hold\n                        gestures.push(Gesture::HoldEnd {\n                            key: event.key,\n                            total: duration,\n                        });\n                    } else {\n                        // Potential tap or double-tap\n                        if let Some(last_tap) = state.last_tap_time {\n                            if last_tap.elapsed() < self.config.double_tap_window {\n                                gestures.push(Gesture::DoubleTap {\n                                    key: event.key,\n                                    interval: last_tap.elapsed(),\n                                });\n                                state.last_tap_time = None;\n                            } else {\n                                gestures.push(Gesture::Tap { key: event.key });\n                                state.last_tap_time = Some(Instant::now());\n                            }\n                        } else {\n                            state.last_tap_time = Some(Instant::now());\n                            // Defer tap emission until we know it is not double-tap\n                        }\n                    }\n                }\n                state.is_held = false;\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Call periodically to emit hold ticks and detect long-press during hold\n    pub fn tick(&mut self) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        \n        for (key, state) in &mut self.key_states {\n            if let Some(press_time) = state.press_time {\n                let held_for = press_time.elapsed();\n                \n                // Detect transition to hold\n                if !state.is_held && held_for >= self.config.long_press_threshold {\n                    state.is_held = true;\n                    gestures.push(Gesture::HoldStart { key: *key });\n                }\n                \n                // Emit hold ticks\n                if state.is_held {\n                    if state.last_tick.map(|t| t.elapsed() >= self.config.hold_tick_interval).unwrap_or(true) {\n                        gestures.push(Gesture::HoldTick { key: *key, held_for });\n                        state.last_tick = Some(Instant::now());\n                    }\n                }\n            }\n            \n            // Emit deferred taps (after double-tap window expires)\n            if let Some(last_tap) = state.last_tap_time {\n                if last_tap.elapsed() >= self.config.double_tap_window && state.press_time.is_none() {\n                    gestures.push(Gesture::Tap { key: *key });\n                    state.last_tap_time = None;\n                }\n            }\n        }\n        \n        gestures\n    }\n}\n```\n\n### Integration with Watch Loop\n```rust\nfn cmd_watch_with_gestures(device: &Device, opts: WatchOptions) -> Result<()> {\n    let mut detector = GestureDetector::new(GestureConfig {\n        long_press_threshold: Duration::from_millis(opts.long_press_ms),\n        double_tap_window: Duration::from_millis(opts.double_tap_ms),\n        hold_tick_interval: Duration::from_millis(opts.hold_tick_ms),\n    });\n    \n    loop {\n        // Check for raw events (short timeout)\n        if let Some(event) = device.read_input(Duration::from_millis(50))? {\n            let gestures = detector.process_event(&event);\n            for g in gestures {\n                emit_gesture(&g, opts.robot);\n            }\n        }\n        \n        // Process ticks for held keys and deferred events\n        let tick_gestures = detector.tick();\n        for g in tick_gestures {\n            emit_gesture(&g, opts.robot);\n        }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Deferred tap emission**: Wait for double-tap window before emitting tap\n2. **Hold distinct from long-press**: Long-press = released after threshold, Hold = still pressed\n3. **Configurable thresholds**: Personal preference varies widely\n4. **Tick-based detection**: Periodic polling for held key events\n5. **Backward compatible**: Without --gestures, behavior unchanged\n\n## Success Criteria\n- [ ] `--gestures` flag enables gesture detection\n- [ ] Tap events emitted after double-tap window\n- [ ] Double-tap detected within configurable window\n- [ ] Long-press detected on release after threshold\n- [ ] Hold events with periodic ticks while pressed\n- [ ] Threshold flags allow customization\n- [ ] Robot mode outputs structured gesture events\n- [ ] Keymap supports gesture-specific actions\n\n## Files to Create/Modify\n- `src/gestures.rs`: New gesture detection module\n- `src/cli/mod.rs`: Add gesture flags to Watch command\n- `src/main.rs`: Integrate gesture detector\n- `src/config/keymap.rs`: Add gesture-specific actions\n\n## Dependencies\n- Soft: Benefits from SCRIPTING-HOOKS (#8) for gesture-specific actions\n\n## Estimated Subtasks\n1. Design gesture state machine\n2. Implement GestureDetector struct\n3. Implement tap/double-tap detection with deferral\n4. Implement long-press detection\n5. Implement hold start/tick/end\n6. Add CLI flags for thresholds\n7. Integrate with watch loop\n8. Add keymap gesture support\n9. Write tests for edge cases","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:11.972191367Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.327002495Z","compaction_level":0,"original_size":0,"labels":["expressiveness","input","priority-12","watch"],"dependencies":[{"issue_id":"bd-1v8","depends_on_id":"bd-156","type":"blocks","created_at":"2026-01-19T18:23:22.326971206Z","created_by":"ubuntu"}]}
{"id":"bd-1vw","title":"Phase 1: Foundation Infrastructure","description":"# Phase 1: Foundation Infrastructure\n\n## Purpose\nEstablish the core architectural foundation for the rich_rust integration. This phase creates the abstraction layers that enable clean separation between robot mode (JSON) and human mode (styled output).\n\n## Why This Phase Comes First\nAll subsequent work depends on having:\n1. The rich_rust dependency available\n2. The Output trait abstraction in place\n3. The theme system for consistent styling\n4. The basic RobotOutput and HumanOutput implementations\n\nWithout this foundation, command implementations would have no consistent API to target.\n\n## Deliverables\n1. Cargo.toml updated with rich_rust dependency\n2. src/output/mod.rs with OutputMode enum and Output trait\n3. src/output/robot.rs with RobotOutput (refactored existing logic)\n4. src/output/human.rs with HumanOutput skeleton\n5. src/theme/mod.rs with SdTheme and color constants\n\n## Architectural Context\n\n### Output Trait\nThe Output trait defines a common interface for all output operations:\n- success(message) - Success messages\n- error(SdError) - Error display with suggestions\n- warning(message) - Warning messages\n- info(message) - Informational messages\n- device_list(devices) - Device listing\n- device_info(info) - Single device details\n- button_event(event) - Button press/release events\n- brightness_set(level) - Brightness confirmation\n- key_set(key, image) - Key image set confirmation\n- key_cleared(key) - Key clear confirmation\n- all_cleared() - All keys cleared confirmation\n- version_info(info) - Version display\n- rule(title) - Horizontal divider\n\n### OutputMode Enum\n```rust\npub enum OutputMode {\n    Robot(RobotFormat),\n    Human(Console),\n}\n```\n\nThis enum is created from CLI flags and passed to command handlers.\n\n### Theme System\nThe SdTheme struct provides consistent colors and styles:\n- Brand colors (accent, success, error, warning, muted)\n- Component styles (header, label, value, key_index, etc.)\n- Box style selection\n\n## Success Criteria\n- Output module compiles without errors\n- Existing robot mode behavior unchanged\n- Theme colors render correctly in 24-bit terminals\n- Foundation ready for command implementations","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-19T21:02:13.251951751Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:13.294044223Z","compaction_level":0,"original_size":0,"labels":["infrastructure","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-1vw","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:02:13.293964082Z","created_by":"ubuntu"}]}
{"id":"bd-1xd","title":"Implement RobotOutput for JSON output (refactor existing)","description":"# Implement RobotOutput for JSON output (refactor existing)\n\n## Purpose\nRefactor existing JSON output logic into a dedicated RobotOutput struct that implements the Output trait. This is a CRITICAL task because robot mode must remain UNCHANGED - AI agents depend on the exact JSON format.\n\n## Background\n\n### Why This Matters\nThe primary users of sd are AI coding agents. They parse JSON output programmatically. ANY change to the JSON structure could break agent workflows. This refactor must be behavior-preserving.\n\n### Current State\nThe current main.rs has JSON output scattered through match arms:\nif cli.use_json() {\n    println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n} else {\n    // human output\n}\n\n### Target State  \n// In command function\noutput.device_list(&devices);  // Output trait method\n\n// RobotOutput implementation\nfn device_list(&self, devices: &[DeviceInfo]) {\n    self.output_json(devices);\n}\n\n## Technical Details\n\n### RobotOutput Struct (src/output/robot.rs)\nuse serde::Serialize;\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse super::{Output, RobotFormat};\nuse std::path::Path;\nuse tracing::{debug, trace, instrument};\n\n/// JSON output implementation for AI agents and scripting\n/// \n/// CRITICAL: This implementation must produce IDENTICAL output to the\n/// current behavior. Any changes to JSON structure will break agents.\npub struct RobotOutput {\n    format: RobotFormat,\n}\n\nimpl RobotOutput {\n    #[instrument]\n    pub fn new(format: RobotFormat) -> Self {\n        debug!(?format, \"Creating RobotOutput\");\n        Self { format }\n    }\n    \n    /// Internal helper to output any serializable data as JSON\n    #[instrument(skip(self, data), fields(format = ?self.format))]\n    fn output_json<T: Serialize>(&self, data: &T) {\n        let json = match self.format {\n            RobotFormat::Json => {\n                trace!(\"Serializing as pretty JSON\");\n                serde_json::to_string_pretty(data)\n                    .expect(\"serialization failed\")\n            }\n            RobotFormat::JsonCompact => {\n                trace!(\"Serializing as compact JSON\");\n                serde_json::to_string(data)\n                    .expect(\"serialization failed\")\n            }\n        };\n        trace!(json_len = json.len(), \"JSON serialized\");\n        println!(\"{json}\");\n    }\n    \n    /// Output single-line JSON (for streaming events)\n    #[instrument(skip(self, data))]\n    fn output_json_line<T: Serialize>(&self, data: &T) {\n        let json = serde_json::to_string(data).expect(\"serialization failed\");\n        trace!(json_len = json.len(), \"JSON line serialized\");\n        println!(\"{json}\");\n    }\n}\n\n### Error Response Structure\n/// JSON structure for error responses\n/// MUST match current format exactly\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: bool,\n    message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    suggestion: Option<String>,\n    recoverable: bool,\n}\n\n### Output Trait Implementation with Tracing\nimpl Output for RobotOutput {\n    #[instrument(skip(self))]\n    fn success(&self, message: &str) {\n        debug!(message, \"Robot: success\");\n        self.output_json(&serde_json::json!({\n            \"success\": true,\n            \"message\": message\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn error(&self, error: &SdError) {\n        debug!(error = %error, \"Robot: error\");\n        self.output_json(&ErrorResponse {\n            error: true,\n            message: error.to_string(),\n            suggestion: error.suggestion().map(String::from),\n            recoverable: error.is_user_recoverable(),\n        });\n    }\n    \n    #[instrument(skip(self))]\n    fn warning(&self, message: &str) {\n        debug!(message, \"Robot: warning\");\n        self.output_json(&serde_json::json!({\n            \"warning\": true,\n            \"message\": message\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn info(&self, message: &str) {\n        debug!(message, \"Robot: info\");\n        self.output_json(&serde_json::json!({\n            \"info\": true,\n            \"message\": message\n        }));\n    }\n    \n    #[instrument(skip(self, devices), fields(count = devices.len()))]\n    fn device_list(&self, devices: &[DeviceInfo]) {\n        debug!(\"Robot: device_list\");\n        // Direct serialization - DeviceInfo already derives Serialize\n        self.output_json(devices);\n    }\n    \n    #[instrument(skip(self, info), fields(serial = %info.serial))]\n    fn device_info(&self, info: &DeviceInfo) {\n        debug!(\"Robot: device_info\");\n        self.output_json(info);\n    }\n    \n    #[instrument(skip(self, event), fields(key = event.key, pressed = event.pressed))]\n    fn button_event(&self, event: &ButtonEvent) {\n        trace!(\"Robot: button_event\");\n        // Single-line JSON for streaming (important for pipe consumers)\n        self.output_json_line(event);\n    }\n    \n    #[instrument(skip(self, states), fields(count = states.len()))]\n    fn button_states(&self, states: &[bool]) {\n        debug!(\"Robot: button_states\");\n        self.output_json(states);\n    }\n    \n    #[instrument(skip(self))]\n    fn brightness_set(&self, level: u8) {\n        debug!(level, \"Robot: brightness_set\");\n        self.output_json(&serde_json::json!({\n            \"brightness\": level,\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self, image))]\n    fn key_set(&self, key: u8, image: &Path) {\n        debug!(key, image = %image.display(), \"Robot: key_set\");\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"image\": image.display().to_string(),\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn key_cleared(&self, key: u8) {\n        debug!(key, \"Robot: key_cleared\");\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"cleared\": true,\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn key_filled(&self, key: u8, color: &str) {\n        debug!(key, color, \"Robot: key_filled\");\n        self.output_json(&serde_json::json!({\n            \"key\": key,\n            \"color\": color,\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn all_cleared(&self) {\n        debug!(\"Robot: all_cleared\");\n        self.output_json(&serde_json::json!({\n            \"all_cleared\": true,\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn all_filled(&self, color: &str) {\n        debug!(color, \"Robot: all_filled\");\n        self.output_json(&serde_json::json!({\n            \"all_filled\": true,\n            \"color\": color,\n            \"ok\": true\n        }));\n    }\n    \n    #[instrument(skip(self))]\n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n        debug!(version, ?git_sha, ?build_time, \"Robot: version_info\");\n        self.output_json(&serde_json::json!({\n            \"version\": version,\n            \"git_sha\": git_sha,\n            \"build_time\": build_time\n        }));\n    }\n    \n    // Visual separators are no-ops in robot mode\n    fn rule(&self, _title: Option<&str>) {\n        // No-op: rules are visual-only\n        trace!(\"Robot: rule (no-op)\");\n    }\n    \n    fn newline(&self) {\n        // No-op: whitespace is visual-only\n        trace!(\"Robot: newline (no-op)\");\n    }\n}\n\n## Logging Guidelines\n- #[instrument] on all public methods\n- debug! for method entry with key data\n- trace! for internal operations\n- Never log the actual JSON (could be large), log length instead\n- Robot mode logging goes to stderr (won't pollute JSON stdout)\n\nRun with logging: RUST_LOG=sd::output=debug cargo run -- list --robot\n\n## Verification Strategy\n\n### Before Refactor\nCapture current output for each command:\nsd list --robot > /tmp/before_list.json\nsd info --robot > /tmp/before_info.json\n\n### After Refactor  \nCompare output:\nsd list --robot > /tmp/after_list.json\ndiff /tmp/before_list.json /tmp/after_list.json\n# Must be empty (no differences)\n\n## Implementation Steps\n1. Create src/output/robot.rs\n2. Add tracing imports\n3. Define RobotOutput struct with format field\n4. Define ErrorResponse and other helper structs\n5. Implement Output trait with #[instrument] on all methods\n6. Add regression tests comparing old vs new output\n7. Verify all JSON formats match exactly\n8. Test logging with RUST_LOG\n\n## Acceptance Criteria\n- [ ] RobotOutput implements all Output trait methods\n- [ ] All methods have #[instrument] attribute\n- [ ] JSON output is byte-for-byte identical to current behavior\n- [ ] Streaming events (button_event) use single-line JSON\n- [ ] Rule and newline are silent no-ops\n- [ ] Unit tests verify JSON structure\n- [ ] No ANSI codes ever appear in robot mode output\n- [ ] RUST_LOG=debug shows method invocations (to stderr)\n- [ ] Logging does not affect stdout JSON","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:04.135537208Z","created_by":"ubuntu","updated_at":"2026-01-19T21:48:09.136556158Z","compaction_level":0,"original_size":0,"labels":["json","phase-1","rich-rust","robot-mode"],"dependencies":[{"issue_id":"bd-1xd","depends_on_id":"bd-1es","type":"blocks","created_at":"2026-01-19T21:04:04.174049018Z","created_by":"ubuntu"},{"issue_id":"bd-1xd","depends_on_id":"bd-1lk","type":"blocks","created_at":"2026-01-19T21:48:09.136489413Z","created_by":"ubuntu"},{"issue_id":"bd-1xd","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:04:04.169371622Z","created_by":"ubuntu"}]}
{"id":"bd-1xp","title":"Add connection event emission for robot mode","description":"## Purpose\nEmit JSON events for device connection state changes in robot mode, enabling AI agents to monitor and react to connectivity issues.\n\n## Implementation\n\n```rust\n// src/output/events.rs\nuse serde::Serialize;\nuse chrono::{DateTime, Utc};\n\n/// Connection state events for robot mode output\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"event\")]\npub enum ConnectionEvent {\n    /// Device was connected and is ready\n    #[serde(rename = \"connected\")]\n    Connected {\n        timestamp: DateTime<Utc>,\n        device: DeviceInfo,\n    },\n    \n    /// Device was disconnected\n    #[serde(rename = \"disconnected\")]\n    Disconnected {\n        timestamp: DateTime<Utc>,\n        reason: DisconnectReason,\n        was_healthy: bool,\n    },\n    \n    /// Attempting to reconnect\n    #[serde(rename = \"reconnecting\")]\n    Reconnecting {\n        timestamp: DateTime<Utc>,\n        attempt: u32,\n        max_attempts: u32,\n        delay_ms: u64,\n        reason: String,\n    },\n    \n    /// Successfully reconnected after disconnection\n    #[serde(rename = \"reconnected\")]\n    Reconnected {\n        timestamp: DateTime<Utc>,\n        device: DeviceInfo,\n        attempts_taken: u32,\n        downtime_ms: u64,\n    },\n    \n    /// Gave up trying to reconnect\n    #[serde(rename = \"reconnect_failed\")]\n    ReconnectFailed {\n        timestamp: DateTime<Utc>,\n        attempts_made: u32,\n        total_downtime_ms: u64,\n        last_error: String,\n    },\n    \n    /// Periodic health check status\n    #[serde(rename = \"health_check\")]\n    HealthCheck {\n        timestamp: DateTime<Utc>,\n        healthy: bool,\n        latency_ms: Option<u32>,\n        error: Option<String>,\n    },\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct DeviceInfo {\n    pub model: String,\n    pub serial: String,\n    pub firmware: String,\n    pub key_count: u8,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum DisconnectReason {\n    UsbError,\n    Timeout,\n    DeviceRemoved,\n    Unknown,\n}\n\nimpl ConnectionEvent {\n    /// Create connected event\n    pub fn connected(device: &crate::device::DeviceInfo) -> Self {\n        Self::Connected {\n            timestamp: Utc::now(),\n            device: DeviceInfo {\n                model: format!(\"{:?}\", device.model),\n                serial: device.serial.clone(),\n                firmware: device.firmware.clone(),\n                key_count: device.key_count,\n            },\n        }\n    }\n    \n    /// Create disconnected event\n    pub fn disconnected(reason: DisconnectReason, was_healthy: bool) -> Self {\n        Self::Disconnected {\n            timestamp: Utc::now(),\n            reason,\n            was_healthy,\n        }\n    }\n    \n    /// Create reconnecting event\n    pub fn reconnecting(attempt: u32, max_attempts: u32, delay_ms: u64, reason: &str) -> Self {\n        Self::Reconnecting {\n            timestamp: Utc::now(),\n            attempt,\n            max_attempts,\n            delay_ms,\n            reason: reason.to_string(),\n        }\n    }\n    \n    /// Create reconnected event\n    pub fn reconnected(\n        device: &crate::device::DeviceInfo,\n        attempts_taken: u32,\n        downtime_ms: u64,\n    ) -> Self {\n        Self::Reconnected {\n            timestamp: Utc::now(),\n            device: DeviceInfo {\n                model: format!(\"{:?}\", device.model),\n                serial: device.serial.clone(),\n                firmware: device.firmware.clone(),\n                key_count: device.key_count,\n            },\n            attempts_taken,\n            downtime_ms,\n        }\n    }\n    \n    /// Serialize to JSON line\n    pub fn to_json(&self) -> String {\n        serde_json::to_string(self).unwrap_or_else(|_| \"{}\".to_string())\n    }\n}\n```\n\n## JSON Output Examples\n\n### Connected\n```json\n{\n  \"event\": \"connected\",\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\",\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"serial\": \"AL12XL00001\",\n    \"firmware\": \"1.03.004\",\n    \"key_count\": 32\n  }\n}\n```\n\n### Disconnected\n```json\n{\n  \"event\": \"disconnected\",\n  \"timestamp\": \"2024-01-15T10:35:00.000Z\",\n  \"reason\": \"usb_error\",\n  \"was_healthy\": true\n}\n```\n\n### Reconnecting\n```json\n{\n  \"event\": \"reconnecting\",\n  \"timestamp\": \"2024-01-15T10:35:02.000Z\",\n  \"attempt\": 1,\n  \"max_attempts\": 5,\n  \"delay_ms\": 2000,\n  \"reason\": \"USB error: device not responding\"\n}\n```\n\n### Reconnected\n```json\n{\n  \"event\": \"reconnected\",\n  \"timestamp\": \"2024-01-15T10:35:08.500Z\",\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"serial\": \"AL12XL00001\",\n    \"firmware\": \"1.03.004\",\n    \"key_count\": 32\n  },\n  \"attempts_taken\": 3,\n  \"downtime_ms\": 8500\n}\n```\n\n### Reconnect Failed\n```json\n{\n  \"event\": \"reconnect_failed\",\n  \"timestamp\": \"2024-01-15T10:35:30.000Z\",\n  \"attempts_made\": 5,\n  \"total_downtime_ms\": 30000,\n  \"last_error\": \"Device not found after 5 reconnection attempts\"\n}\n```\n\n### Health Check\n```json\n{\n  \"event\": \"health_check\",\n  \"timestamp\": \"2024-01-15T10:31:00.000Z\",\n  \"healthy\": true,\n  \"latency_ms\": 12,\n  \"error\": null\n}\n```\n\n## Integration\n\n```rust\n// In connection health monitor\nimpl ConnectionMonitor {\n    fn emit_event(&self, event: ConnectionEvent) {\n        if self.robot_mode {\n            println!(\"{}\", event.to_json());\n        } else {\n            // Human-readable logging handled by tracing\n        }\n    }\n    \n    async fn handle_disconnect(&mut self, reason: DisconnectReason) {\n        let was_healthy = self.last_healthy;\n        self.emit_event(ConnectionEvent::disconnected(reason, was_healthy));\n        \n        // Start reconnection loop\n        for attempt in 1..=self.max_attempts {\n            let delay = self.backoff.next_delay(attempt);\n            self.emit_event(ConnectionEvent::reconnecting(\n                attempt,\n                self.max_attempts,\n                delay.as_millis() as u64,\n                &self.last_error,\n            ));\n            \n            tokio::time::sleep(delay).await;\n            \n            if let Ok(device) = self.try_reconnect().await {\n                let downtime = self.disconnect_time.elapsed().as_millis() as u64;\n                self.emit_event(ConnectionEvent::reconnected(&device, attempt, downtime));\n                return;\n            }\n        }\n        \n        // Failed to reconnect\n        let downtime = self.disconnect_time.elapsed().as_millis() as u64;\n        self.emit_event(ConnectionEvent::reconnect_failed(\n            self.max_attempts,\n            downtime,\n            &self.last_error,\n        ));\n    }\n}\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_connected_event_json() {\n        let device = crate::device::DeviceInfo {\n            model: crate::device::DeviceModel::XL,\n            serial: \"TEST123\".to_string(),\n            firmware: \"1.0\".to_string(),\n            key_count: 32,\n            ..Default::default()\n        };\n        \n        let event = ConnectionEvent::connected(&device);\n        let json = event.to_json();\n        \n        assert!(json.contains(\"\\\"event\\\":\\\"connected\\\"\"));\n        assert!(json.contains(\"\\\"model\\\":\\\"XL\\\"\"));\n        assert!(json.contains(\"\\\"serial\\\":\\\"TEST123\\\"\"));\n    }\n    \n    #[test]\n    fn test_disconnected_event_json() {\n        let event = ConnectionEvent::disconnected(DisconnectReason::UsbError, true);\n        let json = event.to_json();\n        \n        assert!(json.contains(\"\\\"event\\\":\\\"disconnected\\\"\"));\n        assert!(json.contains(\"\\\"reason\\\":\\\"usb_error\\\"\"));\n        assert!(json.contains(\"\\\"was_healthy\\\":true\"));\n    }\n    \n    #[test]\n    fn test_reconnecting_event_json() {\n        let event = ConnectionEvent::reconnecting(2, 5, 4000, \"timeout\");\n        let json = event.to_json();\n        \n        assert!(json.contains(\"\\\"event\\\":\\\"reconnecting\\\"\"));\n        assert!(json.contains(\"\\\"attempt\\\":2\"));\n        assert!(json.contains(\"\\\"max_attempts\\\":5\"));\n        assert!(json.contains(\"\\\"delay_ms\\\":4000\"));\n    }\n    \n    #[test]\n    fn test_all_events_parse_as_json() {\n        let events = vec![\n            ConnectionEvent::disconnected(DisconnectReason::Timeout, false),\n            ConnectionEvent::reconnecting(1, 3, 1000, \"test\"),\n            ConnectionEvent::reconnect_failed(3, 5000, \"gave up\"),\n            ConnectionEvent::health_check(true, Some(15), None),\n        ];\n        \n        for event in events {\n            let json = event.to_json();\n            let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();\n            assert!(parsed.get(\"event\").is_some());\n            assert!(parsed.get(\"timestamp\").is_some());\n        }\n    }\n}\n\n// Helper for health check event\nimpl ConnectionEvent {\n    pub fn health_check(healthy: bool, latency_ms: Option<u32>, error: Option<&str>) -> Self {\n        Self::HealthCheck {\n            timestamp: Utc::now(),\n            healthy,\n            latency_ms,\n            error: error.map(String::from),\n        }\n    }\n}\n```\n\n## Success Criteria\n- [ ] All connection state changes emit JSON events\n- [ ] Events are valid, parseable JSON\n- [ ] Timestamps are ISO-8601 format\n- [ ] Device info included where relevant\n- [ ] Timing information accurate\n- [ ] Works with watch mode streaming\n\n## Logging Requirements\n- TRACE: Event emission\n- DEBUG: Event serialization\n- INFO: (events emitted to stdout in robot mode)\n- WARN: (none)\n- ERROR: (none)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:25.780621064Z","created_by":"ubuntu","updated_at":"2026-01-21T11:26:45.859989487Z","closed_at":"2026-01-21T11:26:45.859937018Z","close_reason":"Implemented WatchConnectionEvent enum with serde serialization for robot mode. Emits disconnected, reconnecting, and reconnected events with relevant details (reason, attempt number, delay_ms) via emit_watch_event helper function.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.792821745Z","created_by":"ubuntu"}]}
{"id":"bd-1xs","title":"Add --text flag to set-key","description":"Extend set-key command:\n```\nsd set-key 0 ~/icon.png --text \"Chrome\" --text-position bottom\n```\n\nOverlays text on the provided image.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.841788169Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.852442359Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xs","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.852367277Z","created_by":"ubuntu"}]}
{"id":"bd-1xy","title":"Create E2E test harness with CLI helpers","description":"## Purpose\nBuild comprehensive infrastructure for end-to-end CLI testing with full output verification, timing assertions, and test isolation.\n\n## Implementation\n\n### Core CLI Runner\n```rust\n// tests/common/cli.rs\nuse std::process::{Command, Output, Stdio};\nuse std::time::{Duration, Instant};\nuse std::path::PathBuf;\nuse serde_json::Value;\nuse tempfile::TempDir;\n\n/// Configuration for CLI test runs\npub struct CliConfig {\n    pub timeout: Duration,\n    pub env_vars: Vec<(String, String)>,\n    pub working_dir: Option<PathBuf>,\n    pub stdin: Option<String>,\n}\n\nimpl Default for CliConfig {\n    fn default() -> Self {\n        Self {\n            timeout: Duration::from_secs(30),\n            env_vars: vec![],\n            working_dir: None,\n            stdin: None,\n        }\n    }\n}\n\n/// Main test runner for sd CLI\npub struct CliRunner {\n    binary_path: PathBuf,\n    config: CliConfig,\n}\n\nimpl CliRunner {\n    pub fn new() -> Self {\n        let binary = env!(\"CARGO_BIN_EXE_sd\");\n        Self {\n            binary_path: PathBuf::from(binary),\n            config: CliConfig::default(),\n        }\n    }\n    \n    pub fn with_timeout(mut self, timeout: Duration) -> Self {\n        self.config.timeout = timeout;\n        self\n    }\n    \n    pub fn with_env(mut self, key: &str, value: &str) -> Self {\n        self.config.env_vars.push((key.to_string(), value.to_string()));\n        self\n    }\n    \n    pub fn with_working_dir(mut self, dir: PathBuf) -> Self {\n        self.config.working_dir = Some(dir);\n        self\n    }\n    \n    /// Execute command and capture output\n    pub fn run(&self, args: &[&str]) -> CliResult {\n        let start = Instant::now();\n        \n        let mut cmd = Command::new(&self.binary_path);\n        cmd.args(args)\n           .stdout(Stdio::piped())\n           .stderr(Stdio::piped());\n        \n        // Apply environment variables\n        for (key, value) in &self.config.env_vars {\n            cmd.env(key, value);\n        }\n        \n        // Apply working directory\n        if let Some(ref dir) = self.config.working_dir {\n            cmd.current_dir(dir);\n        }\n        \n        let output = cmd.output().expect(\"Failed to execute command\");\n        let duration = start.elapsed();\n        \n        CliResult {\n            stdout: String::from_utf8_lossy(&output.stdout).to_string(),\n            stderr: String::from_utf8_lossy(&output.stderr).to_string(),\n            exit_code: output.status.code().unwrap_or(-1),\n            duration,\n            args: args.iter().map(|s| s.to_string()).collect(),\n        }\n    }\n    \n    /// Execute with --robot flag for JSON output\n    pub fn run_robot(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--robot\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n    \n    /// Execute with --dry-run flag\n    pub fn run_dry_run(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--dry-run\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n    \n    /// Execute with both --robot and --dry-run\n    pub fn run_robot_dry_run(&self, args: &[&str]) -> CliResult {\n        let mut full_args = vec![\"--robot\", \"--dry-run\"];\n        full_args.extend(args);\n        self.run(&full_args)\n    }\n}\n```\n\n### CLI Result with Fluent Assertions\n```rust\n/// Captured output from CLI execution\npub struct CliResult {\n    pub stdout: String,\n    pub stderr: String,\n    pub exit_code: i32,\n    pub duration: Duration,\n    pub args: Vec<String>,\n}\n\nimpl CliResult {\n    // Basic checks\n    pub fn success(&self) -> bool { self.exit_code == 0 }\n    \n    // Fluent assertions - all return &Self for chaining\n    pub fn assert_success(&self) -> &Self {\n        assert!(self.success(), \n            \"Command {:?} failed with exit code {}: {}\", \n            self.args, self.exit_code, self.stderr);\n        self\n    }\n    \n    pub fn assert_failure(&self) -> &Self {\n        assert!(!self.success(), \n            \"Command {:?} unexpectedly succeeded\", self.args);\n        self\n    }\n    \n    pub fn assert_exit_code(&self, expected: i32) -> &Self {\n        assert_eq!(self.exit_code, expected,\n            \"Expected exit code {}, got {} for {:?}\", \n            expected, self.exit_code, self.args);\n        self\n    }\n    \n    // Stdout assertions\n    pub fn assert_stdout_contains(&self, text: &str) -> &Self {\n        assert!(self.stdout.contains(text), \n            \"stdout does not contain \\\"{}\\\"\\nActual stdout:\\n{}\", \n            text, self.stdout);\n        self\n    }\n    \n    pub fn assert_stdout_not_contains(&self, text: &str) -> &Self {\n        assert!(!self.stdout.contains(text), \n            \"stdout unexpectedly contains \\\"{}\\\"\", text);\n        self\n    }\n    \n    pub fn assert_stdout_matches(&self, pattern: &str) -> &Self {\n        let re = regex::Regex::new(pattern).unwrap();\n        assert!(re.is_match(&self.stdout),\n            \"stdout does not match pattern \\\"{}\\\"\\nActual stdout:\\n{}\",\n            pattern, self.stdout);\n        self\n    }\n    \n    pub fn assert_stdout_is_empty(&self) -> &Self {\n        assert!(self.stdout.is_empty(),\n            \"Expected empty stdout, got: {}\", self.stdout);\n        self\n    }\n    \n    // Stderr assertions\n    pub fn assert_stderr_contains(&self, text: &str) -> &Self {\n        assert!(self.stderr.contains(text),\n            \"stderr does not contain \\\"{}\\\"\\nActual stderr:\\n{}\",\n            text, self.stderr);\n        self\n    }\n    \n    pub fn assert_stderr_is_empty(&self) -> &Self {\n        assert!(self.stderr.trim().is_empty(),\n            \"Expected empty stderr, got: {}\", self.stderr);\n        self\n    }\n    \n    // JSON assertions (for robot mode)\n    pub fn json(&self) -> Value {\n        serde_json::from_str(&self.stdout)\n            .expect(&format!(\"Failed to parse JSON from stdout:\\n{}\", self.stdout))\n    }\n    \n    pub fn assert_json_field(&self, json_pointer: &str, expected: &Value) -> &Self {\n        let json = self.json();\n        let actual = json.pointer(json_pointer)\n            .expect(&format!(\"JSON path {} not found in:\\n{}\", \n                json_pointer, serde_json::to_string_pretty(&json).unwrap()));\n        assert_eq!(actual, expected,\n            \"JSON field {} mismatch\", json_pointer);\n        self\n    }\n    \n    pub fn assert_json_field_exists(&self, json_pointer: &str) -> &Self {\n        let json = self.json();\n        assert!(json.pointer(json_pointer).is_some(),\n            \"JSON path {} not found\", json_pointer);\n        self\n    }\n    \n    pub fn assert_json_array_len(&self, json_pointer: &str, expected_len: usize) -> &Self {\n        let json = self.json();\n        let arr = json.pointer(json_pointer)\n            .expect(&format!(\"JSON path {} not found\", json_pointer))\n            .as_array()\n            .expect(&format!(\"JSON path {} is not an array\", json_pointer));\n        assert_eq!(arr.len(), expected_len,\n            \"Array at {} has {} elements, expected {}\", \n            json_pointer, arr.len(), expected_len);\n        self\n    }\n    \n    // Timing assertions\n    pub fn assert_duration_under(&self, max: Duration) -> &Self {\n        assert!(self.duration < max,\n            \"Command took {:?}, expected under {:?}\", self.duration, max);\n        self\n    }\n    \n    pub fn assert_duration_over(&self, min: Duration) -> &Self {\n        assert!(self.duration > min,\n            \"Command took {:?}, expected over {:?}\", self.duration, min);\n        self\n    }\n}\n```\n\n### Test Fixture Helpers\n```rust\n// tests/common/fixtures.rs\nuse tempfile::TempDir;\nuse std::path::PathBuf;\n\n/// Get path to test fixtures directory\npub fn fixtures_path(subpath: &str) -> PathBuf {\n    PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n        .join(\"tests\")\n        .join(\"fixtures\")\n        .join(subpath)\n}\n\n/// Create a temporary directory with test images\npub struct TestImages {\n    pub dir: TempDir,\n}\n\nimpl TestImages {\n    /// Create temp dir with N solid-color test images\n    pub fn create_batch(count: u8, size: u32) -> Self {\n        let dir = TempDir::new().unwrap();\n        \n        for i in 0..count {\n            let color = image::Rgb([\n                (i * 8) % 256,\n                (i * 16) % 256,\n                (i * 24) % 256,\n            ]);\n            let img = image::RgbImage::from_pixel(size, size, color);\n            let path = dir.path().join(format!(\"key-{}.png\", i));\n            img.save(&path).unwrap();\n        }\n        \n        Self { dir }\n    }\n    \n    /// Create numbered images matching key-{N}.png pattern\n    pub fn create_numbered(keys: &[u8], size: u32) -> Self {\n        let dir = TempDir::new().unwrap();\n        \n        for &key in keys {\n            let img = image::RgbImage::from_pixel(size, size, \n                image::Rgb([key * 8, 128, 255 - key * 8]));\n            let path = dir.path().join(format!(\"key-{}.png\", key));\n            img.save(&path).unwrap();\n        }\n        \n        Self { dir }\n    }\n    \n    pub fn path(&self) -> &std::path::Path {\n        self.dir.path()\n    }\n}\n\n/// Create a temporary config file\npub struct TestConfig {\n    pub dir: TempDir,\n    pub config_path: PathBuf,\n}\n\nimpl TestConfig {\n    pub fn yaml(content: &str) -> Self {\n        let dir = TempDir::new().unwrap();\n        let config_path = dir.path().join(\"config.yaml\");\n        std::fs::write(&config_path, content).unwrap();\n        Self { dir, config_path }\n    }\n    \n    pub fn toml(content: &str) -> Self {\n        let dir = TempDir::new().unwrap();\n        let config_path = dir.path().join(\"config.toml\");\n        std::fs::write(&config_path, content).unwrap();\n        Self { dir, config_path }\n    }\n}\n```\n\n### Logging Verification Helpers\n```rust\n// tests/common/logging.rs\n\n/// Verify log output contains expected entries\npub struct LogVerifier {\n    log_lines: Vec<String>,\n}\n\nimpl LogVerifier {\n    pub fn from_stderr(stderr: &str) -> Self {\n        Self {\n            log_lines: stderr.lines().map(String::from).collect(),\n        }\n    }\n    \n    pub fn assert_contains_level(&self, level: &str, message: &str) -> &Self {\n        let found = self.log_lines.iter().any(|line| {\n            line.contains(level) && line.contains(message)\n        });\n        assert!(found, \"No {} log containing \\\"{}\\\" found in:\\n{}\", \n            level, message, self.log_lines.join(\"\\n\"));\n        self\n    }\n    \n    pub fn assert_trace(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"TRACE\", message)\n    }\n    \n    pub fn assert_debug(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"DEBUG\", message)\n    }\n    \n    pub fn assert_info(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"INFO\", message)\n    }\n    \n    pub fn assert_warn(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"WARN\", message)\n    }\n    \n    pub fn assert_error(&self, message: &str) -> &Self {\n        self.assert_contains_level(\"ERROR\", message)\n    }\n    \n    pub fn assert_no_errors(&self) -> &Self {\n        let errors: Vec<_> = self.log_lines.iter()\n            .filter(|l| l.contains(\"ERROR\"))\n            .collect();\n        assert!(errors.is_empty(), \"Found unexpected errors:\\n{}\", \n            errors.join(\"\\n\"));\n        self\n    }\n    \n    pub fn assert_no_warnings(&self) -> &Self {\n        let warnings: Vec<_> = self.log_lines.iter()\n            .filter(|l| l.contains(\"WARN\"))\n            .collect();\n        assert!(warnings.is_empty(), \"Found unexpected warnings:\\n{}\", \n            warnings.join(\"\\n\"));\n        self\n    }\n}\n```\n\n## E2E Test Examples\n```rust\n// tests/e2e/batch_operations.rs\nuse common::{cli::CliRunner, fixtures::TestImages, logging::LogVerifier};\n\n#[test]\nfn test_set_keys_full_batch() {\n    let images = TestImages::create_batch(32, 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot(&[\"set-keys\", images.path().to_str().unwrap()]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/summary/success\", &json!(32))\n        .assert_json_field(\"/summary/failed\", &json!(0));\n}\n\n#[test]\nfn test_set_keys_partial_with_continue() {\n    let images = TestImages::create_numbered(&[0, 2, 5, 10, 31], 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot(&[\n        \"set-keys\", \n        images.path().to_str().unwrap(),\n        \"--continue-on-error\"\n    ]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/summary/success\", &json!(5))\n        .assert_json_field(\"/summary/skipped\", &json!(27));\n}\n\n#[test]\nfn test_dry_run_shows_plan_no_device_changes() {\n    let images = TestImages::create_batch(8, 72);\n    let cli = CliRunner::new();\n    \n    let result = cli.run_robot_dry_run(&[\n        \"set-keys\",\n        images.path().to_str().unwrap()\n    ]);\n    \n    result\n        .assert_success()\n        .assert_json_field(\"/dry_run\", &json!(true))\n        .assert_json_field_exists(\"/plan/keys\");\n}\n\n#[test]\nfn test_verbose_logging_output() {\n    let images = TestImages::create_batch(4, 72);\n    let cli = CliRunner::new()\n        .with_env(\"RUST_LOG\", \"sd=trace\");\n    \n    let result = cli.run(&[\n        \"-vvv\",  // Very verbose\n        \"set-keys\",\n        images.path().to_str().unwrap()\n    ]);\n    \n    let logs = LogVerifier::from_stderr(&result.stderr);\n    logs.assert_trace(\"scanning directory\")\n        .assert_debug(\"loading image\")\n        .assert_info(\"set-keys operation complete\");\n}\n```\n\n## Success Criteria\n- [ ] CliRunner can execute sd binary with configurable timeout\n- [ ] Environment variable injection works\n- [ ] Working directory can be overridden\n- [ ] Output capture works for stdout and stderr\n- [ ] Exit code assertions work correctly\n- [ ] JSON parsing and pointer assertions work for robot mode\n- [ ] Timing assertions can verify performance\n- [ ] TestImages helper can create temp directories with test images\n- [ ] TestConfig helper can create temp config files\n- [ ] LogVerifier can parse and assert on log output\n- [ ] Tests can run in parallel safely (no shared state)\n- [ ] Temp directories are cleaned up automatically\n\n## Logging Requirements\n- TRACE: CLI argument parsing details\n- DEBUG: Test setup and teardown steps\n- INFO: Test execution summaries\n- WARN: Test resource cleanup issues\n- ERROR: Assertion failures with full context","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:51.556676964Z","created_by":"ubuntu","updated_at":"2026-01-21T11:30:35.365531492Z","closed_at":"2026-01-21T11:30:35.365470377Z","close_reason":"E2E test harness already implemented in tests/common/cli.rs with CliRunner and CliResult providing: command execution with timeouts and env vars, fluent assertions (assert_success, assert_failure, assert_stdout_contains, assert_stderr_contains), regex matching, JSON parsing and assertions (json_field, json_field_exists, json_array_len), timing assertions (duration_under/over), and convenience methods (run_robot, run_dry_run). Tests verify basic functionality.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xy","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:51.566910552Z","created_by":"ubuntu"}]}
{"id":"bd-1z7d","title":"Phase 5: Polish and Documentation","description":"# Phase 5: Polish and Documentation\n\n## Purpose\nFinal refinements, documentation updates, and verification before considering the rich_rust integration complete. This phase ensures the work is production-ready and well-documented.\n\n## Background\nAfter implementation and testing phases, this phase addresses:\n- Edge cases and polish\n- Documentation for users and maintainers\n- Final verification checklist\n- Future enhancement notes\n\n## Deliverables\n1. Edge case handling improvements\n2. Updated AGENTS.md with output system info\n3. Code comments and documentation\n4. Final verification checklist completed\n5. Future enhancement issues created\n\n## Success Criteria\n- [ ] All edge cases handled gracefully\n- [ ] Documentation updated\n- [ ] Code is well-commented\n- [ ] Final checklist passed\n- [ ] Future work captured in issues","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-19T21:11:41.425528771Z","created_by":"ubuntu","updated_at":"2026-01-19T21:11:41.459696462Z","compaction_level":0,"original_size":0,"labels":["docs","phase-5","polish","rich-rust"],"dependencies":[{"issue_id":"bd-1z7d","depends_on_id":"bd-36gs","type":"blocks","created_at":"2026-01-19T21:11:41.459674160Z","created_by":"ubuntu"},{"issue_id":"bd-1z7d","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:11:41.454992225Z","created_by":"ubuntu"}]}
{"id":"bd-1zf","title":"EPIC: Hot-Reload Configuration Files","description":"## Overview\n**Rank: #11 of 15** | **Impact: Medium** | **Effort: Medium** | **Confidence: Medium-High**\n\nMonitor configuration files and automatically apply changes when files are modified.\n\n## Problem Statement\nWhen designing a Stream Deck layout, users must:\n1. Edit configuration file\n2. Save file\n3. Run `sd apply config.yaml`\n4. See result on device\n5. Repeat\n\nThis edit-save-run-check cycle is slow and breaks flow. Users want to see changes instantly.\n\n## Solution\nWatch mode for configuration files:\n```bash\n# Watch a single config file\nsd watch-config ~/.config/sd/current.yaml\n\n# Watch with debounce (avoid rapid re-applies)\nsd watch-config work.yaml --debounce 500\n\n# Watch entire config directory\nsd watch-config ~/.config/sd/profiles/ --active work.yaml\n```\n\nWhen the file changes:\n```\n[2024-01-15 10:30:15] Detected change in work.yaml\n[2024-01-15 10:30:15] Applying configuration...\n[2024-01-15 10:30:15] ✓ Applied 5 key changes, brightness unchanged\n```\n\n## Why This Is #11 Priority\n1. **Developer experience**: Real-time feedback during design\n2. **Natural extension**: Builds on DECLARATIVE-CONFIG (#7)\n3. **Live editing workflow**: Edit in VSCode, see on device instantly\n4. **Moderate effort**: File watching is well-supported in Rust\n5. **Dependent feature**: Requires declarative config to be useful\n\n## Implementation Approach\n\n### Phase 1: File Watcher Setup\n```rust\n// Add to Cargo.toml\n[dependencies]\nnotify = \"6\"\n\n// In src/watch_config.rs (new file)\nuse notify::{Watcher, RecursiveMode, watcher};\nuse std::sync::mpsc::channel;\nuse std::time::Duration;\n\npub fn watch_config(\n    device: &Device,\n    config_path: &Path,\n    debounce_ms: u64,\n) -> Result<()> {\n    let (tx, rx) = channel();\n    \n    let mut watcher = notify::recommended_watcher(move |res| {\n        if let Ok(event) = res {\n            let _ = tx.send(event);\n        }\n    })?;\n    \n    watcher.watch(config_path, RecursiveMode::NonRecursive)?;\n    \n    println!(\"Watching {} for changes...\", config_path.display());\n    println!(\"Press Ctrl+C to stop\");\n    \n    // Apply initial configuration\n    apply_config(device, config_path)?;\n    \n    let mut last_apply = std::time::Instant::now();\n    \n    loop {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(event) => {\n                // Debounce: ignore events too close together\n                if last_apply.elapsed() < Duration::from_millis(debounce_ms) {\n                    continue;\n                }\n                \n                if is_modify_event(&event) {\n                    println!(\"[{}] Detected change\", timestamp());\n                    match apply_config(device, config_path) {\n                        Ok(changes) => {\n                            println!(\"[{}] ✓ Applied {} changes\", timestamp(), changes);\n                        }\n                        Err(e) => {\n                            eprintln!(\"[{}] ✗ Error: {}\", timestamp(), e);\n                        }\n                    }\n                    last_apply = std::time::Instant::now();\n                }\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => continue,\n            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => break,\n        }\n    }\n    \n    Ok(())\n}\n```\n\n### Phase 2: Intelligent Diff-Apply\nInstead of re-applying everything, track what changed:\n```rust\npub struct ConfigState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyConfig>,\n}\n\nimpl ConfigState {\n    pub fn diff(&self, new: &ConfigState) -> ConfigDiff {\n        let mut changes = Vec::new();\n        \n        if self.brightness != new.brightness {\n            changes.push(Change::Brightness(new.brightness));\n        }\n        \n        for (key, new_config) in &new.keys {\n            match self.keys.get(key) {\n                Some(old_config) if old_config != new_config => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                None => {\n                    changes.push(Change::Key(*key, new_config.clone()));\n                }\n                _ => {}\n            }\n        }\n        \n        ConfigDiff { changes }\n    }\n}\n```\n\n## Key Design Decisions\n1. **Debouncing**: Prevent rapid re-applies during multi-file saves\n2. **Error resilience**: Invalid config shows error, keeps watching\n3. **Diff-based apply**: Only change what actually changed\n4. **Initial apply**: Apply config once when watch starts\n5. **Graceful shutdown**: Ctrl+C stops cleanly\n\n## Robot Mode Output\n```json\n{\"event\": \"watching\", \"path\": \"/home/user/.config/sd/work.yaml\"}\n{\"event\": \"change_detected\", \"timestamp\": \"...\"}\n{\"event\": \"applying\", \"changes\": 5}\n{\"event\": \"applied\", \"success\": true, \"changes\": 5, \"duration_ms\": 150}\n{\"event\": \"error\", \"message\": \"Invalid YAML on line 15\"}\n```\n\n## Success Criteria\n- [ ] `sd watch-config <file>` monitors for changes\n- [ ] Changes auto-applied within debounce window\n- [ ] Syntax errors reported without crashing\n- [ ] Diff-based apply only changes modified keys\n- [ ] Debounce prevents rapid re-applies\n- [ ] Robot mode outputs structured events\n- [ ] Ctrl+C stops cleanly\n\n## Files to Create/Modify\n- `Cargo.toml`: Add notify dependency\n- `src/watch_config.rs`: New file watcher module\n- `src/cli/mod.rs`: Add WatchConfig command\n- `src/main.rs`: Implement command handler\n\n## Dependencies\n- **Hard dependency on DECLARATIVE-CONFIG (#7)**: Requires config files to watch\n\n## Estimated Subtasks\n1. Add notify dependency\n2. Implement basic file watcher\n3. Add debouncing logic\n4. Implement diff-based apply\n5. Add error handling for invalid configs\n6. Add robot mode output\n7. Test with various editors (VSCode, vim, etc.)\n8. Handle edge cases (file deletion, rename)","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:20:34.580206020Z","created_by":"ubuntu","updated_at":"2026-01-19T18:23:22.116619464Z","compaction_level":0,"original_size":0,"labels":["config","developer-experience","priority-11","watch"],"dependencies":[{"issue_id":"bd-1zf","depends_on_id":"bd-1r4","type":"blocks","created_at":"2026-01-19T18:23:22.116589698Z","created_by":"ubuntu"}]}
{"id":"bd-20s","title":"Handle command errors gracefully","description":"Command failures should not crash watch:\n- Log error to stderr\n- Report in robot mode\n- Continue watching\n- Track failure counts for diagnostics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:21.803142096Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:21.816837942Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-20s","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:21.816778210Z","created_by":"ubuntu"}]}
{"id":"bd-21c","title":"Add clap_complete to Cargo.toml","description":"Add dependency:\n```toml\n[dependencies]\nclap_complete = \"4\"\n```\n\nThis is the standard completion generation crate for clap.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.238271755Z","created_by":"ubuntu","updated_at":"2026-01-21T10:59:59.711734829Z","closed_at":"2026-01-21T10:59:59.711689824Z","close_reason":"Already in Cargo.toml: clap_complete = 4.5","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21c","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.266752779Z","created_by":"ubuntu"}]}
{"id":"bd-21i","title":"Set up tracing-based structured logging","description":"## Purpose\nAdd comprehensive logging infrastructure using the tracing ecosystem for debugging, observability, and robot-mode structured output.\n\n## Dependencies\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\", \"json\"] }\n```\n\n## Implementation\n\n### Initialization (src/logging.rs)\n```rust\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter, Layer};\nuse std::io::IsTerminal;\n\npub fn init_logging(robot_mode: bool, verbose: u8) {\n    let default_level = match verbose {\n        0 => \"sd=info\",\n        1 => \"sd=debug\",\n        _ => \"sd=trace\",\n    };\n    \n    let filter = EnvFilter::try_from_default_env()\n        .unwrap_or_else(|_| EnvFilter::new(default_level));\n    \n    if robot_mode {\n        // JSON output for machine parsing\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .json()\n                .with_timer(fmt::time::UtcTime::rfc_3339())\n                .with_current_span(true))\n            .init();\n    } else if std::io::stderr().is_terminal() {\n        // Pretty output for interactive terminal\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .pretty()\n                .with_target(false)\n                .with_ansi(true))\n            .init();\n    } else {\n        // Compact output for piped/redirected stderr\n        tracing_subscriber::registry()\n            .with(filter)\n            .with(fmt::layer()\n                .compact()\n                .with_ansi(false))\n            .init();\n    }\n}\n```\n\n### Instrumentation Pattern\n```rust\nuse tracing::{info, warn, error, debug, trace, instrument, span, Level};\n\n#[instrument(skip(device), fields(device_model = %device.info().model))]\npub fn cmd_set_key(device: &mut dyn DeviceOperations, key: u8, path: &Path) -> Result<()> {\n    info!(key, path = %path.display(), \"Setting key image\");\n    \n    // Timing span for performance analysis\n    let process_span = span!(Level::DEBUG, \"image_processing\", key);\n    let _guard = process_span.enter();\n    \n    let img = image::open(path).map_err(|e| {\n        error!(path = %path.display(), error = %e, \"Failed to open image\");\n        e\n    })?;\n    \n    debug!(width = img.width(), height = img.height(), format = ?img.color(), \"Image loaded\");\n    \n    // ... resize and send to device\n    \n    info!(key, duration_ms = elapsed.as_millis(), \"Key image set successfully\");\n    Ok(())\n}\n```\n\n## Log Level Guidelines\n\n### ERROR\n- Device communication failures\n- Unrecoverable file I/O errors\n- Parse errors that abort operation\n- Include: error cause, affected resource, recovery suggestion\n\n### WARN\n- Recoverable issues (fallback used)\n- Deprecation notices\n- Missing optional files\n- Include: what happened, what was done instead\n\n### INFO\n- Command start/complete\n- High-level operation flow\n- Summary statistics\n- Include: operation name, key parameters, outcome\n\n### DEBUG\n- Detailed operation steps\n- Timing information\n- Cache hit/miss\n- Configuration decisions\n- Include: all relevant parameters, durations\n\n### TRACE\n- Very detailed flow\n- Data values (truncated if large)\n- Loop iterations\n- Include: raw values, intermediate states\n\n## Log Format (Robot Mode JSON)\n```json\n{\n  \"timestamp\": \"2024-01-15T10:30:00.123456Z\",\n  \"level\": \"INFO\",\n  \"target\": \"sd::cmd::set_key\",\n  \"span\": {\n    \"name\": \"cmd_set_key\",\n    \"key\": 5,\n    \"device_model\": \"Stream Deck XL\"\n  },\n  \"fields\": {\n    \"message\": \"Key image set successfully\",\n    \"duration_ms\": 45\n  }\n}\n```\n\n## Environment Variables\n- `RUST_LOG=sd=debug` - Set log level\n- `RUST_LOG=sd::device=trace` - Trace specific module\n- `RUST_LOG_STYLE=never` - Disable colors\n- `NO_COLOR=1` - Disable colors (standard)\n\n## CLI Flags Integration\n- `--verbose` / `-v`: Set DEBUG level\n- `--verbose --verbose` / `-vv`: Set TRACE level\n- `--quiet` / `-q`: Suppress INFO, show WARN+ERROR only\n- `--robot`: Force JSON format\n\n## Success Criteria\n- [ ] Logging initialized based on robot mode and verbosity\n- [ ] RUST_LOG environment variable respected\n- [ ] TTY detection for automatic color handling\n- [ ] All commands have INFO-level start/complete logs\n- [ ] All errors have ERROR-level logs with context and suggestions\n- [ ] Performance-critical paths have DEBUG timing spans\n- [ ] JSON output is valid and includes spans/fields\n- [ ] Quiet mode suppresses non-error output","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:51.017515647Z","created_by":"ubuntu","updated_at":"2026-01-21T10:44:02.742482042Z","closed_at":"2026-01-21T10:44:02.742423442Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21i","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:51.028264695Z","created_by":"ubuntu"}]}
{"id":"bd-21o","title":"Extract Device trait from concrete implementation","description":"## Purpose\nCreate a Device trait that abstracts over real and mock implementations, enabling testability.\n\n## Current State\n\\`src/device.rs\\` directly wraps \\`elgato-streamdeck::StreamDeck\\`. This makes unit testing impossible without real hardware.\n\n## Target Architecture\n\\`\\`\\`rust\n// src/device/mod.rs\nuse std::time::Duration;\nuse async_trait::async_trait;\nuse crate::error::Result;\n\n/// Information about a connected device\n#[derive(Debug, Clone)]\npub struct DeviceInfo {\n    pub model: DeviceModel,\n    pub serial: String,\n    pub firmware: String,\n    pub key_count: u8,\n    pub key_cols: u8,\n    pub key_rows: u8,\n    pub key_width: u32,\n    pub key_height: u32,\n}\n\n/// Supported device models\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DeviceModel {\n    Mini,       // 6 keys (3x2)\n    Original,   // 15 keys (5x3)\n    OriginalV2, // 15 keys (5x3)\n    XL,         // 32 keys (8x4)\n    MK2,        // 15 keys (5x3)\n    Pedal,      // 3 pedals\n    Plus,       // 8 keys + LCD + dials\n}\n\nimpl DeviceModel {\n    pub fn key_count(&self) -> u8 {\n        match self {\n            DeviceModel::Mini => 6,\n            DeviceModel::Original | DeviceModel::OriginalV2 | DeviceModel::MK2 => 15,\n            DeviceModel::XL => 32,\n            DeviceModel::Pedal => 3,\n            DeviceModel::Plus => 8,\n        }\n    }\n    \n    pub fn key_dimensions(&self) -> (u32, u32) {\n        match self {\n            DeviceModel::Mini | DeviceModel::Original | DeviceModel::OriginalV2 | DeviceModel::MK2 => (72, 72),\n            DeviceModel::XL => (96, 96),\n            DeviceModel::Pedal => (0, 0), // No display\n            DeviceModel::Plus => (120, 120),\n        }\n    }\n    \n    pub fn layout(&self) -> (u8, u8) {\n        match self {\n            DeviceModel::Mini => (3, 2),\n            DeviceModel::Original | DeviceModel::OriginalV2 | DeviceModel::MK2 => (5, 3),\n            DeviceModel::XL => (8, 4),\n            DeviceModel::Pedal => (3, 1),\n            DeviceModel::Plus => (4, 2),\n        }\n    }\n}\n\n/// Key press/release event\n#[derive(Debug, Clone)]\npub struct KeyEvent {\n    pub key: u8,\n    pub pressed: bool,\n    pub timestamp: std::time::Instant,\n}\n\n/// Core device operations trait\n/// \n/// This trait abstracts over real hardware and mock implementations,\n/// enabling unit testing without physical devices.\n#[async_trait]\npub trait DeviceOperations: Send + Sync {\n    /// Get device information\n    fn info(&self) -> &DeviceInfo;\n    \n    /// Check if device is connected\n    fn is_connected(&self) -> bool;\n    \n    /// Get device serial number\n    fn serial(&self) -> Option<&str> {\n        Some(&self.info().serial)\n    }\n    \n    /// Set display brightness (0-100)\n    async fn set_brightness(&mut self, level: u8) -> Result<()>;\n    \n    /// Set key image from raw pixel data (BGRA format, pre-sized)\n    async fn set_key_image_raw(&mut self, key: u8, image_data: &[u8]) -> Result<()>;\n    \n    /// Set key image from file path (handles loading, conversion, resizing)\n    async fn set_key_image(&mut self, key: u8, path: &std::path::Path) -> Result<()>;\n    \n    /// Clear a single key (set to black)\n    async fn clear_key(&mut self, key: u8) -> Result<()>;\n    \n    /// Clear all keys\n    async fn clear_all_keys(&mut self) -> Result<()>;\n    \n    /// Fill key with solid color\n    async fn fill_key_color(&mut self, key: u8, r: u8, g: u8, b: u8) -> Result<()>;\n    \n    /// Read input event with timeout\n    /// Returns None if timeout expires without input\n    async fn read_input(&mut self, timeout: Duration) -> Result<Option<KeyEvent>>;\n    \n    /// Flush any buffered operations to device\n    async fn flush(&mut self) -> Result<()>;\n    \n    /// Reset device to default state\n    async fn reset(&mut self) -> Result<()>;\n}\n\n/// Type alias for boxed trait object\npub type BoxedDevice = Box<dyn DeviceOperations>;\n\\`\\`\\`\n\n## Implementation Steps\n1. Create \\`src/device/mod.rs\\` with trait definition\n2. Create \\`src/device/info.rs\\` with DeviceInfo and DeviceModel\n3. Move existing code to \\`src/device/real.rs\\`\n4. Implement trait for real device wrapper\n5. Create \\`src/device/mock.rs\\` (separate task bd-180)\n6. Export all from mod.rs\n7. Update all call sites to use trait via dependency injection\n\n## Migration Strategy\n\\`\\`\\`rust\n// Before: Direct struct usage\nlet device = Device::open()?;\ndevice.set_brightness(80)?;\n\n// After: Trait-based (allows mock injection)\nfn run_command(device: &mut dyn DeviceOperations) -> Result<()> {\n    device.set_brightness(80).await?;\n    Ok(())\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Device trait defined with all necessary async methods\n- [ ] DeviceModel enum covers all supported devices\n- [ ] DeviceInfo provides complete device metadata\n- [ ] Real device implements trait\n- [ ] All existing functionality preserved\n- [ ] No changes to CLI interface\n- [ ] Compiles and passes existing tests\n\n## Logging Requirements\n- TRACE: Method entry/exit for each trait method\n- DEBUG: Device model detection, capability queries\n- INFO: Device connection/disconnection\n- WARN: Unexpected device states\n- ERROR: Connection failures, operation errors","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:49.366767185Z","created_by":"ubuntu","updated_at":"2026-01-21T10:53:16.339862723Z","closed_at":"2026-01-21T10:53:16.339788433Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21o","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:49.396905409Z","created_by":"ubuntu"}]}
{"id":"bd-227","title":"Handle image copying and storage","description":"When importing profiles:\n1. Extract images from ZIP to temp\n2. Copy to ~/.local/share/sd/images/\n3. Use content-addressable naming (SHA256)\n4. Update database with new paths\n5. Handle duplicates (same image, different keys)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.340162210Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.349396096Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-227","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.349355890Z","created_by":"ubuntu"}]}
{"id":"bd-22s","title":"Implement dry-run for clear-key/clear-all","description":"## Purpose\nImplement dry-run mode for all clear operations (clear-key, clear-all, clear-keys).\n\n## Implementation\n\n### clear-key (single)\n```rust\nif dry_run {\n    output.dry_run_preview(DryRunAction::ClearKey {\n        key,\n        device_model: device.info().model.clone(),\n    });\n    return Ok(());\n}\n```\n\n### clear-all\n```rust\nif dry_run {\n    let key_count = device.info().key_count;\n    output.dry_run_preview(DryRunAction::ClearAll {\n        key_count,\n        device_model: device.info().model.clone(),\n    });\n    return Ok(());\n}\n```\n\n### clear-keys (batch)\n```rust\nif dry_run {\n    let keys = resolve_key_selection(&opts)?;\n    output.dry_run_preview(DryRunAction::ClearKeys {\n        keys: keys.clone(),\n        total_count: keys.len(),\n        device_model: device.info().model.clone(),\n    });\n    return Ok(());\n}\n```\n\n## Robot Mode Output\n```json\n{\n  \"dry_run\": true,\n  \"command\": \"clear-keys\",\n  \"would_clear\": [0, 1, 2, 3, 4, 5, 6, 7],\n  \"total_keys\": 8,\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"total_keys\": 32\n  }\n}\n```\n\n## Human Mode Output\n```\nDRY RUN: Would clear 8 keys (0-7) on Stream Deck XL\n  Keys: 0, 1, 2, 3, 4, 5, 6, 7\n  No changes will be made.\n```\n\n## Logging Requirements\n- TRACE: Each key evaluated for clearing\n- DEBUG: Key selection resolution\n- INFO: Dry-run summary\n- WARN: (none)\n- ERROR: Invalid key indices\n\n## Success Criteria\n- [ ] clear-key shows single key preview\n- [ ] clear-all shows device key count\n- [ ] clear-keys shows range resolution\n- [ ] Robot mode returns structured preview\n- [ ] No device operations performed","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.569143769Z","created_by":"ubuntu","updated_at":"2026-01-19T21:46:08.792170946Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-22s","depends_on_id":"bd-1uz","type":"blocks","created_at":"2026-01-19T21:46:08.098540337Z","created_by":"ubuntu"},{"issue_id":"bd-22s","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.578880340Z","created_by":"ubuntu"},{"issue_id":"bd-22s","depends_on_id":"bd-3lf","type":"blocks","created_at":"2026-01-19T21:46:08.792126492Z","created_by":"ubuntu"}]}
{"id":"bd-248","title":"Implement HumanOutput skeleton with rich_rust Console","description":"# Implement HumanOutput skeleton with rich_rust Console\n\n## Purpose\nCreate the HumanOutput struct that implements the Output trait using rich_rust for beautiful terminal rendering. This task creates the skeleton with basic implementations; detailed formatting for each command will be added in Phase 2.\n\n## Background\nHumanOutput is the counterpart to RobotOutput. While RobotOutput produces raw JSON, HumanOutput produces styled terminal output using rich_rust features:\n- Panels with box drawing characters\n- Tables with auto-sizing columns\n- Styled text with colors and attributes\n- Progress bars for brightness\n- Rules for visual separation\n\n## Technical Details\n\n### HumanOutput Struct (src/output/human.rs)\nuse rich_rust::prelude::*;\nuse crate::theme::SdTheme;\nuse crate::device::{DeviceInfo, ButtonEvent};\nuse crate::error::SdError;\nuse super::Output;\nuse std::path::Path;\nuse tracing::{debug, trace, instrument};\n\n/// Styled terminal output implementation for human users\n/// \n/// Uses rich_rust for beautiful, consistent formatting with:\n/// - Panels for grouped information\n/// - Tables for structured data\n/// - Styled text for emphasis\n/// - Progress bars for numeric values\n/// - Automatic terminal capability detection\npub struct HumanOutput {\n    console: Console,\n    theme: SdTheme,\n}\n\nimpl HumanOutput {\n    #[instrument(skip(console), fields(width = console.width()))]\n    pub fn new(console: Console) -> Self {\n        debug!(\"Creating HumanOutput\");\n        Self {\n            console,\n            theme: SdTheme::default(),\n        }\n    }\n    \n    /// Get terminal width for layout calculations\n    fn width(&self) -> usize {\n        self.console.width()\n    }\n    \n    /// Create a styled panel with the theme's accent border\n    #[instrument(skip(self, content))]\n    fn accent_panel(&self, content: &str, title: Option<&str>) -> Panel {\n        trace!(title, \"Creating accent panel\");\n        let mut panel = Panel::from_text(content)\n            .border_style(Style::new().color(self.theme.accent.clone()));\n        if let Some(t) = title {\n            panel = panel.title(t);\n        }\n        panel.rounded()\n    }\n    \n    /// Create a styled panel for errors\n    #[instrument(skip(self, content))]\n    fn error_panel(&self, content: Text, title: Option<&str>) -> Panel {\n        trace!(title, \"Creating error panel\");\n        let width = self.width().saturating_sub(4);\n        let mut panel = Panel::from_rich_text(content, width)\n            .border_style(Style::new().color(self.theme.error.clone()));\n        if let Some(t) = title {\n            panel = panel.title(t);\n        }\n        panel.rounded()\n    }\n    \n    /// Create a styled panel for success\n    fn success_panel(&self, content: &str) -> Panel {\n        Panel::from_text(content)\n            .border_style(Style::new().color(self.theme.success.clone()))\n            .rounded()\n    }\n}\n\n### Output Trait Implementation with Tracing\nimpl Output for HumanOutput {\n    #[instrument(skip(self))]\n    fn success(&self, message: &str) {\n        debug!(message, \"Outputting success\");\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    #[instrument(skip(self))]\n    fn error(&self, error: &SdError) {\n        debug!(error = %error, recoverable = error.is_user_recoverable(), \"Outputting error\");\n        let mut content = Text::new(\"\");\n        content.append_styled(\"  ✗ \", Style::new().bold().color(self.theme.error.clone()));\n        content.append_styled(&error.to_string(), Style::new().bold());\n        content.append(\"\\n\");\n        \n        if let Some(suggestion) = error.suggestion() {\n            trace!(suggestion, \"Adding suggestion\");\n            content.append(\"\\n\");\n            content.append_styled(\"  Suggestion:\\n\", self.theme.label.clone());\n            content.append_styled(&format!(\"  {}\", suggestion), self.theme.muted.clone());\n            content.append(\"\\n\");\n        }\n        \n        let panel = self.error_panel(content, Some(\"Error\"));\n        self.console.print_renderable(&panel);\n    }\n    \n    #[instrument(skip(self))]\n    fn warning(&self, message: &str) {\n        debug!(message, \"Outputting warning\");\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ⚠ \", Style::new().bold().color(self.theme.warning.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    #[instrument(skip(self))]\n    fn info(&self, message: &str) {\n        debug!(message, \"Outputting info\");\n        let mut text = Text::new(\"\");\n        text.append_styled(\"  ℹ \", Style::new().color(self.theme.accent.clone()));\n        text.append(message);\n        self.console.print_text(&text);\n    }\n    \n    #[instrument(skip(self, devices), fields(device_count = devices.len()))]\n    fn device_list(&self, devices: &[DeviceInfo]) {\n        debug!(\"Outputting device list\");\n        // Skeleton: Basic implementation\n        // Detailed table/panel formatting added in Phase 2 task\n        if devices.is_empty() {\n            trace!(\"No devices - showing warning\");\n            self.warning(\"No Stream Deck devices found\");\n            return;\n        }\n        \n        self.console.print(\"[bold]Connected Devices:[/]\");\n        for (i, device) in devices.iter().enumerate() {\n            trace!(index = i, serial = %device.serial, \"Listing device\");\n            self.console.print(&format!(\n                \"  {} ({})\",\n                device.product_name,\n                device.serial\n            ));\n        }\n    }\n    \n    #[instrument(skip(self, info), fields(serial = %info.serial))]\n    fn device_info(&self, info: &DeviceInfo) {\n        debug!(\"Outputting device info\");\n        self.console.print(&format!(\"[bold]{}[/]\", info.product_name));\n        self.console.print(&format!(\"  Serial: {}\", info.serial));\n        self.console.print(&format!(\"  Firmware: {}\", info.firmware_version));\n        self.console.print(&format!(\"  Keys: {} ({}x{})\", \n            info.key_count, info.cols, info.rows));\n    }\n    \n    #[instrument(skip(self, event), fields(key = event.key, pressed = event.pressed))]\n    fn button_event(&self, event: &ButtonEvent) {\n        trace!(\"Outputting button event\");\n        let (icon, action) = if event.pressed {\n            (\"●\", \"pressed\")\n        } else {\n            (\"○\", \"released\")\n        };\n        self.console.print(&format!(\"  {} Key {} {}\", icon, event.key, action));\n    }\n    \n    #[instrument(skip(self, states), fields(count = states.len()))]\n    fn button_states(&self, states: &[bool]) {\n        let pressed: Vec<_> = states.iter()\n            .enumerate()\n            .filter(|(_, &pressed)| pressed)\n            .map(|(i, _)| i.to_string())\n            .collect();\n        \n        trace!(pressed_count = pressed.len(), \"Outputting button states\");\n        \n        if pressed.is_empty() {\n            self.console.print(\"  No keys pressed\");\n        } else {\n            self.console.print(&format!(\"  Keys pressed: {}\", pressed.join(\", \")));\n        }\n    }\n    \n    #[instrument(skip(self))]\n    fn brightness_set(&self, level: u8) {\n        debug!(level, \"Outputting brightness set\");\n        self.success(&format!(\"Brightness set to {}%\", level));\n    }\n    \n    #[instrument(skip(self, image))]\n    fn key_set(&self, key: u8, image: &Path) {\n        let filename = image.file_name()\n            .map(|n| n.to_string_lossy().to_string())\n            .unwrap_or_else(|| image.display().to_string());\n        debug!(key, filename = %filename, \"Outputting key set\");\n        self.success(&format!(\"Key {} set to {}\", key, filename));\n    }\n    \n    #[instrument(skip(self))]\n    fn key_cleared(&self, key: u8) {\n        debug!(key, \"Outputting key cleared\");\n        self.success(&format!(\"Key {} cleared\", key));\n    }\n    \n    #[instrument(skip(self))]\n    fn key_filled(&self, key: u8, color: &str) {\n        debug!(key, color, \"Outputting key filled\");\n        self.success(&format!(\"Key {} filled with {}\", key, color));\n    }\n    \n    #[instrument(skip(self))]\n    fn all_cleared(&self) {\n        debug!(\"Outputting all cleared\");\n        self.success(\"All keys cleared\");\n    }\n    \n    #[instrument(skip(self))]\n    fn all_filled(&self, color: &str) {\n        debug!(color, \"Outputting all filled\");\n        self.success(&format!(\"All keys filled with {}\", color));\n    }\n    \n    #[instrument(skip(self))]\n    fn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n        debug!(version, ?git_sha, ?build_time, \"Outputting version info\");\n        self.console.print(&format!(\"[bold]sd[/] version {}\", version));\n        if let Some(sha) = git_sha {\n            self.console.print(&format!(\"  Git: {}\", sha));\n        }\n        if let Some(time) = build_time {\n            self.console.print(&format!(\"  Built: {}\", time));\n        }\n    }\n    \n    #[instrument(skip(self))]\n    fn rule(&self, title: Option<&str>) {\n        trace!(?title, \"Outputting rule\");\n        self.console.rule(title);\n    }\n    \n    fn newline(&self) {\n        self.console.print(\"\");\n    }\n}\n\n## Logging Guidelines\nAll Output trait methods include tracing instrumentation:\n- #[instrument] attribute on all public methods\n- debug! for method entry with key parameters\n- trace! for detailed internal steps\n- Skip large data (skip(self, devices)) to avoid log bloat\n\nRun with logging: RUST_LOG=sd::output=debug cargo run\n\n## Design Decisions\n\n### Why Skeleton First?\n1. Validates the Output trait design with real implementations\n2. Allows main.rs integration to proceed (Phase 3)\n3. Detailed formatting can be refined iteratively\n4. Basic functionality works while polish is added\n\n### Theme Ownership\nHumanOutput owns a SdTheme instance rather than borrowing it. This avoids lifetime complexity and themes are cheap to clone.\n\n### Console Clone\nrich_rust Console is designed to be cloned (internal state is Rc-wrapped). HumanOutput owns its Console for simplicity.\n\n### Unicode Symbols\nUsing Unicode for icons (✓, ✗, ⚠, ℹ, ●, ○) because:\n- rich_rust handles terminal capability detection\n- Fallback to ASCII can be added later if needed\n- Modern terminals universally support these\n\n## Implementation Steps\n1. Create src/output/human.rs\n2. Define HumanOutput struct with console and theme\n3. Add tracing dependency import\n4. Implement helper methods with #[instrument]\n5. Implement Output trait with tracing on all methods\n6. Test basic output in terminal\n7. Verify logging works with RUST_LOG\n\n## Acceptance Criteria\n- [ ] HumanOutput implements all Output trait methods\n- [ ] All methods have #[instrument] attribute\n- [ ] Basic output appears correctly in terminal\n- [ ] Theme colors are applied to styled text\n- [ ] Console.rule() works for visual separation\n- [ ] Error output shows suggestion when available\n- [ ] No panics or crashes in any method\n- [ ] RUST_LOG=debug shows method invocations","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:40.879633532Z","created_by":"ubuntu","updated_at":"2026-01-19T21:28:16.192582980Z","compaction_level":0,"original_size":0,"labels":["human-mode","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-248","depends_on_id":"bd-1es","type":"blocks","created_at":"2026-01-19T21:04:40.916158120Z","created_by":"ubuntu"},{"issue_id":"bd-248","depends_on_id":"bd-1lk","type":"blocks","created_at":"2026-01-19T21:04:40.922396977Z","created_by":"ubuntu"},{"issue_id":"bd-248","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:04:40.910289401Z","created_by":"ubuntu"}]}
{"id":"bd-24m","title":"Implement basic text rendering","description":"Create src/text.rs:\n```rust\npub fn render_text_image(\n    width: u32, height: u32,\n    text: &str,\n    font_size: f32,\n    text_color: Rgba<u8>,\n    bg_color: Rgba<u8>,\n) -> RgbaImage\n```\n\nUses ab_glyph for text rasterization.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:14.796958819Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:14.808425628Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-24m","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:14.808361998Z","created_by":"ubuntu"}]}
{"id":"bd-254","title":"Write tests for scripting hooks","description":"## Test Coverage for Scripting Hooks\n\n### Unit Tests\n\n1. **Template Substitution Tests**\n   - `{key}` replaced with key index\n   - `{key:02d}` formats with padding\n   - `{pressed}` replaced with \"press\" or \"release\"\n   - `{timestamp}` replaced with ISO timestamp\n   - Escaped `{{` becomes literal `{`\n   - Unknown placeholders returned unchanged (warn logged)\n   - Empty command after substitution → skip (no error)\n\n2. **Command Resolution Tests**\n   - --exec applies to all keys\n   - --on-press only fires on press\n   - --on-release only fires on release\n   - --keymap overrides inline flags\n   - Keymap range selectors match correctly\n   - First matching rule wins (specificity)\n\n3. **Keymap Parsing Tests**\n   - Valid YAML parses correctly\n   - Invalid YAML returns clear error\n   - Missing file returns clear error\n   - Empty keymap valid (no hooks)\n   - Key patterns: single, range, row\n\n4. **Execution Tests (mocked)**\n   - Command spawned via sh -c\n   - Non-blocking: doesn't wait for completion\n   - Environment variables passed correctly\n   - Working directory set correctly\n   - stdin closed immediately\n\n5. **Timeout Tests**\n   - Timeout kills long-running process\n   - Timeout emits warning/event\n   - Process tree killed (not just parent)\n   - Configurable timeout per command\n\n### Integration Tests (require MockDevice)\n\n1. **Watch Mode with Hooks**\n   - Start watch with --exec \"echo {key}\"\n   - Simulate key press via MockDevice\n   - Verify command executed\n   - Verify event emitted\n\n2. **Keymap File Integration**\n   - Load keymap from file\n   - Verify correct command for each key\n   - Verify range patterns work\n   - Verify row patterns work\n\n3. **Press/Release Distinction**\n   - --on-press fires only on press\n   - --on-release fires only on release\n   - Both can be specified simultaneously\n   - Simulate full press-release cycle\n\n4. **Robot Mode Hook Reporting**\n   - Hook start event emitted\n   - Hook completion event emitted\n   - Exit code included in completion\n   - Duration included in completion\n\n### E2E Tests (require E2E harness)\n\n1. **Basic Hook Execution**\n   ```bash\n   # Create test script that writes to file\n   echo '#!/bin/bash\\necho $1 >> /tmp/sd-test' > /tmp/hook.sh\n   chmod +x /tmp/hook.sh\n   \n   # Start watch with hook\n   sd watch --exec \"/tmp/hook.sh {key}\" &\n   \n   # Simulate key press (may need device or mock)\n   # ...\n   \n   # Verify hook executed\n   cat /tmp/sd-test  # Should contain key number\n   ```\n\n2. **Keymap File Test**\n   ```yaml\n   # tests/fixtures/keymaps/test.yaml\n   keys:\n     0:\n       press: \"echo 'key 0 pressed'\"\n     1-7:\n       press: \"notify-send 'Key {key}'\"\n       release: \"echo 'released {key}'\"\n   ```\n   \n   ```bash\n   sd watch --keymap tests/fixtures/keymaps/test.yaml\n   ```\n\n3. **Error Resilience Test**\n   - Hook that exits non-zero\n   - Hook that times out\n   - Hook that doesn't exist\n   - Watch mode continues despite hook failures\n\n4. **Security Test**\n   - Command injection via key index not possible (numeric only)\n   - Shell metacharacters in keymap commands work as expected\n   - No unintended environment leakage\n\n### Test Fixtures (tests/fixtures/keymaps/)\n\n```\nkeymaps/\n├── basic.yaml           # Simple echo commands\n├── all-keys.yaml        # Command for every key\n├── ranges.yaml          # Range patterns (0-7, 8-15)\n├── press-release.yaml   # Different press/release commands\n├── timeout-test.yaml    # Commands that will timeout\n├── error-test.yaml      # Commands that fail\n└── invalid.yaml         # Parse error for testing\n```\n\n### Logging Requirements\n- DEBUG: Command being executed, template substitution\n- INFO: Hook started for key N\n- WARN: Hook timeout, hook non-zero exit\n- ERROR: Hook spawn failure, keymap parse error\n\n### Security Considerations in Tests\n- Verify no shell injection possible\n- Verify hooks run as current user\n- Verify working directory is safe\n- Verify environment is sanitized","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:26:22.353005212Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:10.454551639Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-254","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:22.367692125Z","created_by":"ubuntu"},{"issue_id":"bd-254","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:53.712324794Z","created_by":"ubuntu"},{"issue_id":"bd-254","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:10.454508237Z","created_by":"ubuntu"}]}
{"id":"bd-26w","title":"Implement color fill endpoint","description":"PUT /api/keys/:id/color { \"color\": \"#FF5500\" }\n- Parse color\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:45.404624395Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:45.421082954Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26w","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:45.421027660Z","created_by":"ubuntu"}]}
{"id":"bd-26y","title":"Add robot mode output for watch-config","description":"## Purpose\nAdd robot mode JSON output for the watch-config command to enable programmatic monitoring of configuration changes.\n\n## Implementation\n\\`\\`\\`rust\n// src/watch_config/events.rs\nuse chrono::{DateTime, Utc};\nuse serde::Serialize;\nuse std::path::PathBuf;\n\n/// Robot mode events for watch-config\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"event\", rename_all = \"snake_case\")]\npub enum WatchConfigEvent {\n    /// Started watching a config file\n    Watching {\n        path: PathBuf,\n        debounce_ms: u64,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// File change detected\n    ChangeDetected {\n        path: PathBuf,\n        change_type: FileChangeType,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Debounce timer started\n    DebounceStarted {\n        timeout_ms: u64,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Beginning to apply configuration\n    Applying {\n        path: PathBuf,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Configuration applied successfully\n    Applied {\n        path: PathBuf,\n        changes: ConfigChangeSummary,\n        duration_ms: u64,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Error occurred\n    Error {\n        error_type: WatchConfigErrorType,\n        message: String,\n        recoverable: bool,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Watching paused (e.g., during apply)\n    Paused {\n        reason: String,\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Watching resumed\n    Resumed {\n        timestamp: DateTime<Utc>,\n    },\n    \n    /// Watch stopped\n    Stopped {\n        reason: String,\n        timestamp: DateTime<Utc>,\n    },\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum FileChangeType {\n    Modified,\n    Created,\n    Deleted,\n    Renamed,\n    Unknown,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConfigChangeSummary {\n    pub brightness_changed: bool,\n    pub brightness_value: Option<u8>,\n    pub keys_updated: usize,\n    pub keys_cleared: usize,\n    pub keys_unchanged: usize,\n    pub errors: Vec<KeyChangeError>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct KeyChangeError {\n    pub key: u8,\n    pub error: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum WatchConfigErrorType {\n    FileNotFound,\n    ParseError,\n    DeviceError,\n    PermissionDenied,\n    WatcherError,\n    ApplyError,\n}\n\n/// Emit robot mode event\npub fn emit_event(event: &WatchConfigEvent) {\n    println!(\"{}\", serde_json::to_string(event).unwrap());\n}\n\\`\\`\\`\n\n### Example Output Stream\n\\`\\`\\`json\n{\"event\":\"watching\",\"path\":\"/home/user/.config/sd/current.yaml\",\"debounce_ms\":500,\"timestamp\":\"2024-01-15T10:30:00Z\"}\n{\"event\":\"change_detected\",\"path\":\"/home/user/.config/sd/current.yaml\",\"change_type\":\"modified\",\"timestamp\":\"2024-01-15T10:30:15Z\"}\n{\"event\":\"debounce_started\",\"timeout_ms\":500,\"timestamp\":\"2024-01-15T10:30:15Z\"}\n{\"event\":\"applying\",\"path\":\"/home/user/.config/sd/current.yaml\",\"timestamp\":\"2024-01-15T10:30:15.500Z\"}\n{\"event\":\"applied\",\"path\":\"/home/user/.config/sd/current.yaml\",\"changes\":{\"brightness_changed\":true,\"brightness_value\":80,\"keys_updated\":5,\"keys_cleared\":0,\"keys_unchanged\":27,\"errors\":[]},\"duration_ms\":450,\"timestamp\":\"2024-01-15T10:30:15.950Z\"}\n{\"event\":\"change_detected\",\"path\":\"/home/user/.config/sd/current.yaml\",\"change_type\":\"modified\",\"timestamp\":\"2024-01-15T10:31:00Z\"}\n{\"event\":\"error\",\"error_type\":\"parse_error\",\"message\":\"Invalid YAML at line 15: expected string\",\"recoverable\":true,\"timestamp\":\"2024-01-15T10:31:00.500Z\"}\n\\`\\`\\`\n\n### Integration with Watch Loop\n\\`\\`\\`rust\n// In watch_config command handler\nasync fn watch_config_loop(\n    device: &mut Device,\n    config_path: &Path,\n    debounce_ms: u64,\n    robot_mode: bool,\n) -> Result<()> {\n    // Emit initial watching event\n    if robot_mode {\n        emit_event(&WatchConfigEvent::Watching {\n            path: config_path.to_path_buf(),\n            debounce_ms,\n            timestamp: Utc::now(),\n        });\n    } else {\n        println!(\"Watching {} for changes...\", config_path.display());\n    }\n    \n    // ... file watcher setup\n    \n    loop {\n        match rx.recv() {\n            Ok(event) => {\n                if robot_mode {\n                    emit_event(&WatchConfigEvent::ChangeDetected {\n                        path: config_path.to_path_buf(),\n                        change_type: event.kind.into(),\n                        timestamp: Utc::now(),\n                    });\n                }\n                \n                // Debounce\n                if robot_mode {\n                    emit_event(&WatchConfigEvent::DebounceStarted {\n                        timeout_ms: debounce_ms,\n                        timestamp: Utc::now(),\n                    });\n                }\n                tokio::time::sleep(Duration::from_millis(debounce_ms)).await;\n                \n                // Apply configuration\n                if robot_mode {\n                    emit_event(&WatchConfigEvent::Applying {\n                        path: config_path.to_path_buf(),\n                        timestamp: Utc::now(),\n                    });\n                }\n                \n                let start = Instant::now();\n                match apply_config(device, config_path).await {\n                    Ok(changes) => {\n                        if robot_mode {\n                            emit_event(&WatchConfigEvent::Applied {\n                                path: config_path.to_path_buf(),\n                                changes,\n                                duration_ms: start.elapsed().as_millis() as u64,\n                                timestamp: Utc::now(),\n                            });\n                        } else {\n                            println!(\"✓ Applied {} key changes\", changes.keys_updated);\n                        }\n                    }\n                    Err(e) => {\n                        if robot_mode {\n                            emit_event(&WatchConfigEvent::Error {\n                                error_type: e.error_type(),\n                                message: e.to_string(),\n                                recoverable: e.is_recoverable(),\n                                timestamp: Utc::now(),\n                            });\n                        } else {\n                            eprintln!(\"Error: {}\", e);\n                        }\n                    }\n                }\n            }\n            Err(e) => {\n                // Watcher error\n                if robot_mode {\n                    emit_event(&WatchConfigEvent::Error {\n                        error_type: WatchConfigErrorType::WatcherError,\n                        message: e.to_string(),\n                        recoverable: false,\n                        timestamp: Utc::now(),\n                    });\n                }\n                break;\n            }\n        }\n    }\n    \n    if robot_mode {\n        emit_event(&WatchConfigEvent::Stopped {\n            reason: \"Normal exit\".to_string(),\n            timestamp: Utc::now(),\n        });\n    }\n    \n    Ok(())\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] All watch-config events emit robot mode JSON\n- [ ] Events include timestamps\n- [ ] Change summary includes detailed statistics\n- [ ] Error events include type and recoverability\n- [ ] Output is valid NDJSON (one JSON object per line)\n\n## Logging Requirements\n- TRACE: (none - robot mode doesn't log)\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:35.466745652Z","created_by":"ubuntu","updated_at":"2026-01-19T21:30:13.159797475Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26y","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.477087133Z","created_by":"ubuntu"}]}
{"id":"bd-271","title":"EPIC: Web Dashboard (Complete serve Command)","description":"## Overview\n**Rank: #14 of 15** | **Impact: High** | **Effort: High** | **Confidence: Medium**\n\nVisual browser-based interface for configuring Stream Deck, completing the stubbed `sd serve` command.\n\n## Problem Statement\nNot everyone wants a CLI. Visual editing is more intuitive for:\n- Designing key layouts\n- Previewing images before applying\n- Drag-and-drop configuration\n- Non-technical users\n- Quick experimentation\n\nThe official Elgato software provides this, but is closed-source and limited to official features.\n\n## Solution\nLocal web server with visual editor:\n```bash\nsd serve --port 8420\n# Opens http://localhost:8420\n\n# With specific device\nsd serve --serial ABC123 --port 8420\n\n# Headless mode (no browser auto-open)\nsd serve --no-open --port 8420\n```\n\nWeb interface features:\n- Visual grid of keys matching device layout\n- Drag-and-drop images onto keys\n- Color picker for fill colors\n- Brightness slider\n- Live preview (changes apply immediately)\n- Configuration save/load\n- Device status display\n\n## Why This Is #14 Priority\n1. **High effort**: Full web frontend + API = significant work\n2. **Competes with Elgato**: Official software already does this\n3. **Different audience**: CLI users may not want web UI\n4. **Already stubbed**: The serve command exists in code\n5. **Nice to have**: Not essential for CLI-first users\n\n## Architecture\n```\nBrowser (React/Preact/Vanilla JS)\n    ↓ HTTP/WebSocket\nsd serve (axum)\n    ↓ \nDevice Module\n    ↓\nStream Deck Hardware\n```\n\n## Implementation Approach\n\n### Phase 1: REST API\n```rust\n// In src/server/mod.rs (new)\nuse axum::{Router, Json, extract::State};\n\npub fn create_router(device: Arc<Mutex<Device>>) -> Router {\n    Router::new()\n        .route(\"/api/device\", get(get_device_info))\n        .route(\"/api/brightness\", get(get_brightness).put(set_brightness))\n        .route(\"/api/keys\", get(get_keys))\n        .route(\"/api/keys/:id\", put(set_key).delete(clear_key))\n        .route(\"/api/keys/:id/image\", post(upload_image))\n        .route(\"/api/keys/:id/color\", put(set_color))\n        .route(\"/api/config\", get(get_config).post(save_config))\n        .nest_service(\"/\", ServeDir::new(\"static\"))\n        .with_state(AppState { device })\n}\n\n// API handlers\nasync fn get_device_info(State(state): State<AppState>) -> Json<DeviceInfo> {\n    let device = state.device.lock().unwrap();\n    Json(device.info().clone())\n}\n\nasync fn set_brightness(\n    State(state): State<AppState>,\n    Json(req): Json<BrightnessRequest>,\n) -> Result<Json<()>, ApiError> {\n    let device = state.device.lock().unwrap();\n    device.set_brightness(req.level)?;\n    Ok(Json(()))\n}\n\nasync fn set_key(\n    State(state): State<AppState>,\n    Path(key): Path<u8>,\n    mut multipart: Multipart,\n) -> Result<Json<()>, ApiError> {\n    // Handle image upload\n    while let Some(field) = multipart.next_field().await? {\n        if field.name() == Some(\"image\") {\n            let data = field.bytes().await?;\n            let device = state.device.lock().unwrap();\n            set_key_from_bytes(&device, key, &data)?;\n        }\n    }\n    Ok(Json(()))\n}\n```\n\n### Phase 2: WebSocket for Live Updates\n```rust\n// Real-time key press events\nasync fn ws_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<AppState>,\n) -> impl IntoResponse {\n    ws.on_upgrade(|socket| handle_websocket(socket, state))\n}\n\nasync fn handle_websocket(mut socket: WebSocket, state: AppState) {\n    // Send key events as they happen\n    loop {\n        if let Some(event) = state.event_rx.recv().await {\n            let msg = serde_json::to_string(&event).unwrap();\n            if socket.send(Message::Text(msg)).await.is_err() {\n                break;\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Frontend (Embedded Static Files)\n```rust\n// Embed static files in binary\nuse rust_embed::RustEmbed;\n\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n\n// Or serve from filesystem in dev mode\n#[cfg(debug_assertions)]\nfn static_handler() -> ServeDir {\n    ServeDir::new(\"static\")\n}\n\n#[cfg(not(debug_assertions))]\nfn static_handler() -> EmbeddedAssets {\n    EmbeddedAssets::new()\n}\n```\n\nFrontend stack options (keep simple):\n- **Vanilla JS + HTML**: Zero build step, ~2KB\n- **Preact**: Small React-like library, ~4KB\n- **Alpine.js**: Declarative, ~15KB\n\nRecommended: Vanilla JS with modern features for simplicity.\n\n## API Specification\n```yaml\n# OpenAPI-style specification\npaths:\n  /api/device:\n    get:\n      summary: Get device information\n      response: { model, serial, key_count, key_size, firmware }\n  \n  /api/brightness:\n    get:\n      summary: Get current brightness\n      response: { level: 0-100 }\n    put:\n      summary: Set brightness\n      body: { level: 0-100 }\n  \n  /api/keys:\n    get:\n      summary: Get all key states (if tracked)\n      response: [{ index, source, type }]\n  \n  /api/keys/{id}:\n    put:\n      summary: Set key image (multipart form)\n    delete:\n      summary: Clear key\n  \n  /api/keys/{id}/color:\n    put:\n      summary: Fill key with color\n      body: { color: \"#RRGGBB\" }\n  \n  /api/config:\n    get:\n      summary: Export current config as YAML\n    post:\n      summary: Import and apply config\n```\n\n## Key Design Decisions\n1. **Local only**: No authentication needed (localhost)\n2. **Single device**: Serve manages one device at a time\n3. **Embedded assets**: Single binary deployment\n4. **REST + WebSocket**: REST for actions, WS for events\n5. **Minimal frontend**: Avoid heavy frameworks\n\n## Success Criteria\n- [ ] `sd serve` starts web server on configurable port\n- [ ] Device info displayed in browser\n- [ ] Brightness slider works\n- [ ] Can set key images via drag-and-drop\n- [ ] Can fill keys with colors via picker\n- [ ] Can clear keys\n- [ ] Live key press events via WebSocket\n- [ ] Configuration export/import\n\n## Files to Create/Modify\n- `src/server/mod.rs`: New web server module\n- `src/server/api.rs`: REST API handlers\n- `src/server/ws.rs`: WebSocket handler\n- `static/index.html`: Frontend HTML\n- `static/app.js`: Frontend JavaScript\n- `static/style.css`: Frontend styles\n- `Cargo.toml`: Add axum, tower, rust-embed dependencies\n\n## Dependencies\n- Soft: Benefits from DECLARATIVE-CONFIG for import/export\n\n## Estimated Subtasks\n1. Set up axum server skeleton\n2. Implement device info endpoint\n3. Implement brightness endpoint\n4. Implement key image upload endpoint\n5. Implement color fill endpoint\n6. Implement clear key endpoint\n7. Add WebSocket for key events\n8. Build frontend HTML structure\n9. Build frontend JavaScript logic\n10. Add configuration export/import\n11. Embed static files in binary\n12. Add --no-open flag\n13. Write integration tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:22:15.417798563Z","created_by":"ubuntu","updated_at":"2026-01-19T18:22:15.457603949Z","compaction_level":0,"original_size":0,"labels":["priority-14","serve","visual","web"]}
{"id":"bd-28r","title":"Add WebSocket for key events","description":"## Purpose\nReal-time WebSocket endpoint for streaming key press/release events to connected browser clients.\n\n## Implementation\n\\`\\`\\`rust\n// src/server/websocket.rs\nuse axum::{\n    extract::{State, ws::{WebSocket, WebSocketUpgrade, Message}},\n    response::IntoResponse,\n};\nuse futures_util::{SinkExt, StreamExt};\nuse tokio::sync::broadcast;\nuse serde::Serialize;\nuse tracing::{debug, info, warn, error, instrument, span, Level};\n\nuse crate::server::AppState;\n\n/// WebSocket message types sent to clients\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum WsEvent {\n    /// Key was pressed\n    KeyPressed { key: u8, timestamp: String },\n    /// Key was released\n    KeyReleased { key: u8, timestamp: String },\n    /// Device connection status changed\n    DeviceStatus { connected: bool, serial: Option<String> },\n    /// Heartbeat/ping\n    Ping { server_time: String },\n}\n\n/// Handler for WebSocket upgrade requests\n#[instrument(skip(ws, state))]\npub async fn ws_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<AppState>,\n) -> impl IntoResponse {\n    info!(\"WebSocket upgrade request received\");\n    ws.on_upgrade(|socket| handle_ws_connection(socket, state))\n}\n\n/// Handle individual WebSocket connection\nasync fn handle_ws_connection(socket: WebSocket, state: AppState) {\n    let (mut sender, mut receiver) = socket.split();\n    let mut event_rx = state.event_bus().subscribe();\n    \n    let client_id = uuid::Uuid::new_v4();\n    info!(client_id = %client_id, \"WebSocket client connected\");\n    \n    // Send initial device status\n    let connected = state.device().await.is_connected();\n    let initial_msg = serde_json::to_string(&WsEvent::DeviceStatus {\n        connected,\n        serial: state.device().await.serial().map(|s| s.to_string()),\n    }).unwrap();\n    \n    if let Err(e) = sender.send(Message::Text(initial_msg)).await {\n        warn!(client_id = %client_id, error = %e, \"Failed to send initial status\");\n        return;\n    }\n    \n    // Spawn task to forward events to this client\n    let send_task = tokio::spawn(async move {\n        while let Ok(event) = event_rx.recv().await {\n            let msg = match serde_json::to_string(&event) {\n                Ok(json) => json,\n                Err(e) => {\n                    error!(error = %e, \"Failed to serialize event\");\n                    continue;\n                }\n            };\n            \n            if let Err(e) = sender.send(Message::Text(msg)).await {\n                debug!(error = %e, \"Client disconnected\");\n                break;\n            }\n        }\n    });\n    \n    // Handle incoming messages (for future ping/pong or client requests)\n    while let Some(msg) = receiver.next().await {\n        match msg {\n            Ok(Message::Ping(data)) => {\n                // axum handles pong automatically\n                debug!(\"Received ping\");\n            }\n            Ok(Message::Close(_)) => {\n                debug!(client_id = %client_id, \"Client requested close\");\n                break;\n            }\n            Err(e) => {\n                warn!(client_id = %client_id, error = %e, \"WebSocket error\");\n                break;\n            }\n            _ => {}\n        }\n    }\n    \n    send_task.abort();\n    info!(client_id = %client_id, \"WebSocket client disconnected\");\n}\n\\`\\`\\`\n\n### Event Bus Integration\n\\`\\`\\`rust\n// Add to src/server/state.rs\nuse tokio::sync::broadcast;\n\npub struct AppState {\n    device: Arc<RwLock<Device>>,\n    event_bus: broadcast::Sender<WsEvent>,\n}\n\nimpl AppState {\n    pub fn new(device: Device) -> Self {\n        let (event_bus, _) = broadcast::channel(100);\n        Self {\n            device: Arc::new(RwLock::new(device)),\n            event_bus,\n        }\n    }\n    \n    pub fn event_bus(&self) -> &broadcast::Sender<WsEvent> {\n        &self.event_bus\n    }\n    \n    pub fn emit_event(&self, event: WsEvent) {\n        // Ignore send error if no subscribers\n        let _ = self.event_bus.send(event);\n    }\n}\n\\`\\`\\`\n\n### Route Registration\n\\`\\`\\`rust\n// In create_router()\nlet api_routes = Router::new()\n    // ... existing routes\n    .route(\"/events\", get(websocket::ws_handler));\n\\`\\`\\`\n\n### Client-Side Usage\n\\`\\`\\`javascript\n// In frontend JavaScript\nconst ws = new WebSocket(\\`ws://\\${location.host}/api/events\\`);\n\nws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    switch (data.type) {\n        case 'key_pressed':\n            highlightKey(data.key, true);\n            break;\n        case 'key_released':\n            highlightKey(data.key, false);\n            break;\n        case 'device_status':\n            updateConnectionStatus(data.connected);\n            break;\n    }\n};\n\nws.onclose = () => {\n    console.log('WebSocket closed, will reconnect...');\n    setTimeout(connectWebSocket, 1000);\n};\n\\`\\`\\`\n\n## Dependencies to Add\n\\`\\`\\`toml\n# Cargo.toml additions\n[dependencies]\nfutures-util = \"0.3\"\n\\`\\`\\`\n\n## Success Criteria\n- [ ] WebSocket endpoint accepts connections at /api/events\n- [ ] Initial device status sent on connect\n- [ ] Key press/release events streamed to all clients\n- [ ] Device status changes broadcasted\n- [ ] Graceful handling of client disconnects\n- [ ] Multiple concurrent clients supported\n\n## Logging Requirements\n- TRACE: (none)\n- DEBUG: Ping received, client disconnected\n- INFO: WebSocket upgrade request, client connected/disconnected\n- WARN: Failed to send initial status, WebSocket errors\n- ERROR: Failed to serialize event","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.083855094Z","created_by":"ubuntu","updated_at":"2026-01-19T21:25:40.220296594Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-28r","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.101714961Z","created_by":"ubuntu"}]}
{"id":"bd-298","title":"Implement clear key endpoint","description":"DELETE /api/keys/:id\n- Clear specified key\n- Return success","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:46.247930850Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:46.263618777Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-298","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:46.263574033Z","created_by":"ubuntu"}]}
{"id":"bd-2a1","title":"Update single commands to use retry logic","description":"## Purpose\nModify command dispatch in main.rs to use retry logic for all device-opening commands.\n\n## Implementation\n\n### Identify Device Commands\nCommands that open a device:\n- `info` - reads device info\n- `brightness` - sets brightness\n- `set-key` - sets key image\n- `fill-key` - fills key with color\n- `clear-key` - clears a key\n- `clear-all` - clears all keys\n- `watch` - monitors key events\n- `set-keys` (batch) - sets multiple key images\n- `fill-keys` (batch) - fills multiple keys\n- `clear-keys` (batch) - clears multiple keys\n\n### Command Dispatch Pattern\n```rust\n// src/main.rs\nuse crate::device::{Device, ConnectionOptions};\n\nasync fn run() -> Result<()> {\n    let cli = Cli::parse();\n    \n    // Build connection options from global flags\n    let conn_opts = cli.global.connection_options();\n    \n    match cli.command {\n        Command::Info => {\n            let device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_info(&device, &cli.global).await\n        }\n        Command::Brightness { level } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_brightness(&mut device, level, &cli.global).await\n        }\n        Command::SetKey { key, image } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_set_key(&mut device, key, &image, &cli.global).await\n        }\n        Command::FillKey { key, color } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_fill_key(&mut device, key, &color, &cli.global).await\n        }\n        Command::ClearKey { key } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_clear_key(&mut device, key, &cli.global).await\n        }\n        Command::ClearAll => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_clear_all(&mut device, &cli.global).await\n        }\n        Command::Watch { .. } => {\n            // Watch has special reconnect logic (bd-326)\n            let device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_watch(device, &cli).await\n        }\n        // Batch commands\n        Command::SetKeys { .. } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_set_keys(&mut device, &cli).await\n        }\n        Command::FillKeys { .. } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_fill_keys(&mut device, &cli).await\n        }\n        Command::ClearKeys { .. } => {\n            let mut device = Device::open_with_retry(cli.global.serial.as_deref(), &conn_opts)?;\n            cmd_clear_keys(&mut device, &cli).await\n        }\n        // Non-device commands (no retry needed)\n        Command::Completions { shell } => cmd_completions(shell),\n        Command::Validate { config } => cmd_validate(&config).await,\n    }\n}\n```\n\n### Helper Macro (Optional)\n```rust\n/// Macro to reduce boilerplate for device commands\nmacro_rules! with_device {\n    ($cli:expr, $conn_opts:expr, |$dev:ident| $body:expr) => {{\n        let $dev = Device::open_with_retry($cli.global.serial.as_deref(), $conn_opts)?;\n        $body\n    }};\n    (mut $cli:expr, $conn_opts:expr, |$dev:ident| $body:expr) => {{\n        let mut $dev = Device::open_with_retry($cli.global.serial.as_deref(), $conn_opts)?;\n        $body\n    }};\n}\n\n// Usage:\nCommand::Info => with_device!(cli, &conn_opts, |device| {\n    cmd_info(&device, &cli.global).await\n}),\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_info_uses_retry() {\n        // This test uses MockDevice (bd-180) to verify retry behavior\n        let mock = MockDevice::builder()\n            .fail_first_n_opens(2)\n            .then_succeed()\n            .build();\n        \n        let opts = ConnectionOptions {\n            max_retries: 3,\n            retry_delay: Duration::from_millis(10),\n            ..Default::default()\n        };\n        \n        let result = Device::open_with_retry(None, &opts);\n        assert!(result.is_ok());\n    }\n    \n    #[tokio::test]\n    async fn test_all_device_commands_retry() {\n        // Ensure each command path uses open_with_retry\n        // This is a compile-time check via the dispatch pattern\n    }\n}\n```\n\n## E2E Test Script\n```bash\n#!/bin/bash\n# tests/e2e/test_retry_integration.sh\n\nset -e\n\necho \"Testing retry integration...\"\n\n# Test 1: No retry (default) - should fail fast\nif sd info 2>&1 | grep -q \"retrying\"; then\n    echo \"FAIL: Default should not retry\"\n    exit 1\nfi\necho \"PASS: Default no retry\"\n\n# Test 2: With retry flag - should show retry attempts in human mode\noutput=$(sd --retry 2 info 2>&1 || true)\nif [[ \"$output\" == *\"Connection failed\"* ]] && [[ \"$output\" == *\"retrying\"* ]]; then\n    echo \"PASS: Retry messages shown\"\nelse\n    echo \"PASS: (device connected on first attempt)\"\nfi\n\n# Test 3: Robot mode shows retry events\noutput=$(sd --retry 2 --robot info 2>&1 || true)\nif echo \"$output\" | jq -e '.event == \"connection_attempt\"' > /dev/null 2>&1; then\n    echo \"PASS: Robot mode emits connection events\"\nelse\n    echo \"PASS: (device connected immediately)\"\nfi\n\necho \"All retry integration tests passed!\"\n```\n\n## Logging Requirements\n- TRACE: Command dispatch entry\n- DEBUG: Connection options applied to command\n- INFO: Command starting with retry config\n- WARN: (handled by open_with_retry)\n- ERROR: (handled by open_with_retry)\n\n## Success Criteria\n- [ ] All device commands use open_with_retry\n- [ ] Non-device commands unaffected\n- [ ] GlobalOpts.connection_options() used consistently\n- [ ] Retry events emitted in robot mode\n- [ ] Human mode shows retry status\n- [ ] E2E tests validate integration","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.244590391Z","created_by":"ubuntu","updated_at":"2026-01-21T11:04:02.654943162Z","closed_at":"2026-01-21T11:04:02.654891605Z","close_reason":"All 10 device-opening commands now use open_device(cli) helper which respects retry flags","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2a1","depends_on_id":"bd-1os","type":"blocks","created_at":"2026-01-19T21:53:04.911013461Z","created_by":"ubuntu"},{"issue_id":"bd-2a1","depends_on_id":"bd-rfp","type":"blocks","created_at":"2026-01-19T21:53:00.855510828Z","created_by":"ubuntu"},{"issue_id":"bd-2a1","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.256753532Z","created_by":"ubuntu"}]}
{"id":"bd-2ag","title":"Implement TokenBucket for burst scenarios","description":"## Purpose\nAdvanced rate limiter with burst capacity for scenarios requiring occasional high throughput.\n\n## Implementation\n\\`\\`\\`rust\n// src/rate_limit.rs (extend existing file)\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, instrument};\n\n/// Token bucket rate limiter with burst capacity\n/// \n/// Allows bursts up to capacity, then rate-limits to refill_rate.\n/// Tokens refill continuously based on elapsed time.\n#[derive(Debug)]\npub struct TokenBucket {\n    /// Maximum tokens (burst capacity)\n    capacity: usize,\n    /// Current available tokens (fractional for smooth refill)\n    tokens: f64,\n    /// Tokens added per second\n    refill_rate: f64,\n    /// Last time we calculated token refill\n    last_refill: Instant,\n}\n\nimpl TokenBucket {\n    /// Create a new token bucket\n    /// \n    /// # Arguments\n    /// * \\`capacity\\` - Maximum burst size\n    /// * \\`refill_rate\\` - Tokens per second to refill\n    #[instrument]\n    pub fn new(capacity: usize, refill_rate: f64) -> Self {\n        debug!(\n            capacity = %capacity,\n            refill_rate = %refill_rate,\n            \"Token bucket created\"\n        );\n        Self {\n            capacity,\n            tokens: capacity as f64, // Start full\n            refill_rate,\n            last_refill: Instant::now(),\n        }\n    }\n    \n    /// Create from operations per second with specified burst\n    pub fn from_rate(ops_per_second: f64, burst_size: usize) -> Self {\n        Self::new(burst_size, ops_per_second)\n    }\n    \n    /// Refill tokens based on elapsed time\n    fn refill(&mut self) {\n        let now = Instant::now();\n        let elapsed = now.duration_since(self.last_refill).as_secs_f64();\n        self.tokens = (self.tokens + elapsed * self.refill_rate)\n            .min(self.capacity as f64);\n        self.last_refill = now;\n    }\n    \n    /// Check if a token is available (non-blocking)\n    pub fn check(&mut self) -> bool {\n        self.refill();\n        self.tokens >= 1.0\n    }\n    \n    /// Try to consume a token (non-blocking)\n    /// Returns true if successful, false if no tokens available\n    pub fn try_acquire(&mut self) -> bool {\n        self.refill();\n        if self.tokens >= 1.0 {\n            self.tokens -= 1.0;\n            trace!(remaining = %self.tokens, \"Token acquired\");\n            true\n        } else {\n            trace!(available = %self.tokens, \"No tokens available\");\n            false\n        }\n    }\n    \n    /// Try to consume multiple tokens at once\n    pub fn try_acquire_many(&mut self, count: usize) -> bool {\n        self.refill();\n        let needed = count as f64;\n        if self.tokens >= needed {\n            self.tokens -= needed;\n            trace!(acquired = %count, remaining = %self.tokens, \"Tokens acquired\");\n            true\n        } else {\n            trace!(\n                requested = %count,\n                available = %self.tokens,\n                \"Insufficient tokens\"\n            );\n            false\n        }\n    }\n    \n    /// Wait until a token is available (async)\n    #[instrument(skip(self))]\n    pub async fn wait(&mut self) {\n        self.refill();\n        if self.tokens < 1.0 {\n            let needed = 1.0 - self.tokens;\n            let wait_secs = needed / self.refill_rate;\n            let wait_time = Duration::from_secs_f64(wait_secs);\n            trace!(wait_ms = %wait_time.as_millis(), \"Waiting for token\");\n            tokio::time::sleep(wait_time).await;\n            self.refill();\n        }\n        self.tokens -= 1.0;\n    }\n    \n    /// Time until a token is available\n    pub fn time_until_token(&mut self) -> Duration {\n        self.refill();\n        if self.tokens >= 1.0 {\n            Duration::ZERO\n        } else {\n            let needed = 1.0 - self.tokens;\n            Duration::from_secs_f64(needed / self.refill_rate)\n        }\n    }\n    \n    /// Get current available tokens (may be fractional)\n    pub fn available(&mut self) -> f64 {\n        self.refill();\n        self.tokens\n    }\n    \n    /// Get capacity\n    pub fn capacity(&self) -> usize {\n        self.capacity\n    }\n    \n    /// Get refill rate (tokens per second)\n    pub fn refill_rate(&self) -> f64 {\n        self.refill_rate\n    }\n    \n    /// Reset to full capacity\n    pub fn reset(&mut self) {\n        self.tokens = self.capacity as f64;\n        self.last_refill = Instant::now();\n        debug!(\"Token bucket reset to full\");\n    }\n}\n\n/// Robot mode token bucket status\n#[derive(serde::Serialize)]\npub struct TokenBucketStatus {\n    pub available_tokens: f64,\n    pub capacity: usize,\n    pub refill_rate: f64,\n    pub wait_ms: u64,\n}\n\nimpl TokenBucket {\n    /// Get status for robot mode output\n    pub fn status(&mut self) -> TokenBucketStatus {\n        self.refill();\n        TokenBucketStatus {\n            available_tokens: self.tokens,\n            capacity: self.capacity,\n            refill_rate: self.refill_rate,\n            wait_ms: self.time_until_token().as_millis() as u64,\n        }\n    }\n}\n\\`\\`\\`\n\n## Unit Tests\n\\`\\`\\`rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_initial_burst() {\n        let mut bucket = TokenBucket::new(5, 1.0);\n        // Should allow 5 immediate operations\n        for _ in 0..5 {\n            assert!(bucket.try_acquire());\n        }\n        // 6th should fail\n        assert!(!bucket.try_acquire());\n    }\n    \n    #[test]\n    fn test_refill() {\n        let mut bucket = TokenBucket::new(5, 10.0); // 10 tokens/sec\n        \n        // Exhaust tokens\n        for _ in 0..5 {\n            bucket.try_acquire();\n        }\n        assert!(!bucket.check());\n        \n        // Wait for refill (100ms = 1 token at 10/sec)\n        std::thread::sleep(Duration::from_millis(150));\n        assert!(bucket.check());\n        assert!(bucket.try_acquire());\n    }\n    \n    #[test]\n    fn test_partial_refill() {\n        let mut bucket = TokenBucket::new(10, 100.0); // 100 tokens/sec\n        \n        // Use all tokens\n        for _ in 0..10 {\n            bucket.try_acquire();\n        }\n        \n        // Wait 50ms = 5 tokens\n        std::thread::sleep(Duration::from_millis(55));\n        let available = bucket.available();\n        assert!(available >= 4.5 && available <= 6.0);\n    }\n    \n    #[test]\n    fn test_acquire_many() {\n        let mut bucket = TokenBucket::new(10, 1.0);\n        \n        assert!(bucket.try_acquire_many(5));\n        assert!(bucket.try_acquire_many(3));\n        assert!(!bucket.try_acquire_many(5)); // Only 2 left\n        assert!(bucket.try_acquire_many(2));\n        assert!(!bucket.try_acquire());\n    }\n    \n    #[test]\n    fn test_capacity_cap() {\n        let mut bucket = TokenBucket::new(5, 100.0);\n        std::thread::sleep(Duration::from_millis(100)); // Would add 10 tokens\n        \n        let available = bucket.available();\n        assert_eq!(available, 5.0); // Capped at capacity\n    }\n    \n    #[tokio::test]\n    async fn test_async_wait() {\n        let mut bucket = TokenBucket::new(1, 100.0); // Fast refill\n        bucket.try_acquire(); // Exhaust\n        \n        let start = Instant::now();\n        bucket.wait().await;\n        let elapsed = start.elapsed();\n        \n        // Should have waited ~10ms (1/100 sec)\n        assert!(elapsed >= Duration::from_millis(5));\n        assert!(elapsed < Duration::from_millis(50));\n    }\n    \n    #[test]\n    fn test_reset() {\n        let mut bucket = TokenBucket::new(5, 1.0);\n        for _ in 0..5 {\n            bucket.try_acquire();\n        }\n        assert!(!bucket.check());\n        \n        bucket.reset();\n        assert!(bucket.check());\n        assert_eq!(bucket.available(), 5.0);\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] TokenBucket allows bursts up to capacity\n- [ ] Tokens refill at correct rate\n- [ ] Capacity is respected (no overflow)\n- [ ] acquire_many works for batch operations\n- [ ] Async wait computes correct sleep duration\n- [ ] Robot mode status reporting works\n\n## Logging Requirements\n- TRACE: Token acquired, insufficient tokens\n- DEBUG: Token bucket created, reset\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:18.947415931Z","created_by":"ubuntu","updated_at":"2026-01-19T21:26:34.661265145Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ag","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:18.965819181Z","created_by":"ubuntu"}]}
{"id":"bd-2gt","title":"Add cache stats command","description":"Implement sd cache stats:\n- Location: ~/.cache/sd/images/\n- Entry count\n- Total size (bytes, formatted)\n- Optional: hit rate if tracked\n\nRobot mode: JSON object with stats","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.398978560Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.408353431Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2gt","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.408310671Z","created_by":"ubuntu"}]}
{"id":"bd-2hia","title":"Implement key operation confirmations (set, clear, fill)","description":"# Implement key operation confirmations (set, clear, fill)\n\n## Purpose\nProvide clear, consistent confirmation messages for all key operations. Users should immediately know their command succeeded and what changed.\n\n## Target Outputs\n\n### key_set (sd set-key 5 icon.png)\n```\n  ✓ Key 5 set to icon.png\n```\n\n### key_cleared (sd clear-key 5)\n```\n  ✓ Key 5 cleared\n```\n\n### key_filled (sd fill-key 5 #FF0000)\n```\n  ✓ Key 5 filled with #FF0000\n```\n\n### all_cleared (sd clear-all)\n```\n  ✓ All 32 keys cleared\n```\n\n### all_filled (sd fill-all #0080FF)\n```\n  ✓ All 32 keys filled with #0080FF\n```\n\n## Implementation\n\n### key_set Method\n```rust\nfn key_set(&self, key: u8, image: &Path) {\n    let filename = image.file_name()\n        .map(|n| n.to_string_lossy().to_string())\n        .unwrap_or_else(|| image.display().to_string());\n    \n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" set to \", self.theme.label.clone());\n    text.append_styled(&filename, self.theme.value.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### key_cleared Method\n```rust\nfn key_cleared(&self, key: u8) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" cleared\", self.theme.label.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### key_filled Method\n```rust\nfn key_filled(&self, key: u8, color: &str) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{}\", key), self.theme.key_index.clone());\n    text.append_styled(\" filled with \", self.theme.label.clone());\n    \n    // Try to display color with actual color if valid hex\n    if let Some(parsed_color) = parse_hex_color(color) {\n        text.append_styled(color, Style::new().color(parsed_color));\n    } else {\n        text.append_styled(color, self.theme.value.clone());\n    }\n    \n    self.console.print_text(&text);\n}\n\n/// Parse hex color string to rich_rust Color\nfn parse_hex_color(hex: &str) -> Option<Color> {\n    Color::parse(hex).ok()\n}\n```\n\n### all_cleared Method\n```rust\nfn all_cleared(&self) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"All keys cleared\", self.theme.label.clone());\n    \n    self.console.print_text(&text);\n}\n```\n\n### all_filled Method  \n```rust\nfn all_filled(&self, color: &str) {\n    let mut text = Text::new(\"\");\n    text.append_styled(\"  ✓ \", Style::new().bold().color(self.theme.success.clone()));\n    text.append_styled(\"All keys filled with \", self.theme.label.clone());\n    \n    if let Some(parsed_color) = parse_hex_color(color) {\n        text.append_styled(color, Style::new().color(parsed_color));\n    } else {\n        text.append_styled(color, self.theme.value.clone());\n    }\n    \n    self.console.print_text(&text);\n}\n```\n\n## Design Decisions\n\n### Checkmark Icon (✓)\n- Universal success symbol\n- Green and bold for emphasis\n- Consistent with error (✗) and other indicators\n\n### Simple Line Format\n- No panel needed (these are quick confirmations)\n- Single line is sufficient for success\n- Errors get panels for more information\n\n### Key Index Highlighting\n- Amber color makes key number pop\n- Essential when setting multiple keys in sequence\n- Consistent with button events display\n\n### Color Preview\n- When filling with a color, show it in that color if possible\n- Adds visual confirmation that color was understood\n- Falls back to regular value styling if color parsing fails\n\n### Filename Display\n- Show just filename, not full path (cleaner)\n- Fall back to full path if filename extraction fails\n- Quoted or styled to distinguish from surrounding text\n\n## Multiple Key Operations\nWhen setting multiple keys (future batch operation), these can be called in sequence:\n```\n  ✓ Key 0 set to icon1.png\n  ✓ Key 1 set to icon2.png\n  ✓ Key 2 set to icon3.png\n```\n\n## Testing\n```rust\n#[test]\nfn key_set_shows_filename() {\n    let output = HumanOutput::new(test_console());\n    let path = Path::new(\"/path/to/icons/my_icon.png\");\n    \n    let captured = capture_output(|| output.key_set(5, path));\n    \n    assert!(captured.contains(\"✓\"));\n    assert!(captured.contains(\"Key 5\"));\n    assert!(captured.contains(\"my_icon.png\"));\n    assert!(!captured.contains(\"/path/to\")); // No full path\n}\n\n#[test]\nfn key_filled_with_valid_hex() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| output.key_filled(5, \"#FF0000\"));\n    \n    assert!(captured.contains(\"✓\"));\n    assert!(captured.contains(\"#FF0000\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] key_set shows checkmark, key number, and filename\n- [ ] key_cleared shows checkmark and key number\n- [ ] key_filled shows checkmark, key number, and color\n- [ ] all_cleared confirms all keys\n- [ ] all_filled confirms all keys with color\n- [ ] Key numbers are highlighted in amber\n- [ ] Hex colors display in their actual color when possible\n- [ ] Success checkmark is green and bold","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:47.681747536Z","created_by":"ubuntu","updated_at":"2026-01-19T21:07:47.729868599Z","compaction_level":0,"original_size":0,"labels":["confirmation","keys","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-2hia","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:07:47.729833272Z","created_by":"ubuntu"},{"issue_id":"bd-2hia","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:07:47.723598473Z","created_by":"ubuntu"}]}
{"id":"bd-2j9","title":"Implement error output with styled Error panel and suggestions","description":"# Implement error output with styled Error panel and suggestions\n\n## Purpose\nCreate a visually distinct, helpful error display that not only shows what went wrong but also provides actionable suggestions for recovery. Errors should be attention-grabbing but not alarming.\n\n## Target Output\n```\n╭──────────────────────── Error ────────────────────────╮\n│                                                       │\n│  ✗ No Stream Deck devices found                       │\n│                                                       │\n│  Suggestion:                                          │\n│  Ensure Stream Deck is connected via USB              │\n│                                                       │\n╰───────────────────────────────────────────────────────╯\n```\n\n## Multi-Device Error\n```\n╭──────────────────────── Error ────────────────────────╮\n│                                                       │\n│  ✗ Multiple Stream Deck devices found                 │\n│                                                       │\n│  Available devices:                                   │\n│    • AL12U1E1234                                      │\n│    • AL12U1E5678                                      │\n│                                                       │\n│  Suggestion:                                          │\n│  Use --serial to specify which device                 │\n│                                                       │\n╰───────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Enhanced error Method\n```rust\nfn error(&self, error: &SdError) {\n    let mut content = Text::new(\"\");\n    content.append(\"\\n\");\n    \n    // Error icon and message\n    content.append_styled(\"  ✗ \", Style::new().bold().color(self.theme.error.clone()));\n    content.append_styled(&error.to_string(), Style::new().bold());\n    content.append(\"\\n\");\n    \n    // Special handling for MultipleDevices error\n    if let SdError::MultipleDevices { serials } = error {\n        content.append(\"\\n\");\n        content.append_styled(\"  Available devices:\\n\", self.theme.label.clone());\n        for serial in serials {\n            content.append_styled(&format!(\"    • {}\\n\", serial), \n                self.theme.device_serial.clone());\n        }\n    }\n    \n    // Suggestion section\n    if let Some(suggestion) = error.suggestion() {\n        content.append(\"\\n\");\n        content.append_styled(\"  Suggestion:\\n\", self.theme.label.clone());\n        content.append_styled(&format!(\"  {}\\n\", suggestion), \n            self.theme.muted.clone());\n    }\n    \n    content.append(\"\\n\");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"Error\")\n        .border_style(Style::new().color(self.theme.error.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Red Border, Not Background\n- Red background can be overwhelming and hard to read\n- Red border draws attention without impairing readability\n- White/default text on terminal background stays readable\n\n### Error Icon (✗)\n- Unicode multiply sign is universally understood\n- Bold and colored for emphasis\n- Consistent with success checkmark (✓)\n\n### Suggestion Section\n- Separated visually from error message\n- Muted color indicates it's supplementary info\n- Actionable: tells user what to DO, not just what's wrong\n\n### Special Cases\n- MultipleDevices gets list of serials (actionable information)\n- Other errors can have custom handling added similarly\n- Pattern match on SdError variants for special formatting\n\n### Panel Title\n- Simple \"Error\" title (not the error type)\n- Error details are in the body\n- Keeps title short and scannable\n\n## Error Types and Their Display\n\n| Error | Display | Suggestion |\n|-------|---------|------------|\n| NoDevicesFound | \"No Stream Deck devices found\" | \"Ensure Stream Deck is connected via USB\" |\n| MultipleDevices | \"Multiple devices found\" + list | \"Use --serial to specify which device\" |\n| DeviceNotFound | \"Device 'XXX' not found\" | \"Check serial with 'sd list'\" |\n| InvalidKeyIndex | \"Invalid key 32\" | \"Use key index 0-31\" |\n| InvalidBrightness | \"Invalid brightness 150\" | \"Use value between 0 and 100\" |\n| ImageNotFound | \"Image file not found\" | \"Check path exists\" |\n\n## Testing\n```rust\n#[test]\nfn error_with_suggestion_displays_both() {\n    let output = HumanOutput::new(test_console());\n    let error = SdError::NoDevicesFound;\n    \n    // Capture output\n    output.error(&error);\n    \n    // Verify error message and suggestion both appear\n}\n\n#[test]\nfn multiple_devices_error_lists_serials() {\n    let output = HumanOutput::new(test_console());\n    let error = SdError::MultipleDevices { \n        serials: vec![\"AAA\".into(), \"BBB\".into()] \n    };\n    \n    output.error(&error);\n    \n    // Verify both serials appear in output\n}\n```\n\n## Acceptance Criteria\n- [ ] Error panel has red border\n- [ ] Error icon (✗) is bold and red\n- [ ] Error message is prominent\n- [ ] Suggestion appears when available\n- [ ] MultipleDevices lists all serial numbers\n- [ ] Panel uses rounded style\n- [ ] Readable on both light and dark terminals","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:06:24.185475508Z","created_by":"ubuntu","updated_at":"2026-01-19T21:06:24.245614287Z","compaction_level":0,"original_size":0,"labels":["error","phase-2","rich-rust","ux"],"dependencies":[{"issue_id":"bd-2j9","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:06:24.245580333Z","created_by":"ubuntu"},{"issue_id":"bd-2j9","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:06:24.240456306Z","created_by":"ubuntu"}]}
{"id":"bd-2js","title":"Implement GestureDetector struct","description":"## Purpose\nCreate the core gesture detection engine that recognizes tap, double-tap, long-press, and hold gestures from raw press/release events.\n\n## Implementation\n```rust\n// src/gestures.rs\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, info, warn, instrument, span, Level};\n\n/// Configuration for gesture timing thresholds\n#[derive(Debug, Clone)]\npub struct GestureConfig {\n    /// Time threshold for long-press detection (default: 800ms)\n    pub long_press_threshold: Duration,\n    /// Window for detecting double-tap (default: 300ms)\n    pub double_tap_window: Duration,\n    /// Interval between hold tick events (default: 100ms)\n    pub hold_tick_interval: Duration,\n}\n\nimpl Default for GestureConfig {\n    fn default() -> Self {\n        Self {\n            long_press_threshold: Duration::from_millis(800),\n            double_tap_window: Duration::from_millis(300),\n            hold_tick_interval: Duration::from_millis(100),\n        }\n    }\n}\n\n/// Raw button event from device\n#[derive(Debug, Clone)]\npub struct RawKeyEvent {\n    pub key: u8,\n    pub pressed: bool,\n    pub timestamp: Instant,\n}\n\n/// Detected gesture types\n#[derive(Debug, Clone)]\npub enum Gesture {\n    /// Quick press and release\n    Tap { key: u8 },\n    /// Two taps in quick succession\n    DoubleTap { key: u8, interval: Duration },\n    /// Press held past threshold then released\n    LongPress { key: u8, duration: Duration },\n    /// Key is being held - initial event\n    HoldStart { key: u8 },\n    /// Periodic tick while key is held\n    HoldTick { key: u8, held_for: Duration },\n    /// Key released after being held\n    HoldEnd { key: u8, total: Duration },\n}\n\nimpl Gesture {\n    pub fn key(&self) -> u8 {\n        match self {\n            Gesture::Tap { key } => *key,\n            Gesture::DoubleTap { key, .. } => *key,\n            Gesture::LongPress { key, .. } => *key,\n            Gesture::HoldStart { key } => *key,\n            Gesture::HoldTick { key, .. } => *key,\n            Gesture::HoldEnd { key, .. } => *key,\n        }\n    }\n    \n    pub fn gesture_type(&self) -> &'static str {\n        match self {\n            Gesture::Tap { .. } => \"tap\",\n            Gesture::DoubleTap { .. } => \"double_tap\",\n            Gesture::LongPress { .. } => \"long_press\",\n            Gesture::HoldStart { .. } => \"hold_start\",\n            Gesture::HoldTick { .. } => \"hold_tick\",\n            Gesture::HoldEnd { .. } => \"hold_end\",\n        }\n    }\n}\n\n/// Per-key state for gesture detection\n#[derive(Debug, Default)]\nstruct KeyGestureState {\n    /// When the current press started (None if released)\n    press_time: Option<Instant>,\n    /// When the last potential tap occurred (for double-tap detection)\n    pending_tap_time: Option<Instant>,\n    /// Whether we've transitioned to \"held\" state\n    is_held: bool,\n    /// Last time we emitted a hold tick\n    last_tick_time: Option<Instant>,\n}\n\n/// Main gesture detection engine\npub struct GestureDetector {\n    config: GestureConfig,\n    key_states: HashMap<u8, KeyGestureState>,\n}\n\nimpl GestureDetector {\n    pub fn new(config: GestureConfig) -> Self {\n        info!(\n            long_press_ms = %config.long_press_threshold.as_millis(),\n            double_tap_ms = %config.double_tap_window.as_millis(),\n            tick_interval_ms = %config.hold_tick_interval.as_millis(),\n            \"Gesture detector initialized\"\n        );\n        \n        Self {\n            config,\n            key_states: HashMap::new(),\n        }\n    }\n    \n    /// Process a raw key event and return any detected gestures\n    #[instrument(skip(self), fields(key = %event.key, pressed = %event.pressed))]\n    pub fn process_event(&mut self, event: &RawKeyEvent) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        let state = self.key_states.entry(event.key).or_default();\n        \n        if event.pressed {\n            // Key pressed\n            trace!(\"Key pressed, starting timing\");\n            state.press_time = Some(event.timestamp);\n            state.is_held = false;\n            state.last_tick_time = None;\n        } else {\n            // Key released\n            if let Some(press_time) = state.press_time.take() {\n                let duration = event.timestamp.duration_since(press_time);\n                \n                if state.is_held {\n                    // Was in hold state - emit hold end\n                    debug!(\n                        duration_ms = %duration.as_millis(),\n                        \"Hold ended\"\n                    );\n                    gestures.push(Gesture::HoldEnd {\n                        key: event.key,\n                        total: duration,\n                    });\n                } else if duration >= self.config.long_press_threshold {\n                    // Long press (pressed past threshold but not ticking as hold)\n                    debug!(\n                        duration_ms = %duration.as_millis(),\n                        \"Long press detected\"\n                    );\n                    gestures.push(Gesture::LongPress {\n                        key: event.key,\n                        duration,\n                    });\n                    // Clear pending tap since this was a long press\n                    state.pending_tap_time = None;\n                } else {\n                    // Short press - check for double-tap\n                    if let Some(pending_time) = state.pending_tap_time.take() {\n                        let interval = event.timestamp.duration_since(pending_time);\n                        if interval < self.config.double_tap_window {\n                            // Double tap!\n                            debug!(\n                                interval_ms = %interval.as_millis(),\n                                \"Double tap detected\"\n                            );\n                            gestures.push(Gesture::DoubleTap {\n                                key: event.key,\n                                interval,\n                            });\n                        } else {\n                            // Too slow for double-tap, emit the pending tap\n                            // and start new pending tap\n                            trace!(\"Pending tap expired, emitting tap\");\n                            gestures.push(Gesture::Tap { key: event.key });\n                            state.pending_tap_time = Some(event.timestamp);\n                        }\n                    } else {\n                        // First potential tap - defer emission\n                        trace!(\"Starting pending tap timer\");\n                        state.pending_tap_time = Some(event.timestamp);\n                    }\n                }\n                \n                state.is_held = false;\n            } else {\n                warn!(\"Release without matching press\");\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Called periodically to emit hold ticks and finalize deferred taps\n    #[instrument(skip(self), level = \"trace\")]\n    pub fn tick(&mut self, now: Instant) -> Vec<Gesture> {\n        let mut gestures = Vec::new();\n        \n        for (key, state) in &mut self.key_states {\n            // Handle held keys\n            if let Some(press_time) = state.press_time {\n                let held_for = now.duration_since(press_time);\n                \n                // Transition to held state\n                if !state.is_held && held_for >= self.config.long_press_threshold {\n                    state.is_held = true;\n                    debug!(key = %key, \"Hold started\");\n                    gestures.push(Gesture::HoldStart { key: *key });\n                }\n                \n                // Emit hold ticks\n                if state.is_held {\n                    let should_tick = state.last_tick_time\n                        .map(|t| now.duration_since(t) >= self.config.hold_tick_interval)\n                        .unwrap_or(true);\n                    \n                    if should_tick {\n                        trace!(key = %key, held_ms = %held_for.as_millis(), \"Hold tick\");\n                        gestures.push(Gesture::HoldTick { key: *key, held_for });\n                        state.last_tick_time = Some(now);\n                    }\n                }\n            }\n            \n            // Finalize pending taps after double-tap window expires\n            if let Some(pending_time) = state.pending_tap_time {\n                if state.press_time.is_none() && \n                   now.duration_since(pending_time) >= self.config.double_tap_window {\n                    trace!(key = %key, \"Pending tap finalized\");\n                    gestures.push(Gesture::Tap { key: *key });\n                    state.pending_tap_time = None;\n                }\n            }\n        }\n        \n        gestures\n    }\n    \n    /// Reset all state (e.g., on device reconnect)\n    pub fn reset(&mut self) {\n        info!(\"Gesture detector state reset\");\n        self.key_states.clear();\n    }\n    \n    /// Get current config\n    pub fn config(&self) -> &GestureConfig {\n        &self.config\n    }\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    fn make_event(key: u8, pressed: bool, offset_ms: u64) -> RawKeyEvent {\n        RawKeyEvent {\n            key,\n            pressed,\n            timestamp: Instant::now() + Duration::from_millis(offset_ms),\n        }\n    }\n    \n    #[test]\n    fn test_single_tap() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // Press\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: true,\n            timestamp: base,\n        });\n        assert!(gestures.is_empty());\n        \n        // Quick release (100ms)\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(100),\n        });\n        assert!(gestures.is_empty()); // Tap is deferred\n        \n        // Tick after double-tap window\n        let gestures = detector.tick(base + Duration::from_millis(400));\n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::Tap { key: 0 }));\n    }\n    \n    #[test]\n    fn test_double_tap() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // First tap\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        detector.process_event(&RawKeyEvent { key: 0, pressed: false, timestamp: base + Duration::from_millis(50) });\n        \n        // Second tap within window (200ms after first release)\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base + Duration::from_millis(150) });\n        let gestures = detector.process_event(&RawKeyEvent { key: 0, pressed: false, timestamp: base + Duration::from_millis(200) });\n        \n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::DoubleTap { key: 0, .. }));\n    }\n    \n    #[test]\n    fn test_long_press() {\n        let mut detector = GestureDetector::new(GestureConfig::default());\n        let base = Instant::now();\n        \n        // Press\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        \n        // Release after threshold (1 second)\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(1000),\n        });\n        \n        assert_eq!(gestures.len(), 1);\n        assert!(matches!(gestures[0], Gesture::LongPress { key: 0, .. }));\n    }\n    \n    #[test]\n    fn test_hold_with_ticks() {\n        let config = GestureConfig {\n            hold_tick_interval: Duration::from_millis(100),\n            ..Default::default()\n        };\n        let mut detector = GestureDetector::new(config);\n        let base = Instant::now();\n        \n        // Press\n        detector.process_event(&RawKeyEvent { key: 0, pressed: true, timestamp: base });\n        \n        // Tick after threshold - should get HoldStart\n        let gestures = detector.tick(base + Duration::from_millis(850));\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldStart { .. })));\n        \n        // Tick again - should get HoldTick\n        let gestures = detector.tick(base + Duration::from_millis(950));\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldTick { .. })));\n        \n        // Release - should get HoldEnd\n        let gestures = detector.process_event(&RawKeyEvent {\n            key: 0,\n            pressed: false,\n            timestamp: base + Duration::from_millis(1100),\n        });\n        assert!(gestures.iter().any(|g| matches!(g, Gesture::HoldEnd { .. })));\n    }\n}\n```\n\n## Success Criteria\n- [ ] GestureDetector correctly identifies tap gestures\n- [ ] Double-tap detected within configurable window\n- [ ] Long-press detected on release after threshold\n- [ ] Hold events emitted with periodic ticks\n- [ ] Multiple keys tracked independently\n- [ ] State reset works correctly\n\n## Logging Requirements\n- TRACE: Key pressed/released, pending tap timer start/finalize, hold tick\n- DEBUG: Double tap detected, long press detected, hold started/ended\n- INFO: Gesture detector initialized, state reset\n- WARN: Release without matching press (shouldn't happen)\n- ERROR: (none - errors bubble up)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.259522713Z","created_by":"ubuntu","updated_at":"2026-01-19T20:53:00.241917671Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2js","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.270731547Z","created_by":"ubuntu"}]}
{"id":"bd-2jze","title":"Future: Add progress bars for batch key operations","description":"# Future: Add progress bars for batch key operations\n\n## Purpose\nWhen setting multiple keys (future batch operation), display a progress bar showing upload progress. This provides visual feedback for longer operations.\n\n## Background\nSetting 32 keys on a Stream Deck XL can take several seconds. A progress bar would:\n- Show operation is progressing (not stuck)\n- Indicate estimated time remaining\n- Provide satisfying visual feedback\n\n## Potential Implementation\n```rust\n// In a future batch command\nfn cmd_set_keys_batch(cli: &Cli, args: &BatchArgs, output: &dyn Output) -> Result<(), SdError> {\n    let images = load_images(&args.images)?;\n    let total = images.len();\n    \n    output.progress_start(\"Setting keys\", total);\n    \n    for (i, (key, image)) in images.iter().enumerate() {\n        device::set_key_image(&device, *key, image)?;\n        output.progress_update(i + 1);\n    }\n    \n    output.progress_finish();\n    Ok(())\n}\n```\n\n## Output Trait Addition\n```rust\ntrait Output {\n    // ... existing methods ...\n    \n    fn progress_start(&self, task: &str, total: usize);\n    fn progress_update(&self, completed: usize);\n    fn progress_finish(&self);\n}\n```\n\n## Visual Design\n```\nSetting keys ████████████░░░░░░░░░░░░░░░░░░░░░░░░ 12/32  37%\n```\n\n## Deferred Until\n- Batch key operations are implemented\n- Use case is validated by real users\n\n## Acceptance Criteria (when implemented)\n- [ ] Progress bar shows during batch operations\n- [ ] Updates smoothly as keys are set\n- [ ] Shows count and percentage\n- [ ] Robot mode outputs JSON progress events","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-19T21:12:56.772695450Z","created_by":"ubuntu","updated_at":"2026-01-19T21:12:56.819350291Z","compaction_level":0,"original_size":0,"labels":["enhancement","future","progress","rich-rust"],"dependencies":[{"issue_id":"bd-2jze","depends_on_id":"bd-1z7d","type":"blocks","created_at":"2026-01-19T21:12:56.819318141Z","created_by":"ubuntu"},{"issue_id":"bd-2jze","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:12:56.813586650Z","created_by":"ubuntu"}]}
{"id":"bd-2ks","title":"Implement SessionState struct (shared with snapshots)","description":"Create src/state.rs (if not already from SAVE-RESTORE):\n- SessionState struct with brightness, keys HashMap\n- KeyState enum: Image(PathBuf), Color(String), Cleared\n- Thread-safe global accessor\n- Record methods for each mutation type\n\nNOTE: This is SHARED with SAVE-RESTORE epic. Coordinate implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.088169255Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:01.119119759Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ks","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.119070255Z","created_by":"ubuntu"}]}
{"id":"bd-2kw","title":"Add support for unsupported feature warnings","description":"Elgato profiles may contain unsupported features:\n- Folders (nested profiles)\n- Multi-actions (sequences)\n- System actions (specific to Elgato software)\n- Animated GIFs\n\nLog warnings for unsupported features, continue with supported parts.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:31.573276189Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.582720831Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2kw","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.582677830Z","created_by":"ubuntu"}]}
{"id":"bd-2ky","title":"Create test fixtures directory with sample data","description":"## Purpose\nProvide consistent, comprehensive test data for all test scenarios across the entire codebase.\n\n## Directory Structure\n```\ntests/fixtures/\n├── images/\n│   ├── valid/\n│   │   ├── exact-72x72.png       # Exact XL key size, no resize\n│   │   ├── exact-96x96.png       # Exact MK2 key size\n│   │   ├── large-256x256.png     # Needs downscale\n│   │   ├── large-1024x1024.png   # Very large, tests memory\n│   │   ├── small-50x50.png       # Needs upscale\n│   │   ├── nonsquare-100x80.png  # Non-square aspect\n│   │   ├── transparent.png       # With alpha channel\n│   │   ├── grayscale.png         # Grayscale image\n│   │   ├── high-quality.jpg      # JPEG with high quality\n│   │   ├── low-quality.jpg       # JPEG with artifacts\n│   │   └── webp-image.webp       # WebP format\n│   ├── invalid/\n│   │   ├── corrupted.png         # Invalid PNG header\n│   │   ├── truncated.png         # Incomplete file\n│   │   ├── empty.png             # Zero bytes\n│   │   ├── not-image.txt         # Text file with .png extension\n│   │   └── fake-header.bin       # Valid PNG header, invalid data\n│   ├── batch/\n│   │   ├── complete-32/          # Full XL layout (key-00.png to key-31.png)\n│   │   ├── complete-15/          # Full MK2 layout (key-00.png to key-14.png)\n│   │   ├── complete-6/           # Full Mini layout (key-00.png to key-05.png)\n│   │   ├── partial-10/           # Sparse (key-00, key-05, key-10, etc.)\n│   │   ├── gaps/                 # key-00, key-02, key-04 (odd numbers missing)\n│   │   ├── mixed-formats/        # key-00.png, key-01.jpg, key-02.webp\n│   │   └── custom-pattern/       # icon_00.png, icon_01.png (custom naming)\n│   └── colors/\n│       ├── red.png               # Solid #FF0000\n│       ├── green.png             # Solid #00FF00\n│       ├── blue.png              # Solid #0000FF\n│       ├── white.png             # Solid #FFFFFF\n│       └── black.png             # Solid #000000\n├── profiles/\n│   ├── valid/\n│   │   ├── minimal.streamDeckProfile      # manifest + 1 key\n│   │   ├── full-xl.streamDeckProfile      # 32 keys, all types\n│   │   ├── full-mk2.streamDeckProfile     # 15 keys\n│   │   ├── full-mini.streamDeckProfile    # 6 keys\n│   │   └── with-brightness.streamDeckProfile  # brightness setting\n│   ├── unsupported/\n│   │   ├── with-folders.streamDeckProfile     # Nested folders\n│   │   ├── with-multiaction.streamDeckProfile # Multi-actions\n│   │   ├── with-animation.streamDeckProfile   # Animated GIF\n│   │   └── with-system.streamDeckProfile      # System actions\n│   └── invalid/\n│       ├── corrupted-zip.streamDeckProfile\n│       ├── missing-manifest.streamDeckProfile\n│       ├── bad-json.streamDeckProfile\n│       └── missing-images.streamDeckProfile\n├── configs/\n│   ├── valid/\n│   │   ├── brightness-only.yaml   # Just brightness setting\n│   │   ├── single-key.yaml        # One key with image\n│   │   ├── full-layout.yaml       # All 32 keys defined\n│   │   ├── with-ranges.yaml       # Range selectors (0-7, 8-15)\n│   │   ├── with-rows.yaml         # Row selectors (row-0, row-1)\n│   │   ├── with-default.yaml      # Default fallback rule\n│   │   ├── with-colors.yaml       # Color fills\n│   │   ├── mixed-types.yaml       # Images, colors, cleared\n│   │   ├── with-patterns.yaml     # Pattern expansions\n│   │   ├── device-filter.yaml     # Device-specific config\n│   │   └── equivalent.toml        # TOML version of valid config\n│   └── invalid/\n│       ├── syntax-error.yaml      # YAML parse error\n│       ├── missing-image.yaml     # References non-existent file\n│       ├── out-of-range.yaml      # Key index > 31\n│       ├── invalid-color.yaml     # Bad color format\n│       └── missing-required.yaml  # Missing required field\n├── keymaps/\n│   ├── basic.yaml                 # Simple echo hooks\n│   ├── all-keys.yaml              # Hook for every key\n│   ├── ranges.yaml                # Range patterns\n│   ├── gestures.yaml              # Gesture-specific hooks\n│   ├── press-release.yaml         # Separate press/release\n│   ├── with-timeout.yaml          # Commands that timeout\n│   └── invalid.yaml               # Parse error\n├── snapshots/\n│   ├── work-layout.json           # Sample saved snapshot\n│   ├── gaming-layout.json         # Another snapshot\n│   └── with-cached-images/        # Snapshot with image cache\n└── scripts/\n    ├── generate-images.py         # Script to regenerate fixtures\n    └── validate-fixtures.sh       # Verify all fixtures valid\n```\n\n## Image Generation Script (scripts/generate-images.py)\n```python\nfrom PIL import Image\n\n# Generate solid color images\ncolors = {\n    'red': (255, 0, 0),\n    'green': (0, 255, 0),\n    'blue': (0, 0, 255),\n    'white': (255, 255, 255),\n    'black': (0, 0, 0),\n}\n\nfor name, color in colors.items():\n    img = Image.new('RGB', (72, 72), color)\n    img.save(f'tests/fixtures/images/colors/{name}.png')\n\n# Generate batch images with key numbers\nfor i in range(32):\n    img = Image.new('RGB', (72, 72), (50, 50, 50))\n    # Add text overlay with key number\n    # ... (use ImageDraw)\n    img.save(f'tests/fixtures/images/batch/complete-32/key-{i:02d}.png')\n```\n\n## Validation Script (scripts/validate-fixtures.sh)\n```bash\n#!/bin/bash\n# Verify all fixtures are valid and present\n\n# Check images\nfor img in tests/fixtures/images/valid/*.png; do\n    file \"$img\" | grep -q \"PNG image\" || echo \"Invalid: $img\"\ndone\n\n# Check configs parse\nfor cfg in tests/fixtures/configs/valid/*.yaml; do\n    python -c \"import yaml; yaml.safe_load(open('$cfg'))\" || echo \"Invalid: $cfg\"\ndone\n\necho \"Fixture validation complete\"\n```\n\n## Success Criteria\n- [ ] All fixture files created and valid\n- [ ] Images cover all sizes, formats, and edge cases\n- [ ] Profile files are valid Elgato format (verified with tool)\n- [ ] Config files cover all schema features\n- [ ] Keymap files cover all hook scenarios\n- [ ] Generation script can recreate fixtures\n- [ ] Validation script passes\n- [ ] README.md documents each fixture purpose\n- [ ] Files are version controlled in git\n- [ ] No binary files larger than 100KB","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:36:50.449140586Z","created_by":"ubuntu","updated_at":"2026-01-21T10:32:42.416478768Z","closed_at":"2026-01-21T10:32:42.416414738Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ky","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:50.459934398Z","created_by":"ubuntu"}]}
{"id":"bd-2lfp","title":"Implement NO_COLOR and TTY environment tests","description":"# Implement NO_COLOR, TTY, and environment variable tests\n\n## Purpose\nVerify that the output system correctly respects environment variables, CLI flags, and terminal detection. This ensures the CLI works correctly in CI pipelines, scripts, accessibility scenarios, and various terminal configurations.\n\n## Background\n\n### NO_COLOR Standard (https://no-color.org/)\nThe NO_COLOR environment variable is a cross-tool convention for disabling colored output. When set (to ANY value, including empty string), programs should not emit ANSI color codes.\n\n### FORCE_COLOR\nOverrides auto-detection:\n- FORCE_COLOR=0: Disable colors  \n- FORCE_COLOR=1: Force standard colors (16)\n- FORCE_COLOR=2: Force 256 colors\n- FORCE_COLOR=3: Force truecolor (24-bit)\n\n### SD_FORMAT Environment Variable\nThe CLI supports SD_FORMAT env var as alternative to --format flag:\n- SD_FORMAT=json: Equivalent to --format=json\n- SD_FORMAT=json-compact: Equivalent to --format=json-compact\n- SD_FORMAT=text: Equivalent to --format=text (default)\n\n### --no-color CLI Flag\nThe CLI has a --no-color flag that should behave identically to NO_COLOR=1\n\n### TTY Detection\nWhen stdout is not a terminal (piped to file, another process), colors should be disabled by default unless FORCE_COLOR is set.\n\n## Test Implementation\n\n### Test Module (tests/unit/environment.rs)\nuse sd::output::{OutputMode, HumanOutput, RobotOutput, Output};\nuse sd::cli::Cli;\nuse rich_rust::prelude::*;\nuse crate::common::*;\nuse tracing::{info, debug, instrument};\n\nfn setup() {\n    init_test_logging();\n}\n\n// === NO_COLOR Environment Variable Tests ===\n\n#[test]\n#[instrument]\nfn no_color_disables_ansi() {\n    setup();\n    info!(\"Testing NO_COLOR=1 disables ANSI\");\n    \n    with_no_color(|| {\n        let console = Console::new();\n        \n        assert!(!console.is_color_enabled(), \n            \"NO_COLOR should disable colors\");\n    });\n    \n    info!(\"✓ NO_COLOR=1 disables color\");\n}\n\n#[test]\n#[instrument]\nfn no_color_empty_string_still_disables() {\n    setup();\n    info!(\"Testing NO_COLOR= (empty) disables ANSI\");\n    \n    // NO_COLOR= (empty value) should STILL disable colors per spec\n    let _guard = EnvGuard::set(\"NO_COLOR\", \"\");\n    \n    let console = Console::new();\n    assert!(!console.is_color_enabled(),\n        \"NO_COLOR with empty value should still disable colors\");\n    \n    info!(\"✓ NO_COLOR= disables color\");\n}\n\n#[test]\n#[instrument]\nfn no_color_output_has_no_ansi() {\n    setup();\n    info!(\"Testing output with NO_COLOR has no ANSI codes\");\n    \n    with_no_color(|| {\n        let console = Console::builder()\n            .force_terminal(true)  // Force terminal mode for testing\n            .build();\n        \n        console.begin_capture();\n        let output = HumanOutput::new(console.clone());\n        output.success(\"Test message\");\n        output.device_list(&[mock_device_xl()]);\n        output.error(&SdError::NoDevicesFound);\n        let captured = console.end_capture();\n        \n        debug!(output = %captured, \"Output with NO_COLOR\");\n        \n        assert_no_ansi(&captured);\n    });\n    \n    info!(\"✓ NO_COLOR output has no ANSI\");\n}\n\n// === FORCE_COLOR Environment Variable Tests ===\n\n#[test]\n#[instrument]\nfn force_color_0_disables() {\n    setup();\n    info!(\"Testing FORCE_COLOR=0 disables colors\");\n    \n    with_force_color(0, || {\n        let console = Console::new();\n        assert!(!console.is_color_enabled(),\n            \"FORCE_COLOR=0 should disable colors\");\n    });\n    \n    info!(\"✓ FORCE_COLOR=0 disables color\");\n}\n\n#[test]\n#[instrument]\nfn force_color_1_enables_standard() {\n    setup();\n    info!(\"Testing FORCE_COLOR=1 enables standard colors\");\n    \n    with_force_color(1, || {\n        let console = Console::new();\n        assert!(console.is_color_enabled(),\n            \"FORCE_COLOR=1 should enable colors\");\n        \n        // Standard means 16-color (4-bit)\n        if let Some(system) = console.color_system() {\n            debug!(?system, \"Color system\");\n        }\n    });\n    \n    info!(\"✓ FORCE_COLOR=1 enables color\");\n}\n\n#[test]\n#[instrument]\nfn force_color_3_enables_truecolor() {\n    setup();\n    info!(\"Testing FORCE_COLOR=3 enables truecolor\");\n    \n    with_force_color(3, || {\n        let console = Console::new();\n        assert!(console.is_color_enabled(),\n            \"FORCE_COLOR=3 should enable colors\");\n        \n        assert_eq!(console.color_system(), Some(ColorSystem::TrueColor),\n            \"FORCE_COLOR=3 should enable TrueColor\");\n    });\n    \n    info!(\"✓ FORCE_COLOR=3 enables truecolor\");\n}\n\n#[test]\n#[instrument]\nfn force_color_overrides_no_color() {\n    setup();\n    info!(\"Testing FORCE_COLOR takes precedence over NO_COLOR\");\n    \n    // FORCE_COLOR should override NO_COLOR\n    let _guard1 = EnvGuard::set(\"NO_COLOR\", \"1\");\n    let _guard2 = EnvGuard::set(\"FORCE_COLOR\", \"1\");\n    \n    let console = Console::new();\n    \n    // FORCE_COLOR should win\n    assert!(console.is_color_enabled(),\n        \"FORCE_COLOR should override NO_COLOR\");\n    \n    info!(\"✓ FORCE_COLOR overrides NO_COLOR\");\n}\n\n// === --no-color CLI Flag Tests ===\n\n#[test]\n#[instrument]\nfn cli_no_color_flag_disables() {\n    setup();\n    info!(\"Testing --no-color CLI flag\");\n    \n    // Simulate CLI with --no-color\n    let cli = Cli::parse_from(&[\"sd\", \"--no-color\", \"list\"]);\n    \n    assert!(cli.no_color, \"--no-color flag should be set\");\n    \n    // OutputMode should respect the flag\n    let mode = OutputMode::from_cli(&cli);\n    \n    match mode {\n        OutputMode::Human(console) => {\n            // Console should have safe_box or no color\n            debug!(\"Human mode with --no-color\");\n        }\n        OutputMode::Robot(_) => {\n            panic!(\"--no-color alone should not trigger robot mode\");\n        }\n    }\n    \n    info!(\"✓ --no-color flag works\");\n}\n\n#[test]\n#[instrument]\nfn cli_no_color_produces_no_ansi() {\n    setup();\n    info!(\"Testing --no-color produces no ANSI in output\");\n    \n    let console = Console::builder()\n        .force_terminal(true)\n        .safe_box(true)  // Simulates --no-color effect\n        .no_color(true)\n        .build();\n    \n    console.begin_capture();\n    let output = HumanOutput::new(console.clone());\n    output.success(\"Test message\");\n    let captured = console.end_capture();\n    \n    assert_no_ansi(&captured);\n    \n    // Should use ASCII box characters if panels are shown\n    if captured.contains('+') || captured.contains('-') {\n        debug!(\"Using ASCII box characters\");\n    }\n    \n    info!(\"✓ --no-color produces no ANSI\");\n}\n\n// === SD_FORMAT Environment Variable Tests ===\n\n#[test]\n#[instrument]\nfn sd_format_json_enables_robot_mode() {\n    setup();\n    info!(\"Testing SD_FORMAT=json enables robot mode\");\n    \n    with_sd_format(\"json\", || {\n        let cli = Cli::parse_from(&[\"sd\", \"list\"]);\n        \n        assert!(cli.use_json(), \n            \"SD_FORMAT=json should enable JSON output\");\n    });\n    \n    info!(\"✓ SD_FORMAT=json works\");\n}\n\n#[test]\n#[instrument]\nfn sd_format_json_compact() {\n    setup();\n    info!(\"Testing SD_FORMAT=json-compact\");\n    \n    with_sd_format(\"json-compact\", || {\n        let cli = Cli::parse_from(&[\"sd\", \"list\"]);\n        \n        assert!(cli.use_json(), \"Should enable JSON\");\n        assert!(cli.use_compact_json(), \"Should be compact\");\n    });\n    \n    info!(\"✓ SD_FORMAT=json-compact works\");\n}\n\n#[test]\n#[instrument]\nfn sd_format_flag_overrides_env() {\n    setup();\n    info!(\"Testing --format flag overrides SD_FORMAT\");\n    \n    with_sd_format(\"json\", || {\n        // Explicit flag should override env\n        let cli = Cli::parse_from(&[\"sd\", \"--format=text\", \"list\"]);\n        \n        assert!(!cli.use_json(),\n            \"--format=text should override SD_FORMAT=json\");\n    });\n    \n    info!(\"✓ --format overrides SD_FORMAT\");\n}\n\n// === TTY Detection Tests ===\n\n#[test]\n#[instrument]\nfn non_tty_defaults_no_color() {\n    setup();\n    info!(\"Testing non-TTY defaults to no color\");\n    \n    // Simulate non-TTY by not forcing terminal\n    let console = Console::builder()\n        .force_terminal(false)  // Not a terminal\n        .build();\n    \n    // Without terminal, colors should be disabled by default\n    assert!(!console.is_terminal(), \"Should not be terminal\");\n    \n    // Color state depends on FORCE_COLOR\n    debug!(color_enabled = console.is_color_enabled(), \"Color state\");\n    \n    info!(\"✓ Non-TTY detection works\");\n}\n\n#[test]\n#[instrument]\nfn force_color_overrides_non_tty() {\n    setup();\n    info!(\"Testing FORCE_COLOR overrides non-TTY\");\n    \n    with_force_color(3, || {\n        let console = Console::builder()\n            .force_terminal(false)  // Not a terminal\n            .build();\n        \n        // FORCE_COLOR should enable colors even without terminal\n        assert!(console.is_color_enabled(),\n            \"FORCE_COLOR should enable colors even without TTY\");\n    });\n    \n    info!(\"✓ FORCE_COLOR overrides non-TTY\");\n}\n\n// === Robot Mode Ignores Color Settings Tests ===\n\n#[test]\n#[instrument]\nfn robot_mode_ignores_force_color() {\n    setup();\n    info!(\"Testing robot mode ignores FORCE_COLOR\");\n    \n    with_force_color(3, || {\n        let cli = Cli::parse_from(&[\"sd\", \"--robot\", \"list\"]);\n        let mode = OutputMode::from_cli(&cli);\n        let output = mode.as_output();\n        \n        let captured = capture_stdout(|| {\n            output.device_list(&[mock_device_xl()]);\n        });\n        \n        // Robot mode should NEVER have ANSI codes\n        assert_no_ansi(&captured);\n        \n        // Should be valid JSON\n        let _: serde_json::Value = serde_json::from_str(&captured)\n            .expect(\"Robot mode should output JSON regardless of FORCE_COLOR\");\n    });\n    \n    info!(\"✓ Robot mode ignores FORCE_COLOR\");\n}\n\n#[test]\n#[instrument]\nfn robot_mode_ignores_no_color() {\n    setup();\n    info!(\"Testing robot mode works with NO_COLOR\");\n    \n    with_no_color(|| {\n        let cli = Cli::parse_from(&[\"sd\", \"--robot\", \"list\"]);\n        let mode = OutputMode::from_cli(&cli);\n        let output = mode.as_output();\n        \n        let captured = capture_stdout(|| {\n            output.device_list(&[mock_device_xl()]);\n        });\n        \n        // Should still be valid JSON\n        let _: serde_json::Value = serde_json::from_str(&captured)\n            .expect(\"Robot mode should work with NO_COLOR\");\n    });\n    \n    info!(\"✓ Robot mode works with NO_COLOR\");\n}\n\n// === Safe Box ASCII Fallback Test ===\n\n#[test]\n#[instrument]\nfn safe_box_uses_ascii() {\n    setup();\n    info!(\"Testing safe_box uses ASCII box characters\");\n    \n    let console = Console::builder()\n        .force_terminal(true)\n        .safe_box(true)  // Force ASCII box characters\n        .build();\n    \n    console.begin_capture();\n    let output = HumanOutput::new(console.clone());\n    output.device_list(&[mock_device_xl()]);\n    let captured = console.end_capture();\n    \n    debug!(output = %captured, \"Safe box output\");\n    \n    // Should use ASCII box characters\n    assert_has_ascii_box(&captured);\n    \n    info!(\"✓ Safe box uses ASCII\");\n}\n\n// === SD_SERIAL Environment Variable Test ===\n\n#[test]\n#[instrument]\nfn sd_serial_env_sets_serial() {\n    setup();\n    info!(\"Testing SD_SERIAL environment variable\");\n    \n    let _guard = EnvGuard::set(\"SD_SERIAL\", \"TEST123\");\n    \n    let cli = Cli::parse_from(&[\"sd\", \"info\"]);\n    \n    assert_eq!(cli.serial.as_deref(), Some(\"TEST123\"),\n        \"SD_SERIAL should set serial option\");\n    \n    info!(\"✓ SD_SERIAL works\");\n}\n\n// === Combined Environment Tests ===\n\n#[test]\n#[instrument]\nfn combined_env_vars() {\n    setup();\n    info!(\"Testing combined environment variables\");\n    \n    // Set multiple env vars\n    let _g1 = EnvGuard::set(\"SD_FORMAT\", \"json\");\n    let _g2 = EnvGuard::set(\"SD_SERIAL\", \"MYDEVICE\");\n    let _g3 = EnvGuard::set(\"NO_COLOR\", \"1\");  // Should be ignored for JSON\n    \n    let cli = Cli::parse_from(&[\"sd\", \"list\"]);\n    \n    assert!(cli.use_json(), \"SD_FORMAT=json should work\");\n    assert_eq!(cli.serial.as_deref(), Some(\"MYDEVICE\"), \n        \"SD_SERIAL should work\");\n    \n    info!(\"✓ Combined env vars work\");\n}\n\n## Acceptance Criteria\n- [ ] NO_COLOR disables all color output\n- [ ] NO_COLOR= (empty string) also disables colors\n- [ ] FORCE_COLOR overrides auto-detection  \n- [ ] FORCE_COLOR overrides NO_COLOR\n- [ ] --no-color CLI flag works\n- [ ] SD_FORMAT=json enables robot mode\n- [ ] SD_FORMAT=json-compact enables compact mode\n- [ ] --format flag overrides SD_FORMAT env\n- [ ] SD_SERIAL env sets serial option\n- [ ] Robot mode ignores color environment variables\n- [ ] Non-TTY output defaults to no colors\n- [ ] safe_box option uses ASCII characters\n- [ ] All tests include tracing instrumentation\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:11:31.233218699Z","created_by":"ubuntu","updated_at":"2026-01-19T21:38:22.319269026Z","compaction_level":0,"original_size":0,"labels":["environment","no-color","phase-4","rich-rust","testing"],"dependencies":[{"issue_id":"bd-2lfp","depends_on_id":"bd-1gx6","type":"blocks","created_at":"2026-01-19T21:22:55.913746769Z","created_by":"ubuntu"},{"issue_id":"bd-2lfp","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:11:31.290231473Z","created_by":"ubuntu"},{"issue_id":"bd-2lfp","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:11:31.284483891Z","created_by":"ubuntu"},{"issue_id":"bd-2lfp","depends_on_id":"bd-usa2","type":"blocks","created_at":"2026-01-19T21:38:22.319224612Z","created_by":"ubuntu"}]}
{"id":"bd-2mvm","title":"Refactor main.rs entry point to use OutputMode","description":"# Refactor main.rs entry point to use OutputMode\n\n## Purpose\nTransform main.rs to use the new output abstraction. The entry point creates the appropriate OutputMode based on CLI flags and passes it to command handlers.\n\n## Current State (Simplified)\n```rust\nfn main() {\n    let cli = Cli::parse();\n    \n    if let Err(e) = run(&cli) {\n        if cli.use_json() {\n            println!(\"{}\", serde_json::json!({\n                \"error\": true,\n                \"message\": e.to_string(),\n            }));\n        } else {\n            eprintln!(\"Error: {}\", e);\n        }\n        std::process::exit(1);\n    }\n}\n\nfn run(cli: &Cli) -> Result<(), SdError> {\n    match &cli.command {\n        Some(Commands::List(args)) => cmd_list(cli, args),\n        // ...\n    }\n}\n```\n\n## Target State\n```rust\nuse crate::output::{OutputMode, Output};\n\nfn main() {\n    let cli = Cli::parse();\n    \n    // Create appropriate output handler based on CLI flags\n    let output_mode = OutputMode::from_cli(&cli);\n    let output = output_mode.as_output();\n    \n    // Run with output abstraction\n    if let Err(e) = run(&cli, output.as_ref()) {\n        output.error(&e);\n        std::process::exit(1);\n    }\n}\n\nfn run(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    match &cli.command {\n        Some(Commands::List(args)) => cmd_list(cli, args, output),\n        Some(Commands::Info) => cmd_info(cli, output),\n        Some(Commands::Brightness(args)) => cmd_brightness(cli, args, output),\n        Some(Commands::SetKey(args)) => cmd_set_key(cli, args, output),\n        Some(Commands::ClearKey(args)) => cmd_clear_key(cli, args, output),\n        Some(Commands::ClearAll) => cmd_clear_all(cli, output),\n        Some(Commands::FillKey(args)) => cmd_fill_key(cli, args, output),\n        Some(Commands::FillAll(args)) => cmd_fill_all(cli, args, output),\n        Some(Commands::Watch(args)) => cmd_watch(cli, args, output),\n        Some(Commands::Read) => cmd_read(cli, output),\n        Some(Commands::Version) => cmd_version(output),\n        Some(Commands::Completions(args)) => cmd_completions(args),\n        None => cmd_default(output),\n    }\n}\n```\n\n## Implementation Steps\n\n### Step 1: Add Output Module Import\n```rust\nmod output;\n\nuse output::{OutputMode, Output};\n```\n\n### Step 2: Update main() Function\n```rust\nfn main() {\n    let cli = Cli::parse();\n    \n    // Set up color output handling\n    // (rich_rust Console handles this automatically)\n    \n    let output_mode = OutputMode::from_cli(&cli);\n    let output = output_mode.as_output();\n    \n    if let Err(e) = run(&cli, output.as_ref()) {\n        output.error(&e);\n        std::process::exit(1);\n    }\n}\n```\n\n### Step 3: Update run() Signature\n```rust\nfn run(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    // Command dispatch with output parameter\n}\n```\n\n### Step 4: Update Each Command Function\nEvery command function signature changes to accept output:\n```rust\n// Before\nfn cmd_list(cli: &Cli, args: &ListArgs) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    if cli.use_json() {\n        println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n    } else {\n        for device in &devices {\n            println!(\"{}\", device.serial);\n        }\n    }\n    Ok(())\n}\n\n// After\nfn cmd_list(cli: &Cli, args: &ListArgs, output: &dyn Output) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    output.device_list(&devices);\n    Ok(())\n}\n```\n\n### Step 5: Handle Default Command (no subcommand)\n```rust\nfn cmd_default(output: &dyn Output) -> Result<(), SdError> {\n    // Show quick-start info in human mode\n    // Show agent discovery info in robot mode\n    output.info(\"Run 'sd --help' for usage information\");\n    Ok(())\n}\n```\n\n## Design Decisions\n\n### Box<dyn Output> vs enum dispatch\n- Using trait object (dyn Output) for flexibility\n- enum dispatch would be faster but less extensible\n- Performance difference is negligible for CLI output\n\n### Error Handling Flow\n- Errors bubble up via Result\n- main() calls output.error() for final display\n- Consistent error formatting regardless of where error occurred\n\n### Completions Command Exception\n- Shell completions are pure text (generated by clap)\n- No output styling needed/wanted\n- Keeps original implementation\n\n## Verification\n```bash\n# Robot mode regression\nsd list --robot | diff - expected_list.json\nsd info --robot | diff - expected_info.json\n\n# Human mode visual check\nsd list  # Should show styled panel\nsd info  # Should show styled table with key layout\n```\n\n## Acceptance Criteria\n- [ ] OutputMode created from CLI flags\n- [ ] run() accepts &dyn Output parameter\n- [ ] All command functions updated\n- [ ] Error handling uses output.error()\n- [ ] No direct println! for user-facing output (except completions)\n- [ ] Robot mode behavior unchanged\n- [ ] Human mode shows styled output","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:08:56.747819442Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:56.801313731Z","compaction_level":0,"original_size":0,"labels":["main","phase-3","refactor","rich-rust"],"dependencies":[{"issue_id":"bd-2mvm","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:08:56.792270123Z","created_by":"ubuntu"},{"issue_id":"bd-2mvm","depends_on_id":"bd-1xd","type":"blocks","created_at":"2026-01-19T21:08:56.796791456Z","created_by":"ubuntu"},{"issue_id":"bd-2mvm","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:08:56.801287411Z","created_by":"ubuntu"}]}
{"id":"bd-2oj","title":"Add text-key command","description":"Implement sd text-key:\n```\nsd text-key 0 \"Build\" --font-size 24 --bg-color \"#333\"\n```\n\nGenerates image from text and applies to key.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:16.314684264Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:16.326125375Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2oj","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:16.326055764Z","created_by":"ubuntu"}]}
{"id":"bd-2qo","title":"Design snapshot storage schema","description":"## Purpose\nDesign comprehensive storage schema for snapshots, combining SQLite metadata with file-based image caching.\n\n## Directory Structure\n```\n~/.local/share/sd/\n├── snapshots/\n│   ├── snapshots.db           # SQLite database\n│   └── images/                # Content-addressable image cache\n│       ├── aa/\n│       │   └── aabbcc...123.webp\n│       ├── bb/\n│       │   └── bbccdd...456.webp\n│       └── ...\n```\n\n## SQLite Schema\n```sql\n-- snapshots.db\n\n-- Snapshot metadata\nCREATE TABLE snapshots (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE,\n    description TEXT,\n    device_model TEXT NOT NULL,      -- \"StreamDeckXL\", \"StreamDeckMK2\", etc.\n    device_serial TEXT,              -- Optional: bind to specific device\n    key_count INTEGER NOT NULL,      -- Device key count at snapshot time\n    key_width INTEGER NOT NULL,      -- Image dimensions expected\n    key_height INTEGER NOT NULL,\n    brightness INTEGER,              -- 0-100 or NULL if not captured\n    created_at TEXT NOT NULL,        -- ISO 8601 timestamp\n    updated_at TEXT NOT NULL,        -- ISO 8601 timestamp\n    version INTEGER DEFAULT 1        -- Schema version for future migration\n);\n\n-- Per-key state within snapshot\nCREATE TABLE snapshot_keys (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    snapshot_id INTEGER NOT NULL REFERENCES snapshots(id) ON DELETE CASCADE,\n    key_index INTEGER NOT NULL,      -- 0-based key number\n    state_type TEXT NOT NULL,        -- 'image', 'color', 'clear'\n    \n    -- For 'image' type\n    source_path TEXT,                -- Original source path (for reference)\n    image_hash TEXT,                 -- SHA256 of processed image content\n    \n    -- For 'color' type  \n    color_hex TEXT,                  -- \"#RRGGBB\" format\n    \n    created_at TEXT NOT NULL,\n    \n    UNIQUE(snapshot_id, key_index)\n);\n\n-- Image cache metadata\nCREATE TABLE images (\n    hash TEXT PRIMARY KEY,           -- SHA256 hash (content-addressable)\n    original_path TEXT,              -- First source path seen\n    width INTEGER NOT NULL,\n    height INTEGER NOT NULL,\n    format TEXT NOT NULL,            -- \"webp\", \"png\", etc.\n    size_bytes INTEGER NOT NULL,\n    created_at TEXT NOT NULL,\n    last_accessed_at TEXT NOT NULL,\n    access_count INTEGER DEFAULT 1\n);\n\n-- Indexes for performance\nCREATE INDEX idx_snapshot_keys_snapshot ON snapshot_keys(snapshot_id);\nCREATE INDEX idx_snapshot_keys_hash ON snapshot_keys(image_hash);\nCREATE INDEX idx_images_accessed ON images(last_accessed_at);\n```\n\n## File Storage\nImages stored using content-addressable pattern:\n```rust\n/// Generate storage path for image hash\nfn image_path(hash: &str) -> PathBuf {\n    // First 2 chars as subdirectory for distribution\n    let dir = &hash[0..2];\n    PathBuf::from(format!(\"images/{}/{}.webp\", dir, hash))\n}\n```\n\n## Rust Structs\n```rust\n// src/snapshot/schema.rs\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Snapshot {\n    pub id: i64,\n    pub name: String,\n    pub description: Option<String>,\n    pub device_model: String,\n    pub device_serial: Option<String>,\n    pub key_count: u8,\n    pub key_width: u32,\n    pub key_height: u32,\n    pub brightness: Option<u8>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub keys: Vec<SnapshotKey>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SnapshotKey {\n    pub key_index: u8,\n    pub state: KeyState,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum KeyState {\n    Image {\n        source_path: Option<String>,\n        image_hash: String,\n    },\n    Color {\n        hex: String,\n    },\n    Clear,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CachedImage {\n    pub hash: String,\n    pub original_path: Option<String>,\n    pub width: u32,\n    pub height: u32,\n    pub format: String,\n    pub size_bytes: u64,\n}\n```\n\n## Database Access Layer\n```rust\n// src/snapshot/db.rs\nuse rusqlite::{Connection, params};\nuse tracing::{debug, info, instrument};\n\npub struct SnapshotDb {\n    conn: Connection,\n}\n\nimpl SnapshotDb {\n    #[instrument(skip_all)]\n    pub fn open() -> Result<Self> {\n        let path = dirs::data_local_dir()\n            .ok_or_else(|| anyhow::anyhow!(\"No local data directory\"))?\n            .join(\"sd/snapshots/snapshots.db\");\n        \n        std::fs::create_dir_all(path.parent().unwrap())?;\n        \n        let conn = Connection::open(&path)?;\n        let db = Self { conn };\n        db.migrate()?;\n        Ok(db)\n    }\n    \n    fn migrate(&self) -> Result<()> {\n        self.conn.execute_batch(include_str!(\"schema.sql\"))?;\n        Ok(())\n    }\n    \n    #[instrument(skip(self))]\n    pub fn save_snapshot(&self, snapshot: &Snapshot) -> Result<i64> {\n        // Insert or update snapshot...\n    }\n    \n    #[instrument(skip(self))]\n    pub fn load_snapshot(&self, name: &str) -> Result<Option<Snapshot>> {\n        // Load snapshot with all keys...\n    }\n    \n    #[instrument(skip(self))]\n    pub fn list_snapshots(&self) -> Result<Vec<SnapshotSummary>> {\n        // Return list of snapshots without full key data...\n    }\n    \n    #[instrument(skip(self))]\n    pub fn delete_snapshot(&self, name: &str) -> Result<bool> {\n        // Delete snapshot and orphaned images...\n    }\n}\n```\n\n## Robot Mode Output\n```json\n{\n  \"command\": \"save\",\n  \"snapshot\": {\n    \"name\": \"work-layout\",\n    \"device_model\": \"StreamDeckXL\",\n    \"key_count\": 32,\n    \"brightness\": 80,\n    \"keys_saved\": 24,\n    \"images_cached\": 18,\n    \"cache_size_bytes\": 156789\n  }\n}\n```\n\n## Logging Requirements\n- TRACE: Individual key save/load operations\n- DEBUG: SQL queries, file I/O operations\n- INFO: Snapshot save/load/delete with summary\n- WARN: Missing source images (use cached)\n- ERROR: Database errors, I/O failures\n\n## Success Criteria\n- [ ] SQLite schema handles all key types\n- [ ] Content-addressable image storage works\n- [ ] Snapshots can be saved and restored correctly\n- [ ] Device compatibility checked on restore\n- [ ] Orphaned images cleaned up on delete\n- [ ] Robot mode provides structured output","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:04.945524164Z","created_by":"ubuntu","updated_at":"2026-01-21T11:18:19.788994646Z","closed_at":"2026-01-21T11:18:19.788937979Z","close_reason":"Implemented snapshot storage schema: SQLite schema in src/snapshot/db.rs, Rust structs (Snapshot, SnapshotKey, KeyState, CachedImage, SnapshotSummary) in src/snapshot/schema.rs, database access layer with CRUD operations, content-addressable image caching, and comprehensive tests (12 new tests passing).","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qo","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:04.973777821Z","created_by":"ubuntu"}]}
{"id":"bd-2re","title":"Write tests for snapshot system","description":"## Test Coverage for Device State Snapshots\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **Snapshot Serialization Tests**\n   - Snapshot serializes to valid JSON\n   - Snapshot deserializes correctly\n   - Handles all key states: image, color, cleared\n   - Preserves brightness value\n   - Includes device metadata (model, serial)\n\n2. **State Tracking Tests**\n   - set-key records image path\n   - fill-key records color value\n   - clear-key records cleared state\n   - brightness changes recorded\n   - Multiple operations on same key use latest\n\n3. **Snapshot Storage Tests**\n   - Saves to ~/.local/share/sd/snapshots/\n   - Creates directory if not exists\n   - Uses SQLite for metadata index\n   - Stores images in content-addressable format\n   - Handles disk full gracefully\n\n4. **Image Resolution Tests**\n   - Original path available and valid → use original\n   - Original path missing → fallback to cached\n   - Both missing → clear error with recovery hint\n   - Relative paths resolved correctly\n   - Home directory ~ expanded correctly\n\n### Integration Tests (require MockDevice)\n\n1. **Save-Restore Cycle**\n   - Apply configuration\n   - Save snapshot\n   - Clear device\n   - Restore snapshot\n   - Verify device state matches original\n\n2. **Multiple Snapshots**\n   - Save \"work\" snapshot\n   - Save \"gaming\" snapshot\n   - Restore \"work\" - verify correct\n   - Restore \"gaming\" - verify correct\n   - List shows both with metadata\n\n3. **Snapshot Operations**\n   - List shows all snapshots with dates\n   - Show displays snapshot contents\n   - Delete removes snapshot and cached images\n   - Overwrite existing with same name (with confirmation)\n\n4. **Robot Mode Output**\n   - Save returns snapshot ID and path\n   - Restore returns per-key application status\n   - List returns JSON array with metadata\n   - Errors include snapshot name and reason\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Workflow**\n   - `sd brightness 80 && sd set-key 0 icon.png`\n   - `sd save my-layout`\n   - `sd clear-all`\n   - `sd restore my-layout`\n   - Verify keys restored correctly\n\n2. **Snapshot Management**\n   - `sd snapshots` lists all snapshots\n   - `sd snapshot show my-layout` displays contents\n   - `sd snapshot delete my-layout` removes it\n   - `sd snapshot delete nonexistent` returns error\n\n3. **Edge Cases**\n   - Save with empty device state\n   - Restore when source images deleted\n   - Restore to different device model (should warn)\n   - Unicode characters in snapshot name\n\n### Logging Requirements\n- TRACE: Each key being saved/restored\n- DEBUG: Image resolution decisions, cache hits/misses\n- INFO: Snapshot save/restore complete with key count\n- WARN: Fallback to cached image, missing originals\n- ERROR: Save/restore failures with context\n\n### Test Data\n- tests/fixtures/snapshots/work.json - sample snapshot file\n- tests/fixtures/snapshots/gaming.json - another sample\n- tests/fixtures/snapshots/corrupted.json - invalid snapshot","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:05.979311207Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:42.806959662Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2re","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:38.763082225Z","created_by":"ubuntu"},{"issue_id":"bd-2re","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:42.806921039Z","created_by":"ubuntu"},{"issue_id":"bd-2re","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.988259595Z","created_by":"ubuntu"}]}
{"id":"bd-2rh7","title":"Remove colored crate dependency","description":"# Remove colored crate dependency\n\n## Purpose\nAfter the rich_rust integration is complete, remove the colored crate dependency since all styling is now handled by rich_rust. This reduces dependencies and ensures we're not accidentally using the old styling system.\n\n## Background\nThe colored crate was used for basic terminal coloring before rich_rust integration. With rich_rust now handling all styled output, colored is no longer needed.\n\n## Pre-conditions\nBefore removing colored:\n- [ ] All output flows through Output trait\n- [ ] No code imports or uses colored\n- [ ] Robot mode tests pass (unchanged JSON)\n- [ ] Human mode tests pass (styled output works)\n\n## Implementation Steps\n\n### Step 1: Search for colored Usage\n```bash\nrg \"use colored\" src/\nrg \"colored::\" src/\nrg \".red()\" src/   # Method-style coloring\nrg \".green()\" src/\nrg \".blue()\" src/\n```\n\n### Step 2: Verify No Usage\nAll results should be empty or in comments/documentation.\n\n### Step 3: Remove from Cargo.toml\n```toml\n# Before\n[dependencies]\ncolored = \"3.0\"\n\n# After\n# (line removed)\n```\n\n### Step 4: Verify Compilation\n```bash\ncargo check --all-targets\ncargo build\ncargo test\n```\n\n### Step 5: Verify No colored in Lock File\n```bash\ncargo tree | grep colored\n# Should show no results\n```\n\n## Potential Issues\n\n### Transitive Dependency\nIf another crate depends on colored, it may still appear in Cargo.lock. That's fine - we just don't want direct dependency.\n\n### Test Code\nEnsure test utilities don't use colored either.\n\n### Build Scripts\nCheck build.rs doesn't use colored (it shouldn't).\n\n## Verification\n```bash\n# Ensure no compile errors\ncargo check --all-targets\n\n# Ensure all tests pass\ncargo test\n\n# Verify binary works\ncargo run -- list\ncargo run -- list --robot\n```\n\n## Acceptance Criteria\n- [ ] colored removed from Cargo.toml [dependencies]\n- [ ] No code imports colored\n- [ ] cargo check passes\n- [ ] cargo test passes\n- [ ] CLI works correctly in both modes","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T21:09:40.401060023Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:40.445503361Z","compaction_level":0,"original_size":0,"labels":["cleanup","dependencies","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-2rh7","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:09:40.440219512Z","created_by":"ubuntu"},{"issue_id":"bd-2rh7","depends_on_id":"bd-2ui5","type":"blocks","created_at":"2026-01-19T21:09:40.445470679Z","created_by":"ubuntu"}]}
{"id":"bd-2sd","title":"Integrate gesture detector with watch loop","description":"Modify watch loop:\n1. If --gestures, use GestureDetector\n2. Pass raw events through detector\n3. Emit gesture events instead of raw events\n4. Call tick() periodically for held keys and deferred taps","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.324903187Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.334627155Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sd","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.334583503Z","created_by":"ubuntu"}]}
{"id":"bd-2sp","title":"Add timeout support for commands","description":"If --exec-timeout specified:\n1. Spawn command\n2. Wait with timeout\n3. Kill if exceeds timeout\n4. Report timeout in robot mode\n\nUse std::process::Child with wait_timeout or similar.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:19.671716912Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:19.687064749Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sp","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:19.687008323Z","created_by":"ubuntu"}]}
{"id":"bd-2t5","title":"Add configuration export/import","description":"GET /api/config → YAML configuration\nPOST /api/config with YAML → apply configuration\n\nIntegrates with declarative config system.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:49.338508012Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:49.356031806Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2t5","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:49.355979357Z","created_by":"ubuntu"}]}
{"id":"bd-2ui","title":"Implement basic file watcher","description":"## Purpose\nCreate robust file watching infrastructure for hot-reload configuration using the notify crate.\n\n## Implementation\n```rust\n// src/watch_config.rs\nuse notify::{\n    Config, Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher,\n    event::{ModifyKind, DataChange},\n};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc::{channel, Receiver};\nuse std::time::{Duration, Instant};\nuse tracing::{debug, trace, info, warn, error, instrument, span, Level};\n\n/// File watcher for configuration hot-reload\npub struct ConfigWatcher {\n    watcher: RecommendedWatcher,\n    receiver: Receiver<Result<Event, notify::Error>>,\n    config_path: PathBuf,\n    debounce_duration: Duration,\n    last_event_time: Option<Instant>,\n}\n\nimpl ConfigWatcher {\n    /// Create a new config watcher for the given path\n    #[instrument(skip_all, fields(path = %config_path.display()))]\n    pub fn new(config_path: PathBuf, debounce_ms: u64) -> Result<Self, WatchError> {\n        // Verify file exists and is readable\n        if !config_path.exists() {\n            return Err(WatchError::FileNotFound(config_path.clone()));\n        }\n        \n        if !config_path.is_file() {\n            return Err(WatchError::NotAFile(config_path.clone()));\n        }\n        \n        let (tx, rx) = channel();\n        \n        // Create watcher with recommended settings\n        let watcher = RecommendedWatcher::new(\n            move |res: Result<Event, notify::Error>| {\n                let _ = tx.send(res);\n            },\n            Config::default()\n                .with_poll_interval(Duration::from_millis(500))\n                .with_compare_contents(true),  // Detect content changes, not just metadata\n        )?;\n        \n        info!(\"Config watcher initialized\");\n        \n        Ok(Self {\n            watcher,\n            receiver: rx,\n            config_path,\n            debounce_duration: Duration::from_millis(debounce_ms),\n            last_event_time: None,\n        })\n    }\n    \n    /// Start watching the config file\n    #[instrument(skip(self))]\n    pub fn start_watching(&mut self) -> Result<(), WatchError> {\n        // Watch the parent directory to handle editors that use atomic saves\n        // (write to temp, rename to target)\n        let parent = self.config_path.parent()\n            .ok_or_else(|| WatchError::NoParentDir(self.config_path.clone()))?;\n        \n        trace!(dir = %parent.display(), \"Watching parent directory\");\n        self.watcher.watch(parent, RecursiveMode::NonRecursive)?;\n        \n        info!(path = %self.config_path.display(), \"Started watching config file\");\n        Ok(())\n    }\n    \n    /// Stop watching\n    pub fn stop_watching(&mut self) -> Result<(), WatchError> {\n        if let Some(parent) = self.config_path.parent() {\n            self.watcher.unwatch(parent)?;\n        }\n        info!(\"Stopped watching config file\");\n        Ok(())\n    }\n    \n    /// Poll for file changes with timeout\n    /// Returns Some(()) if config file changed, None if timeout\n    #[instrument(skip(self), level = \"trace\")]\n    pub fn poll_change(&mut self, timeout: Duration) -> Result<Option<()>, WatchError> {\n        match self.receiver.recv_timeout(timeout) {\n            Ok(Ok(event)) => {\n                if self.is_relevant_event(&event) {\n                    // Debounce: ignore events too close together\n                    if let Some(last_time) = self.last_event_time {\n                        if last_time.elapsed() < self.debounce_duration {\n                            trace!(\n                                elapsed_ms = %last_time.elapsed().as_millis(),\n                                debounce_ms = %self.debounce_duration.as_millis(),\n                                \"Event within debounce window, skipping\"\n                            );\n                            return Ok(None);\n                        }\n                    }\n                    \n                    self.last_event_time = Some(Instant::now());\n                    debug!(kind = ?event.kind, \"Config file changed\");\n                    Ok(Some(()))\n                } else {\n                    trace!(kind = ?event.kind, \"Ignoring irrelevant event\");\n                    Ok(None)\n                }\n            }\n            Ok(Err(e)) => {\n                warn!(error = %e, \"Watch error\");\n                Err(WatchError::Notify(e))\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => {\n                Ok(None)\n            }\n            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => {\n                error!(\"Watch channel disconnected\");\n                Err(WatchError::ChannelDisconnected)\n            }\n        }\n    }\n    \n    /// Check if this event is relevant to our config file\n    fn is_relevant_event(&self, event: &Event) -> bool {\n        // Must involve our config file\n        let involves_config = event.paths.iter().any(|p| {\n            p == &self.config_path || \n            p.file_name() == self.config_path.file_name()\n        });\n        \n        if !involves_config {\n            return false;\n        }\n        \n        // Must be a modify or create event (handles atomic saves)\n        matches!(\n            event.kind,\n            EventKind::Modify(ModifyKind::Data(_)) |\n            EventKind::Modify(ModifyKind::Any) |\n            EventKind::Create(_)\n        )\n    }\n    \n    /// Get the path being watched\n    pub fn config_path(&self) -> &Path {\n        &self.config_path\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum WatchError {\n    #[error(\"Config file not found: {0}\")]\n    FileNotFound(PathBuf),\n    \n    #[error(\"Path is not a file: {0}\")]\n    NotAFile(PathBuf),\n    \n    #[error(\"Cannot determine parent directory: {0}\")]\n    NoParentDir(PathBuf),\n    \n    #[error(\"Notify error: {0}\")]\n    Notify(#[from] notify::Error),\n    \n    #[error(\"Watch channel disconnected\")]\n    ChannelDisconnected,\n}\n\n/// Watch loop that applies config on changes\n#[instrument(skip_all, fields(config = %config_path.display()))]\npub fn run_watch_loop<F>(\n    config_path: PathBuf,\n    debounce_ms: u64,\n    mut apply_fn: F,\n) -> Result<(), WatchError>\nwhere\n    F: FnMut(&Path) -> Result<usize, Box<dyn std::error::Error>>,\n{\n    let mut watcher = ConfigWatcher::new(config_path.clone(), debounce_ms)?;\n    watcher.start_watching()?;\n    \n    // Initial apply\n    info!(\"Applying initial configuration\");\n    match apply_fn(&config_path) {\n        Ok(changes) => info!(changes = %changes, \"Initial configuration applied\"),\n        Err(e) => error!(error = %e, \"Failed to apply initial configuration\"),\n    }\n    \n    println!(\"Watching {} for changes (Ctrl+C to stop)...\", config_path.display());\n    \n    loop {\n        match watcher.poll_change(Duration::from_millis(100)) {\n            Ok(Some(())) => {\n                info!(\"Change detected, reloading\");\n                match apply_fn(&config_path) {\n                    Ok(changes) => {\n                        info!(changes = %changes, \"Configuration reloaded\");\n                        println!(\"[{}] Applied {} changes\", \n                            chrono::Local::now().format(\"%H:%M:%S\"),\n                            changes);\n                    }\n                    Err(e) => {\n                        error!(error = %e, \"Failed to apply configuration\");\n                        eprintln!(\"[{}] Error: {}\", \n                            chrono::Local::now().format(\"%H:%M:%S\"),\n                            e);\n                    }\n                }\n            }\n            Ok(None) => {\n                // Timeout, continue loop\n            }\n            Err(WatchError::ChannelDisconnected) => {\n                info!(\"Watcher shutting down\");\n                break;\n            }\n            Err(e) => {\n                error!(error = %e, \"Watch error\");\n            }\n        }\n    }\n    \n    watcher.stop_watching()?;\n    Ok(())\n}\n```\n\n## Editor Compatibility Notes\nDifferent editors save files differently:\n- **vim/neovim**: Writes to temp file, then renames (atomic)\n- **VSCode**: Direct write to file\n- **Sublime Text**: Creates backup, writes, deletes backup\n- **IntelliJ**: Uses safe write with temp file\n\nBy watching the parent directory and handling both Modify and Create events, we handle all these cases.\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_watcher_creation() {\n        let temp = TempDir::new().unwrap();\n        let config = temp.path().join(\"config.yaml\");\n        std::fs::write(&config, \"test: true\").unwrap();\n        \n        let watcher = ConfigWatcher::new(config, 100);\n        assert!(watcher.is_ok());\n    }\n    \n    #[test]\n    fn test_watcher_file_not_found() {\n        let result = ConfigWatcher::new(PathBuf::from(\"/nonexistent/config.yaml\"), 100);\n        assert!(matches!(result, Err(WatchError::FileNotFound(_))));\n    }\n    \n    #[test]\n    fn test_debounce() {\n        let temp = TempDir::new().unwrap();\n        let config = temp.path().join(\"config.yaml\");\n        std::fs::write(&config, \"test: true\").unwrap();\n        \n        let mut watcher = ConfigWatcher::new(config.clone(), 500).unwrap();\n        watcher.start_watching().unwrap();\n        \n        // Rapid modifications should be debounced\n        for _ in 0..5 {\n            std::fs::write(&config, \"test: modified\").unwrap();\n            std::thread::sleep(Duration::from_millis(50));\n        }\n        \n        // Should only register one change due to debouncing\n        // (Test timing is tricky, this is more of a smoke test)\n    }\n}\n```\n\n## Success Criteria\n- [ ] Watcher created successfully for existing files\n- [ ] Error on non-existent or non-file paths\n- [ ] Events debounced within configured window\n- [ ] Handles vim/VSCode/Sublime atomic saves\n- [ ] Clean shutdown with stop_watching()\n- [ ] Initial config applied on start\n\n## Logging Requirements\n- TRACE: Watching parent directory, event details, debounce skips, irrelevant events\n- DEBUG: Config file changed (relevant events)\n- INFO: Watcher initialized, started/stopped watching, change detected, config reloaded\n- WARN: Watch error events\n- ERROR: Channel disconnected, failed to apply config","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.905192428Z","created_by":"ubuntu","updated_at":"2026-01-19T20:51:09.904332649Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ui","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.915490016Z","created_by":"ubuntu"}]}
{"id":"bd-2ui5","title":"Update all command functions to use Output trait","description":"# Update all command functions to use Output trait\n\n## Purpose\nTransform each command function to use the Output trait instead of direct println! calls. This is the detailed implementation work that connects commands to the new output system.\n\n## Command Functions to Update\n\n### 1. cmd_list\n```rust\n// Before\nfn cmd_list(cli: &Cli, args: &ListArgs) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    if cli.use_json() {\n        println!(\"{}\", serde_json::to_string_pretty(&devices)?);\n    } else {\n        if args.long {\n            // detailed output\n        } else {\n            for device in &devices {\n                println!(\"{}\", device.serial);\n            }\n        }\n    }\n    Ok(())\n}\n\n// After\nfn cmd_list(cli: &Cli, args: &ListArgs, output: &dyn Output) -> Result<(), SdError> {\n    let devices = device::list_devices()?;\n    output.device_list(&devices);\n    Ok(())\n}\n```\n\n### 2. cmd_info\n```rust\nfn cmd_info(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    output.device_info(&device.info);\n    Ok(())\n}\n```\n\n### 3. cmd_brightness\n```rust\nfn cmd_brightness(cli: &Cli, args: &BrightnessArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::set_brightness(&device, args.level)?;\n    output.brightness_set(args.level);\n    Ok(())\n}\n```\n\n### 4. cmd_set_key\n```rust\nfn cmd_set_key(cli: &Cli, args: &SetKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::set_key_image(&device, args.key, &args.image)?;\n    output.key_set(args.key, &args.image);\n    Ok(())\n}\n```\n\n### 5. cmd_clear_key\n```rust\nfn cmd_clear_key(cli: &Cli, args: &ClearKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::clear_key(&device, args.key)?;\n    output.key_cleared(args.key);\n    Ok(())\n}\n```\n\n### 6. cmd_clear_all\n```rust\nfn cmd_clear_all(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::clear_all_keys(&device)?;\n    output.all_cleared();\n    Ok(())\n}\n```\n\n### 7. cmd_fill_key\n```rust\nfn cmd_fill_key(cli: &Cli, args: &FillKeyArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let color = parse_color(&args.color)?;\n    device::fill_key_color(&device, args.key, color)?;\n    output.key_filled(args.key, &args.color);\n    Ok(())\n}\n```\n\n### 8. cmd_fill_all\n```rust\nfn cmd_fill_all(cli: &Cli, args: &FillAllArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let color = parse_color(&args.color)?;\n    device::fill_all_keys_color(&device, color)?;\n    output.all_filled(&args.color);\n    Ok(())\n}\n```\n\n### 9. cmd_watch\n```rust\nfn cmd_watch(cli: &Cli, args: &WatchArgs, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    \n    // Human mode header (no-op in robot mode)\n    output.rule(Some(\"Button Events\"));\n    \n    // Watch loop with output trait\n    device::watch_buttons_with_output(&device, output, args.once, args.timeout)?;\n    \n    Ok(())\n}\n```\n\n### 10. cmd_read\n```rust\nfn cmd_read(cli: &Cli, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    let states = device::read_button_states(&device);\n    output.button_states(&states);\n    Ok(())\n}\n```\n\n### 11. cmd_version\n```rust\nfn cmd_version(output: &dyn Output) -> Result<(), SdError> {\n    let version = env!(\"CARGO_PKG_VERSION\");\n    let git_sha = option_env!(\"VERGEN_GIT_SHA\").map(|s| {\n        if option_env!(\"VERGEN_GIT_DIRTY\") == Some(\"true\") {\n            format!(\"{} (dirty)\", s)\n        } else {\n            s.to_string()\n        }\n    });\n    let build_time = option_env!(\"VERGEN_BUILD_TIMESTAMP\");\n    \n    output.version_info(version, git_sha.as_deref(), build_time);\n    Ok(())\n}\n```\n\n## Pattern: Device Operations\nMost commands follow this pattern:\n1. Open device (may error)\n2. Perform operation (may error)\n3. Output success confirmation\n\n```rust\nfn cmd_operation(cli: &Cli, args: &Args, output: &dyn Output) -> Result<(), SdError> {\n    let device = device::open_device(cli.serial.as_deref())?;\n    device::do_something(&device, args.param)?;\n    output.something_done(args.param);\n    Ok(())\n}\n```\n\n## Watch Command Special Case\nThe watch command needs to stream events, so device.rs watch function needs to accept the output trait:\n\n```rust\n// In device.rs\npub fn watch_buttons_with_output(\n    device: &Device,\n    output: &dyn Output,\n    once: bool,\n    timeout_secs: u64,\n) -> Result<(), SdError> {\n    loop {\n        match device.inner.read_input(Duration::from_millis(50)) {\n            Ok(Some(StreamDeckInput::ButtonStateChange(states))) => {\n                for (key, &pressed) in states.iter().enumerate() {\n                    if pressed {\n                        let event = ButtonEvent {\n                            key: key as u8,\n                            pressed: true,\n                            timestamp_ms: current_timestamp_ms(),\n                        };\n                        output.button_event(&event);\n                        \n                        if once {\n                            return Ok(());\n                        }\n                    }\n                }\n            }\n            _ => {}\n        }\n    }\n}\n```\n\n## Verification Checklist\nFor each command:\n- [ ] Function signature updated with output: &dyn Output\n- [ ] All println! calls removed\n- [ ] Appropriate output method called\n- [ ] Robot mode JSON unchanged\n- [ ] Human mode displays styled output\n\n## Acceptance Criteria\n- [ ] All 11 command functions updated\n- [ ] No direct println! in command functions\n- [ ] Watch command streams events via output trait\n- [ ] Version command shows all metadata\n- [ ] Each command produces correct output in both modes","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:09:24.071519014Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:24.112452875Z","compaction_level":0,"original_size":0,"labels":["commands","phase-3","refactor","rich-rust"],"dependencies":[{"issue_id":"bd-2ui5","depends_on_id":"bd-1rhq","type":"parent-child","created_at":"2026-01-19T21:09:24.106899168Z","created_by":"ubuntu"},{"issue_id":"bd-2ui5","depends_on_id":"bd-2mvm","type":"blocks","created_at":"2026-01-19T21:09:24.112411787Z","created_by":"ubuntu"}]}
{"id":"bd-2uym","title":"Update AGENTS.md with output system documentation","description":"# Update AGENTS.md with output system documentation\n\n## Purpose\nUpdate the AGENTS.md file to document the new output system for AI coding agents working on the project. This ensures future maintainers understand the architecture.\n\n## Content to Add\n\n### New Section: Output System Architecture\n```markdown\n## Output System Architecture\n\nThe CLI uses a trait-based output abstraction to support both human and robot modes.\n\n### Key Components\n\n| Component | Location | Purpose |\n|-----------|----------|---------|\n| Output trait | src/output/mod.rs | Common interface for all output |\n| RobotOutput | src/output/robot.rs | JSON output for AI agents |\n| HumanOutput | src/output/human.rs | Styled terminal output |\n| SdTheme | src/theme/mod.rs | Visual styling constants |\n\n### Output Mode Selection\n\n```rust\n// Determined by CLI flags\nif cli.use_json() {  // --robot or --format=json\n    RobotOutput  // Pure JSON\n} else {\n    HumanOutput  // rich_rust styled output\n}\n```\n\n### Adding New Output\n\nWhen adding a new command or output type:\n\n1. Add method to Output trait in src/output/mod.rs\n2. Implement in RobotOutput (JSON structure)\n3. Implement in HumanOutput (styled output)\n4. Add tests for both modes\n\n### Robot Mode Contract\n\nCRITICAL: Robot mode JSON must remain stable. AI agents parse this output. Changes to JSON structure are breaking changes.\n\nCurrent JSON formats documented in tests/golden/*.json\n```\n\n### Update Robot Mode Section\nAdd detail about the Output trait:\n```markdown\n### Robot Mode (Updated)\n\nRobot mode output flows through the Output trait:\n- RobotOutput.device_list() → JSON array of DeviceInfo\n- RobotOutput.error() → JSON with error, message, suggestion, recoverable\n- RobotOutput.button_event() → Single-line JSON for streaming\n\nAll JSON serialization uses serde. Structures must derive Serialize.\n```\n\n### Add Theme Documentation\n```markdown\n### Theme System\n\nVisual styling is centralized in src/theme/mod.rs:\n\n| Color | Hex | Usage |\n|-------|-----|-------|\n| accent | #0080FF | Panel borders, headers |\n| success | #00D26A | Success messages, checkmarks |\n| error | #FF4757 | Error messages, X marks |\n| warning | #FFA502 | Warnings, key indices |\n| muted | #747D8C | Secondary info, timestamps |\n\nTo modify theme colors, edit SdTheme::default() in src/theme/mod.rs.\n```\n\n## Location\nAdd new section after \"Device Commands\" section in AGENTS.md.\n\n## Acceptance Criteria\n- [ ] Output System Architecture section added\n- [ ] Key components documented\n- [ ] Robot mode JSON contract emphasized\n- [ ] Theme colors documented\n- [ ] Instructions for adding new output","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T21:12:19.529063368Z","created_by":"ubuntu","updated_at":"2026-01-19T21:12:19.578456305Z","compaction_level":0,"original_size":0,"labels":["agents","docs","phase-5","rich-rust"],"dependencies":[{"issue_id":"bd-2uym","depends_on_id":"bd-1z7d","type":"parent-child","created_at":"2026-01-19T21:12:19.572238869Z","created_by":"ubuntu"},{"issue_id":"bd-2uym","depends_on_id":"bd-2rh7","type":"blocks","created_at":"2026-01-19T21:12:19.578368460Z","created_by":"ubuntu"}]}
{"id":"bd-2vg","title":"Implement config loading (YAML + TOML)","description":"## Purpose\nLoad declarative configuration from YAML or TOML files with validation.\n\n## Implementation\n\n```rust\n// src/config/loader.rs\nuse std::path::Path;\nuse tracing::{debug, info, warn, instrument};\n\n#[derive(Debug, Clone)]\npub enum ConfigFormat {\n    Yaml,\n    Toml,\n}\n\nimpl ConfigFormat {\n    pub fn from_extension(path: &Path) -> Option<Self> {\n        match path.extension()?.to_str()? {\n            \"yaml\" | \"yml\" => Some(Self::Yaml),\n            \"toml\" => Some(Self::Toml),\n            _ => None,\n        }\n    }\n}\n\n/// Load and parse a configuration file\n#[instrument(fields(path = %path.display()))]\npub fn load_config(path: &Path) -> Result<ProfileConfig, ConfigError> {\n    info!(\"Loading configuration file\");\n    \n    // Detect format\n    let format = ConfigFormat::from_extension(path)\n        .ok_or_else(|| ConfigError::UnknownFormat(path.to_path_buf()))?;\n    debug!(format = ?format, \"Detected config format\");\n    \n    // Read file\n    let content = std::fs::read_to_string(path)\n        .map_err(|e| ConfigError::ReadError(path.to_path_buf(), e))?;\n    debug!(bytes = %content.len(), \"Read config file\");\n    \n    // Parse based on format\n    let config: ProfileConfig = match format {\n        ConfigFormat::Yaml => {\n            serde_yaml::from_str(&content)\n                .map_err(|e| ConfigError::ParseError(format!(\"YAML: {}\", e)))?\n        }\n        ConfigFormat::Toml => {\n            toml::from_str(&content)\n                .map_err(|e| ConfigError::ParseError(format!(\"TOML: {}\", e)))?\n        }\n    };\n    \n    // Validate\n    config.validate()?;\n    \n    info!(\n        keys = %config.keys.len(),\n        brightness = ?config.brightness,\n        \"Configuration loaded successfully\"\n    );\n    \n    Ok(config)\n}\n\n#[derive(Debug, Clone, serde::Deserialize)]\npub struct ProfileConfig {\n    /// Optional profile name\n    pub name: Option<String>,\n    /// Target device serial (optional)\n    pub device: Option<String>,\n    /// Brightness level (0-100)\n    pub brightness: Option<u8>,\n    /// Key configurations\n    #[serde(default)]\n    pub keys: Vec<KeyConfig>,\n}\n\nimpl ProfileConfig {\n    pub fn validate(&self) -> Result<(), ConfigError> {\n        // Validate brightness range\n        if let Some(b) = self.brightness {\n            if b > 100 {\n                return Err(ConfigError::ValidationError(\n                    format!(\"brightness {} out of range (0-100)\", b)\n                ));\n            }\n        }\n        \n        // Validate each key config\n        for key in &self.keys {\n            key.validate()?;\n        }\n        \n        Ok(())\n    }\n}\n```\n\n## Dependencies\n```toml\n# Cargo.toml additions\nserde_yaml = \"0.9\"\ntoml = \"0.8\"\n```\n\n## Edge Cases\n- File not found → clear error with path\n- Permission denied → clear error\n- Empty file → empty config (valid)\n- Duplicate keys → last wins with warning\n- Unknown fields → ignored (forward compat)\n- Invalid UTF-8 → ParseError\n\n## Logging Requirements\n- TRACE: Individual field parsing\n- DEBUG: Format detection, file read, key parsing\n- INFO: Load start/complete with summary\n- WARN: Unknown fields, duplicate keys\n- ERROR: Parse failures, validation errors\n\n## Success Criteria\n- [ ] YAML files load correctly\n- [ ] TOML files load correctly\n- [ ] Format auto-detected from extension\n- [ ] Validation catches invalid values\n- [ ] Clear errors for common issues","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.427405742Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:26.102849039Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2vg","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.441503776Z","created_by":"ubuntu"}]}
{"id":"bd-2xx","title":"Build frontend HTML structure","description":"Create static/index.html:\n- Device info display\n- Grid of keys matching device layout\n- Brightness slider\n- Drag-and-drop zones for images\n- Color picker\n\nKeep minimal - vanilla JS preferred.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:47.901045537Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:47.916799168Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2xx","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:47.916732602Z","created_by":"ubuntu"}]}
{"id":"bd-2yg","title":"Add snapshot show/delete commands","description":"Implement:\n- sd snapshot show <name>: Display snapshot contents (keys, brightness)\n- sd snapshot delete <name>: Remove snapshot with confirmation\n\nNote: deletion should be explicit, not part of normal workflow","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.566787383Z","created_by":"ubuntu","updated_at":"2026-01-21T11:24:04.959900763Z","closed_at":"2026-01-21T11:24:04.959838767Z","close_reason":"Implemented cmd_snapshot_show and cmd_snapshot_delete with CLI subcommands. Show displays detailed snapshot info (device model, key count, brightness, keys with their states). Delete includes confirmation prompt (bypassed with --force), orphan image cleanup, and proper error handling.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yg","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.576243097Z","created_by":"ubuntu"}]}
{"id":"bd-2ys","title":"Implement device_info rich output with Table and key layout grid","description":"# Implement device_info rich output with Table and key layout grid\n\n## Purpose\nCreate a comprehensive, visually stunning device information display using a Table for specifications and an ASCII art key layout grid. This command provides the detailed view when a user wants to understand their device.\n\n## Target Output\n```\n╭──────────────────── Stream Deck XL ─────────────────────╮\n│                                                         │\n│  ┌─────────────┬────────────────────────────────────┐   │\n│  │ Serial      │ AL12U1E1234                        │   │\n│  │ Firmware    │ 1.5.3                              │   │\n│  │ Keys        │ 32 (8 columns × 4 rows)            │   │\n│  │ Key Size    │ 96×96 pixels                       │   │\n│  │ Device Type │ Xl                                 │   │\n│  └─────────────┴────────────────────────────────────┘   │\n│                                                         │\n│  Key Layout:                                            │\n│  ┌──┬──┬──┬──┬──┬──┬──┬──┐                              │\n│  │ 0│ 1│ 2│ 3│ 4│ 5│ 6│ 7│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │ 8│ 9│10│11│12│13│14│15│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │16│17│18│19│20│21│22│23│                              │\n│  ├──┼──┼──┼──┼──┼──┼──┼──┤                              │\n│  │24│25│26│27│28│29│30│31│                              │\n│  └──┴──┴──┴──┴──┴──┴──┴──┘                              │\n│                                                         │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Key Layout Grid Generator\n```rust\nimpl HumanOutput {\n    /// Generate ASCII art key layout grid\n    fn render_key_layout(&self, rows: u8, cols: u8) -> String {\n        let mut grid = String::new();\n        \n        // Calculate cell width (need room for 2-digit numbers)\n        let cell_width = 2;\n        \n        // Top border\n        grid.push_str(\"  ┌\");\n        for c in 0..cols {\n            grid.push_str(&\"─\".repeat(cell_width));\n            if c < cols - 1 { grid.push('┬'); }\n        }\n        grid.push_str(\"┐\\n\");\n        \n        // Rows with content\n        for r in 0..rows {\n            grid.push_str(\"  │\");\n            for c in 0..cols {\n                let key_num = r * cols + c;\n                grid.push_str(&format!(\"{:>2}\", key_num));\n                if c < cols - 1 { grid.push('│'); }\n            }\n            grid.push_str(\"│\\n\");\n            \n            // Row separator (except after last row)\n            if r < rows - 1 {\n                grid.push_str(\"  ├\");\n                for c in 0..cols {\n                    grid.push_str(&\"─\".repeat(cell_width));\n                    if c < cols - 1 { grid.push('┼'); }\n                }\n                grid.push_str(\"┤\\n\");\n            }\n        }\n        \n        // Bottom border\n        grid.push_str(\"  └\");\n        for c in 0..cols {\n            grid.push_str(&\"─\".repeat(cell_width));\n            if c < cols - 1 { grid.push('┴'); }\n        }\n        grid.push_str(\"┘\\n\");\n        \n        grid\n    }\n}\n```\n\n### device_info Method\n```rust\nfn device_info(&self, info: &DeviceInfo) {\n    // Build specification table\n    let mut table = Table::new()\n        .with_column(Column::new(\"\").style(self.theme.label.clone()))\n        .with_column(Column::new(\"\").style(self.theme.value.clone()))\n        .box_style(&BoxChars::ROUNDED);\n    \n    table.add_row_cells([\"Serial\", &info.serial]);\n    table.add_row_cells([\"Firmware\", &info.firmware_version]);\n    table.add_row_cells([\"Keys\", &format!(\"{} ({} columns × {} rows)\", \n        info.key_count, info.cols, info.rows)]);\n    table.add_row_cells([\"Key Size\", &format!(\"{}×{} pixels\", \n        info.key_width, info.key_height)]);\n    table.add_row_cells([\"Device Type\", &info.kind]);\n    \n    // Render table to segments\n    let table_segments = table.render(self.width().saturating_sub(6));\n    \n    // Build key layout\n    let key_layout = self.render_key_layout(info.rows, info.cols);\n    \n    // Combine into content\n    let mut content = Text::new(\"\");\n    content.append(\"\\n\");\n    \n    // Add table (need to convert segments to text)\n    for segment in table_segments {\n        content.append(&segment.text);\n    }\n    \n    content.append(\"\\n\");\n    content.append_styled(\"  Key Layout:\\n\", self.theme.label.clone());\n    content.append(&key_layout);\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(&info.product_name)\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Table for Specifications\n- Key-value pairs are perfect for table layout\n- Labels in left column, values in right\n- Consistent alignment improves scannability\n\n### Key Layout Grid\n- ASCII art provides immediate visual understanding\n- Shows key numbering convention (left-to-right, top-to-bottom)\n- Essential for users setting up key configurations\n- Uses box-drawing characters that match panel style\n\n### Panel Title\n- Uses device product name (e.g., \"Stream Deck XL\")\n- Centered in panel header for prominence\n\n### Information Selection\n- Serial: Needed for multi-device scenarios\n- Firmware: Useful for troubleshooting\n- Keys: Count and layout dimensions\n- Key Size: Important for image preparation\n- Device Type: Internal identifier\n\n## Edge Cases\n- Stream Deck Mini (6 keys, 3×2): Smaller grid\n- Stream Deck Original (15 keys, 5×3): Medium grid\n- Stream Deck XL (32 keys, 8×4): Full grid as shown\n- Stream Deck + (8 keys, 4×2): Narrow grid\n\n## Testing\n```rust\n#[test]\nfn key_layout_grid_dimensions() {\n    let output = HumanOutput::new(test_console());\n    \n    let grid = output.render_key_layout(4, 8);\n    \n    // Verify grid has correct number of rows\n    assert_eq!(grid.lines().count(), 9); // 4 data rows + 5 border rows\n    \n    // Verify key numbers are correct\n    assert!(grid.contains(\"│ 0│ 1│\"));\n    assert!(grid.contains(\"│24│25│\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] Device info renders in styled panel\n- [ ] Table shows all device specifications\n- [ ] Key layout grid is accurate for device dimensions\n- [ ] Grid uses box-drawing characters\n- [ ] Panel title shows device name\n- [ ] Works for all Stream Deck models","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:05:59.366035813Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:59.415305398Z","compaction_level":0,"original_size":0,"labels":["device","info","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-2ys","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:05:59.415277315Z","created_by":"ubuntu"},{"issue_id":"bd-2ys","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:05:59.411015120Z","created_by":"ubuntu"}]}
{"id":"bd-305","title":"Add SetKeys command struct to CLI","description":"## Add SetKeys Command Struct to CLI\n\n### Command Definition (src/cli/mod.rs)\n\n```rust\n/// Set multiple keys from a directory of images\n#[derive(Parser, Debug)]\npub struct SetKeysCommand {\n    /// Directory containing key images\n    #[arg(value_name = \"DIR\")]\n    pub dir: PathBuf,\n\n    /// Filename pattern with {index} placeholder\n    /// Examples: \"key-{index}.png\", \"icon_{index:02d}.jpg\"\n    #[arg(long, short = 'p', default_value = \"key-{index}.png\")]\n    pub pattern: String,\n\n    /// Continue setting other keys if one fails\n    #[arg(long, short = 'c')]\n    pub continue_on_error: bool,\n\n    /// Starting key index (for partial layouts)\n    #[arg(long, default_value = \"0\")]\n    pub start_key: u8,\n\n    /// Only process keys in this range (e.g., \"0-7\" for first row)\n    #[arg(long)]\n    pub key_range: Option<String>,\n\n    /// Dry run - show what would happen without applying\n    /// (Note: This is covered by global --dry-run flag, but explicit here for discoverability)\n    #[arg(long, short = 'n')]\n    pub dry_run: bool,\n\n    /// Clear keys that don't have matching images\n    #[arg(long)]\n    pub clear_missing: bool,\n\n    /// Skip keys that already have the same image (compare by hash)\n    #[arg(long)]\n    pub skip_unchanged: bool,\n\n    /// Maximum concurrent key sets (for performance tuning)\n    #[arg(long, default_value = \"1\")]\n    pub concurrency: u8,\n}\n```\n\n### Command Registration\n\n```rust\n#[derive(Subcommand, Debug)]\npub enum Command {\n    // ... existing commands\n    \n    /// Set multiple keys from a directory of images\n    #[command(visible_alias = \"batch\")]\n    SetKeys(SetKeysCommand),\n}\n```\n\n### Help Text\n\n```\nUSAGE:\n    sd set-keys [OPTIONS] <DIR>\n\nARGS:\n    <DIR>    Directory containing key images\n\nOPTIONS:\n    -p, --pattern <PATTERN>     Filename pattern [default: key-{index}.png]\n    -c, --continue-on-error     Continue if individual keys fail\n        --start-key <N>         Starting key index [default: 0]\n        --key-range <RANGE>     Only process keys in range (e.g., \"0-7\")\n    -n, --dry-run               Preview without applying changes\n        --clear-missing         Clear keys without matching images\n        --skip-unchanged        Skip keys with identical images\n        --concurrency <N>       Parallel key operations [default: 1]\n    -h, --help                  Print help\n\nEXAMPLES:\n    # Set all keys from directory\n    sd set-keys ~/my-layout/\n\n    # Use custom naming pattern\n    sd set-keys ~/icons/ --pattern \"icon-{index:02d}.png\"\n\n    # Only set first row (keys 0-7 on XL)\n    sd set-keys ~/row1/ --key-range 0-7\n\n    # Preview changes first\n    sd set-keys ~/layout/ --dry-run\n```\n\n### Pattern Syntax Documentation\n\nThe pattern supports these placeholders:\n- `{index}` - Key index as decimal (0, 1, 2, ...)\n- `{index:02d}` - Key index with zero-padding (00, 01, 02, ...)\n- `{index:X}` - Key index as uppercase hex (0, 1, ..., A, B, ...)\n- `{row}` - Row number (0-3 for XL)\n- `{col}` - Column number (0-7 for XL)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:41.964096116Z","created_by":"ubuntu","updated_at":"2026-01-21T09:10:23.104394386Z","closed_at":"2026-01-21T09:10:23.104338300Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-305","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:41.982464199Z","created_by":"ubuntu"}]}
{"id":"bd-319","title":"Add --profile support for saved profiles","description":"With --profile <name>:\n- Load profile from snapshot/config storage\n- Generate script from stored state instead of session\n- Allows exporting saved configurations\n\nRequires: SAVE-RESTORE or DECLARATIVE-CONFIG to be implemented.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:02.945280338Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:02.961325127Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-319","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.961283929Z","created_by":"ubuntu"}]}
{"id":"bd-31u","title":"EPIC: Testing & Observability Infrastructure","description":"## Overview\n**FOUNDATIONAL EPIC** - Must be implemented early as other epics depend on this infrastructure.\n\nThis epic establishes the testing and observability foundation that enables comprehensive quality assurance across all features.\n\n## Problem Statement\nWithout proper testing infrastructure:\n- Unit tests cannot mock device interactions\n- Integration tests have no way to simulate USB devices\n- E2E tests lack consistent harness and reporting\n- Debugging production issues is difficult without logging\n- CI/CD cannot run device-dependent tests\n\n## Components\n\n### 1. Mock Device Layer\nA mock implementation of the Stream Deck device interface that:\n- Simulates all device operations (set_key, brightness, etc.)\n- Records all operations for assertion\n- Can simulate errors and edge cases\n- Supports configurable device models (XL, MK2, Mini)\n\n### 2. Test Harness\nConsistent test infrastructure including:\n- Test fixtures for common scenarios\n- Sample images in various formats\n- Sample profile files (Elgato format)\n- Declarative config test files\n- Snapshot comparison utilities\n\n### 3. Logging Infrastructure\nStructured logging using tracing crate:\n- Configurable log levels via RUST_LOG\n- Structured JSON output for robot mode\n- Human-readable output for terminal\n- Performance timing spans\n- Error context capture\n\n### 4. E2E Test Framework\nEnd-to-end testing infrastructure:\n- CLI invocation helpers\n- Output capture and parsing\n- Robot mode JSON validation\n- Exit code assertions\n- Timeout handling\n\n## Why This Is Foundational\nEvery feature epic needs:\n- Unit tests → requires mock device\n- Integration tests → requires test harness\n- E2E tests → requires CLI test framework\n- Debugging → requires logging\n\nImplementing this first enables parallel development of other features with proper testing.\n\n## Success Criteria\n- [ ] Mock device passes all unit tests without real hardware\n- [ ] Test harness provides fixtures for all test scenarios\n- [ ] Logging captures all operations with context\n- [ ] E2E framework can test any CLI command\n- [ ] CI can run full test suite without Stream Deck hardware\n\n## Architecture\n```\n┌─────────────────────────────────────────────┐\n│                 CLI Layer                    │\n├─────────────────────────────────────────────┤\n│              Device Trait                    │\n├──────────────────┬──────────────────────────┤\n│   Real Device    │      Mock Device          │\n│ (elgato-streamdeck)│  (testing only)         │\n└──────────────────┴──────────────────────────┘\n```\n\n## Files to Create\n- `src/device/mod.rs`: Device trait extraction\n- `src/device/real.rs`: Real device implementation\n- `src/device/mock.rs`: Mock device for testing\n- `src/logging.rs`: Tracing setup\n- `tests/common/mod.rs`: Test utilities\n- `tests/fixtures/`: Test data files\n- `tests/e2e/`: E2E test modules","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:35:36.861992209Z","created_by":"ubuntu","updated_at":"2026-01-21T11:30:56.801666481Z","closed_at":"2026-01-21T11:30:56.801619573Z","close_reason":"Core success criteria met: 1) MockDevice implemented (bd-180) with 17 tests passing without real hardware. 2) Test harness provides fixtures (tests/fixtures/) and CLI test runner (tests/common/cli.rs). 3) Logging set up with tracing (bd-21i). 4) E2E framework (bd-1xy) can test CLI commands with fluent assertions. 5) Full 67-test suite runs without Stream Deck hardware. Remaining P1 tasks (bd-1gx6 test utilities, bd-2ky fixtures) are enhancements.","compaction_level":0,"original_size":0,"labels":["foundation","infrastructure","logging","testing"]}
{"id":"bd-326","title":"Implement auto-reconnect for watch command","description":"## Purpose\nAdd automatic reconnection to the watch command for robust long-running operation.\n\n## Implementation\n\n```rust\n// In src/cli/watch.rs\nuse std::time::Duration;\nuse tracing::{debug, info, warn, error, instrument};\n\nconst MAX_RECONNECT_DELAY: Duration = Duration::from_secs(30);\nconst INITIAL_RECONNECT_DELAY: Duration = Duration::from_secs(1);\nconst BACKOFF_FACTOR: f32 = 1.5;\n\n#[derive(Debug, Clone)]\npub struct WatchOptions {\n    pub reconnect: bool,\n    pub reconnect_delay: Duration,\n    pub max_reconnect_attempts: Option<u32>,\n}\n\n#[instrument(skip(device, opts))]\npub async fn watch_events(\n    mut device: Device,\n    opts: &WatchOptions,\n) -> Result<(), WatchError> {\n    let mut reconnect_delay = INITIAL_RECONNECT_DELAY;\n    let mut reconnect_attempts = 0;\n    \n    loop {\n        info!(\"Starting event watch loop\");\n        \n        match watch_loop(&device).await {\n            Ok(()) => {\n                // Normal exit (e.g., Ctrl+C)\n                info!(\"Watch loop exited normally\");\n                return Ok(());\n            }\n            Err(e) if e.is_connection_error() && opts.reconnect => {\n                reconnect_attempts += 1;\n                \n                // Check max attempts\n                if let Some(max) = opts.max_reconnect_attempts {\n                    if reconnect_attempts > max {\n                        error!(\n                            attempts = %reconnect_attempts,\n                            \"Max reconnection attempts exceeded\"\n                        );\n                        return Err(e);\n                    }\n                }\n                \n                warn!(\n                    error = %e,\n                    attempt = %reconnect_attempts,\n                    delay_secs = %reconnect_delay.as_secs_f32(),\n                    \"Connection lost, reconnecting\"\n                );\n                \n                // Emit disconnected event (robot mode)\n                emit_event(WatchEvent::Disconnected {\n                    reason: e.to_string(),\n                    reconnecting: true,\n                });\n                \n                // Wait before reconnecting\n                tokio::time::sleep(reconnect_delay).await;\n                \n                // Try to reconnect\n                match Device::open_with_retry(device.serial(), &Default::default()) {\n                    Ok(new_device) => {\n                        info!(\"Reconnected successfully\");\n                        device = new_device;\n                        reconnect_delay = INITIAL_RECONNECT_DELAY;\n                        reconnect_attempts = 0;\n                        \n                        // Emit reconnected event\n                        emit_event(WatchEvent::Reconnected {\n                            device_serial: device.serial().map(|s| s.to_string()),\n                        });\n                    }\n                    Err(e) => {\n                        warn!(error = %e, \"Reconnection attempt failed\");\n                        // Increase backoff for next attempt\n                        reconnect_delay = Duration::from_secs_f32(\n                            (reconnect_delay.as_secs_f32() * BACKOFF_FACTOR)\n                                .min(MAX_RECONNECT_DELAY.as_secs_f32())\n                        );\n                        continue;\n                    }\n                }\n            }\n            Err(e) => {\n                error!(error = %e, \"Watch loop failed\");\n                return Err(e);\n            }\n        }\n    }\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(tag = \"type\")]\npub enum WatchEvent {\n    KeyPress { key: u8, timestamp: String },\n    KeyRelease { key: u8, timestamp: String },\n    Disconnected { reason: String, reconnecting: bool },\n    Reconnected { device_serial: Option<String> },\n}\n```\n\n## CLI Flags\n- `--reconnect`: Enable auto-reconnect (default: off)\n- `--reconnect-delay <ms>`: Initial reconnect delay (default: 1000)\n- `--max-reconnect-attempts <n>`: Limit attempts (default: unlimited)\n\n## Edge Cases\n- Device unplugged → detect, reconnect\n- USB hub reset → detect, reconnect\n- System sleep/wake → detect, reconnect\n- Device never returns → respect max attempts or run forever\n- Different device connected → warn and reconnect to same serial\n\n## Logging Requirements\n- TRACE: Individual event read\n- DEBUG: Reconnection attempt details, backoff calculation\n- INFO: Watch start, reconnection success, normal exit\n- WARN: Connection lost (with context), reconnect failure\n- ERROR: Max attempts exceeded, unrecoverable error\n\n## Success Criteria\n- [ ] Watch survives device unplug/replug\n- [ ] Backoff prevents rapid reconnection spam\n- [ ] Robot mode emits disconnect/reconnect events\n- [ ] Human mode shows status messages\n- [ ] Ctrl+C exits cleanly even during reconnection","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.492377938Z","created_by":"ubuntu","updated_at":"2026-01-21T11:26:50.332514303Z","closed_at":"2026-01-21T11:26:50.332465191Z","close_reason":"Implemented auto-reconnect for watch command with --reconnect flag, --reconnect-delay, --max-reconnect-attempts options. Features: exponential backoff (1.5x factor), 30-second max delay cap, connection event emission in robot mode (disconnected, reconnecting, reconnected events), graceful handling of unlimited retries.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-326","depends_on_id":"bd-1os","type":"blocks","created_at":"2026-01-19T21:53:42.341656062Z","created_by":"ubuntu"},{"issue_id":"bd-326","depends_on_id":"bd-1xp","type":"blocks","created_at":"2026-01-19T21:53:45.825549025Z","created_by":"ubuntu"},{"issue_id":"bd-326","depends_on_id":"bd-2a1","type":"blocks","created_at":"2026-01-19T22:07:24.938156098Z","created_by":"ubuntu"},{"issue_id":"bd-326","depends_on_id":"bd-37v","type":"blocks","created_at":"2026-01-19T21:53:47.527123310Z","created_by":"ubuntu"},{"issue_id":"bd-326","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.507471676Z","created_by":"ubuntu"}]}
{"id":"bd-33c","title":"Integrate cache into set_key_image","description":"Modify image setting flow:\n1. Check cache for pre-processed image\n2. If hit: use cached data directly\n3. If miss: load, resize, encode, cache, then send\n4. Report cache hit/miss for metrics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:39.075313942Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:39.084764195Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-33c","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:39.084713159Z","created_by":"ubuntu"}]}
{"id":"bd-34h","title":"Test across sleep/wake cycles","description":"Manual testing checklist:\n1. Start sd watch --reconnect\n2. Put machine to sleep\n3. Wake machine\n4. Verify automatic reconnection\n5. Test on Linux and macOS if possible","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:26.463127532Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:19.560988255Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-34h","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T21:03:19.560946086Z","created_by":"ubuntu"},{"issue_id":"bd-34h","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T18:39:12.408821481Z","created_by":"ubuntu"},{"issue_id":"bd-34h","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.477954358Z","created_by":"ubuntu"}]}
{"id":"bd-34i","title":"EPIC: Device State Snapshots (Save/Restore)","description":"## Overview\n**Rank: #2 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nAdd `sd save <name>` and `sd restore <name>` commands to capture and restore complete device state (key images + brightness).\n\n## Problem Statement\nUsers typically want to switch between different configurations:\n- \"Work mode\" with productivity app shortcuts\n- \"Gaming mode\" with game-specific macros\n- \"Streaming mode\" with OBS controls\n- \"Music mode\" with DAW controls\n\nCurrently, switching requires re-running 30+ commands or maintaining external scripts. There is no way to capture the current state and restore it later.\n\n## Solution\nNamed snapshots that capture the entire device state:\n```bash\nsd save work-mode      # Capture current state\nsd save gaming-mode    # Capture another state\nsd restore work-mode   # Switch back instantly\nsd snapshots           # List available snapshots\nsd snapshot delete gaming-mode  # Remove a snapshot\n```\n\n## Why This Is #2 Priority\n1. **Workflow enabler**: Makes the CLI usable for real multi-context workflows\n2. **Builds on config infrastructure**: The `src/config/` module already has SQLite and image storage\n3. **Complements batch ops**: Import images → set-keys → save = powerful workflow\n4. **Reversibility**: Currently the CLI is one-way; this adds the ability to go back\n\n## Technical Challenge: Reading Device State\n**Critical consideration**: Stream Deck hardware does NOT allow reading back key images. We can only:\n- Read current brightness level\n- Read button press events\n\nThis means we have two implementation approaches:\n\n### Approach A: Command History Tracking (Simpler)\nTrack what commands were applied during the session:\n```rust\nstruct SessionState {\n    brightness: Option<u8>,\n    keys: HashMap<u8, KeyState>,  // What we set, not what device has\n}\n\nenum KeyState {\n    Image(PathBuf),    // Source image path\n    Color(String),     // Hex color\n    Cleared,\n}\n```\n- Pro: Simple, works with any command sequence\n- Con: Only tracks current session; loses state on restart\n\n### Approach B: Config-First Workflow (More Robust)\nRequire users to work through config files:\n```bash\nsd apply work.yaml    # Apply a config\nsd save work-mode     # Save the config reference, not device state\nsd restore work-mode  # Re-apply the config\n```\n- Pro: Persistent, declarative, version-controllable\n- Con: Requires config system (#7) first\n\n### Recommended: Hybrid Approach\n1. Track command history during session (immediate value)\n2. When saving, store both the history AND resolved image data\n3. Restore by replaying the history or applying stored images\n\n## Implementation Approach\n```rust\n// In src/config/snapshots.rs (new file)\npub struct Snapshot {\n    pub name: String,\n    pub created_at: DateTime<Utc>,\n    pub brightness: u8,\n    pub keys: Vec<KeySnapshot>,\n}\n\npub struct KeySnapshot {\n    pub index: u8,\n    pub source: KeySource,\n    pub image_data: Option<Vec<u8>>,  // Cached resized image\n}\n\npub enum KeySource {\n    ImageFile(PathBuf),\n    Color(String),\n    Cleared,\n}\n\n// Storage in ~/.local/share/sd/snapshots/\n// - snapshots.db (SQLite index)\n// - images/<sha256>.bin (cached resized images)\n```\n\n## Key Design Decisions\n1. **Name-based access**: Human-readable names, not UUIDs\n2. **Store source AND cached**: Keep original paths for portability, cache for speed\n3. **Graceful degradation**: If source image moved, use cached version\n4. **Atomic restore**: All-or-nothing application\n5. **Conflict handling**: Prompt before overwriting existing snapshot name\n\n## Success Criteria\n- [ ] `sd save <name>` captures current tracked state\n- [ ] `sd restore <name>` applies a saved snapshot\n- [ ] `sd snapshots` lists all saved snapshots with metadata\n- [ ] `sd snapshot show <name>` displays snapshot contents\n- [ ] `sd snapshot delete <name>` removes a snapshot\n- [ ] Robot mode returns structured JSON for all operations\n- [ ] Graceful handling when source images are missing\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Save, Restore, Snapshots commands\n- `src/main.rs`: Add command handlers\n- `src/config/snapshots.rs`: New snapshot storage module\n- `src/state.rs`: Session state tracking (new)\n\n## Dependencies\n- Soft dependency on BATCH-OPS: batch operations make saving more useful\n- Soft dependency on DECLARATIVE-CONFIG: config-first workflow is cleaner\n\n## Estimated Subtasks\n1. Design snapshot storage schema\n2. Implement session state tracking\n3. Add save command with state serialization\n4. Add restore command with state application\n5. Add snapshots list command\n6. Add snapshot show/delete commands\n7. Implement image caching for snapshots\n8. Handle missing source images gracefully\n9. Add robot mode output\n10. Write tests","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:59.040775758Z","created_by":"ubuntu","updated_at":"2026-01-21T11:24:40.466488770Z","closed_at":"2026-01-21T11:24:40.466430581Z","close_reason":"All success criteria met: save/restore/snapshots/snapshot-show/snapshot-delete commands implemented. Robot mode JSON output supported. Image caching with SHA256 content-addressable storage. Graceful handling of missing source images with fallback to cache. 49 tests passing. Only remaining child bead is bd-2re (P2 - additional test coverage).","compaction_level":0,"original_size":0,"labels":["cli","config","priority-2","workflow"]}
{"id":"bd-35a","title":"EPIC: Dry-Run Mode for All Mutating Commands","description":"## Overview\n**Rank: #4 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: Very High**\n\nAdd `--dry-run` global flag that shows what would happen without making changes to the device.\n\n## Problem Statement\nUsers experimenting with the CLI (especially AI agents) have no way to preview what a command will do before it executes. This leads to:\n- Trial-and-error workflows on physical hardware\n- Difficulty debugging \"why isnt my image showing?\"\n- Agents making changes without understanding consequences\n- No way to validate commands in CI/CD pipelines without a device\n\n## Solution\nA global `--dry-run` flag that validates and previews all operations:\n```bash\nsd set-key 5 ~/icon.png --dry-run\n# Output:\n# DRY RUN: Would set key 5\n#   Source: /home/user/icon.png (256x256 PNG)\n#   Resize: 72x72 using Lanczos3\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd brightness 80 --dry-run\n# Output:\n# DRY RUN: Would set brightness to 80%\n#   Current: 50% (if readable)\n#   Device: Stream Deck XL (serial: ABC123)\n\nsd set-keys ~/layout/ --dry-run\n# Output:\n# DRY RUN: Would set 24 keys from /home/user/layout/\n#   Key 0: key-00.png (128x128 JPG) → resize to 72x72\n#   Key 1: key-01.png (72x72 PNG) → no resize needed\n#   Key 2: (no file found, would skip)\n#   ...\n```\n\n## Why This Is #4 Priority\n1. **Safety net**: Preview before committing to physical device\n2. **Debugging aid**: See exact image processing that will occur\n3. **Agent-friendly**: Validate operations without side effects\n4. **Low effort**: Simple flag, ~50 lines of code per command\n5. **Universal pattern**: Users immediately understand what --dry-run means\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - global flag\n#[derive(Parser)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Command,\n    \n    /// Preview what would happen without making changes\n    #[arg(long, global = true)]\n    pub dry_run: bool,\n    \n    // ... existing flags\n}\n\n// In main.rs - pass through to handlers\nfn cmd_brightness(device: &Device, level: u8, dry_run: bool, robot: bool) -> Result<()> {\n    if dry_run {\n        let info = DryRunInfo {\n            action: \"set_brightness\",\n            details: BrightnessDetails { level },\n            device: device.info(),\n        };\n        if robot {\n            println\\!(\"{}\", serde_json::to_string(&info)?);\n        } else {\n            println\\!(\"DRY RUN: Would set brightness to {level}%\");\n            println\\!(\"  Device: {} (serial: {})\", \n                device.info().model, \n                device.info().serial);\n        }\n        return Ok(());\n    }\n    device.set_brightness(level)\n}\n\nfn cmd_set_key(\n    device: &Device, \n    key: u8, \n    path: &Path, \n    dry_run: bool,\n    robot: bool\n) -> Result<()> {\n    // Always validate the image (even in dry-run)\n    let img = image::open(path)?;\n    let (w, h) = img.dimensions();\n    let key_size = device.info().key_size();\n    \n    if dry_run {\n        let needs_resize = w \\!= key_size.0 || h \\!= key_size.1;\n        let info = DryRunInfo {\n            action: \"set_key\",\n            details: SetKeyDetails {\n                key,\n                source_path: path.to_path_buf(),\n                source_dimensions: (w, h),\n                target_dimensions: key_size,\n                needs_resize,\n            },\n            device: device.info(),\n        };\n        // Output appropriately\n        return Ok(());\n    }\n    \n    // Actually do it\n    set_key_image(device, key, path)\n}\n```\n\n## Key Design Decisions\n1. **Global flag**: Applies to all mutating commands uniformly\n2. **Full validation**: Dry-run still validates inputs (image exists, parseable, etc.)\n3. **Structured output**: Robot mode gets JSON with full details\n4. **Human-friendly output**: Clear formatting for terminal users\n5. **Early exit**: Dry-run returns after preview, never touches device\n\n## What Dry-Run Shows\nFor each command type:\n- **brightness**: Target level, device info\n- **set-key**: Source path, dimensions, resize behavior, target key\n- **fill-key**: Key index, color value\n- **clear-key/clear-all**: Which keys would be cleared\n- **set-keys**: Full manifest of directory contents and what would happen\n\n## Robot Mode Output Structure\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key\",\n  \"would_succeed\": true,\n  \"details\": {\n    \"key\": 5,\n    \"source\": \"/path/to/image.png\",\n    \"source_dimensions\": [256, 256],\n    \"target_dimensions\": [72, 72],\n    \"resize_required\": true,\n    \"resize_filter\": \"lanczos3\"\n  },\n  \"device\": {\n    \"model\": \"Stream Deck XL\",\n    \"serial\": \"ABC123\",\n    \"key_count\": 32\n  }\n}\n```\n\n## Success Criteria\n- [ ] `--dry-run` flag available on all mutating commands\n- [ ] Dry-run validates inputs without touching device\n- [ ] Human-readable output explains what would happen\n- [ ] Robot mode returns structured JSON with full details\n- [ ] Errors during validation are reported normally\n- [ ] Works even when no device is connected (with limitations)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add global --dry-run flag\n- `src/main.rs`: Add dry_run parameter to all mutating command handlers\n\n## Dependencies\nNone - standalone feature\n\n## Estimated Subtasks\n1. Add global --dry-run flag to CLI\n2. Implement dry-run for brightness command\n3. Implement dry-run for set-key command\n4. Implement dry-run for fill-key command\n5. Implement dry-run for clear-key/clear-all commands\n6. Implement dry-run for set-keys (batch) command\n7. Design and implement robot mode JSON structure\n8. Write tests for dry-run behavior","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:10:57.838742147Z","created_by":"ubuntu","updated_at":"2026-01-19T18:10:57.877812438Z","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-4","safety"]}
{"id":"bd-35j","title":"Implement robot mode JSON output for batch","description":"## Robot Mode JSON Output for Batch Operations\n\n### Output Schema\n\n```json\n{\n  \"command\": \"set_keys\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"device\": {\n    \"model\": \"Stream Deck XL\",\n    \"serial\": \"ABC123456\",\n    \"key_count\": 32,\n    \"key_size\": [72, 72]\n  },\n  \"input\": {\n    \"directory\": \"/path/to/dir\",\n    \"pattern\": \"key-{index}.png\",\n    \"continue_on_error\": true\n  },\n  \"results\": [\n    {\n      \"key\": 0,\n      \"file\": \"key-00.png\",\n      \"success\": true,\n      \"source\": {\n        \"path\": \"/path/to/dir/key-00.png\",\n        \"format\": \"PNG\",\n        \"dimensions\": [256, 256],\n        \"size_bytes\": 45678\n      },\n      \"processing\": {\n        \"resize_required\": true,\n        \"target_dimensions\": [72, 72],\n        \"filter\": \"lanczos3\",\n        \"cache_hit\": false,\n        \"duration_ms\": 45\n      }\n    },\n    {\n      \"key\": 1,\n      \"file\": \"key-01.png\", \n      \"success\": false,\n      \"error\": {\n        \"code\": \"IMAGE_CORRUPTED\",\n        \"message\": \"Failed to decode PNG: invalid header\",\n        \"suggestion\": \"Verify the image is a valid PNG file\"\n      }\n    }\n  ],\n  \"summary\": {\n    \"total_keys\": 32,\n    \"files_found\": 30,\n    \"success\": 28,\n    \"failed\": 2,\n    \"skipped\": 2,\n    \"duration_ms\": 1250\n  },\n  \"performance\": {\n    \"scan_duration_ms\": 15,\n    \"load_duration_ms\": 800,\n    \"resize_duration_ms\": 300,\n    \"transfer_duration_ms\": 135,\n    \"cache_hits\": 5,\n    \"cache_misses\": 25\n  }\n}\n```\n\n### Streaming Output (for progress)\n\nWhen `--robot --stream` is used, emit progress events:\n\n```json\n{\"event\": \"scan_complete\", \"files_found\": 30}\n{\"event\": \"key_start\", \"key\": 0, \"file\": \"key-00.png\"}\n{\"event\": \"key_complete\", \"key\": 0, \"success\": true, \"duration_ms\": 45}\n{\"event\": \"key_start\", \"key\": 1, \"file\": \"key-01.png\"}\n{\"event\": \"key_failed\", \"key\": 1, \"error\": \"IMAGE_CORRUPTED\"}\n...\n{\"event\": \"complete\", \"summary\": {...}}\n```\n\n### Error Codes\n\nStandard error codes for machine parsing:\n- `FILE_NOT_FOUND` - Image file doesn't exist\n- `PERMISSION_DENIED` - Cannot read image file\n- `IMAGE_CORRUPTED` - Image cannot be decoded\n- `IMAGE_FORMAT_UNSUPPORTED` - Format not PNG/JPG/WebP\n- `KEY_OUT_OF_RANGE` - Key index exceeds device capacity\n- `DEVICE_ERROR` - USB communication failure\n\n### Implementation Notes\n\n1. Always include `device` block for context\n2. Always include timing for performance analysis\n3. Include cache statistics for debugging\n4. Error objects always have code, message, and suggestion\n5. Summary must match sum of individual results\n6. All paths should be absolute for unambiguous references","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.744961886Z","created_by":"ubuntu","updated_at":"2026-01-21T10:58:10.559596473Z","closed_at":"2026-01-21T10:58:10.559544826Z","close_reason":"Already implemented with BatchSetKeysResult JSON struct in main.rs","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-35j","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.761750275Z","created_by":"ubuntu"}]}
{"id":"bd-35os","title":"Implement button_event styled output for watch command","description":"# Implement button_event styled output for watch command\n\n## Purpose\nCreate a visually clear, easy-to-scan event stream for the button watch command. Events should be instantly distinguishable (pressed vs released) with timestamps for correlation.\n\n## Target Output (stream)\n```\n───────────────────── Button Events ─────────────────────\n\n  ● Key 5 pressed                           00:00:01.234\n  ○ Key 5 released                          00:00:01.456\n  ● Key 12 pressed                          00:00:02.100\n  ● Key 13 pressed                          00:00:02.150\n  ○ Key 12 released                         00:00:02.300\n  ○ Key 13 released                         00:00:02.500\n\nPress Ctrl+C to stop watching...\n```\n\n## Implementation\n\n### Watch Header Method\n```rust\nimpl HumanOutput {\n    /// Print header for watch command\n    pub fn watch_header(&self) {\n        self.rule(Some(\"Button Events\"));\n        self.newline();\n    }\n    \n    /// Print footer hint for watch command\n    pub fn watch_footer(&self) {\n        self.newline();\n        self.console.print_styled(\n            \"Press Ctrl+C to stop watching...\",\n            self.theme.muted.clone()\n        );\n    }\n}\n```\n\n### button_event Method\n```rust\nfn button_event(&self, event: &ButtonEvent) {\n    let (icon, style) = if event.pressed {\n        (\"●\", self.theme.button_pressed.clone())  // Filled circle, green\n    } else {\n        (\"○\", self.theme.button_released.clone()) // Empty circle, dim\n    };\n    \n    let action = if event.pressed { \"pressed\" } else { \"released\" };\n    let timestamp = format_timestamp_ms(event.timestamp_ms);\n    \n    // Build styled line\n    let mut text = Text::new(\"\");\n    text.append_styled(&format!(\"  {} \", icon), style.clone());\n    text.append_styled(\"Key \", self.theme.label.clone());\n    text.append_styled(&format!(\"{:<2}\", event.key), self.theme.key_index.clone());\n    text.append_styled(&format!(\" {:<8}\", action), style);\n    \n    // Right-align timestamp to fixed position\n    let padding = self.width().saturating_sub(40);\n    text.append_styled(&format!(\"{:>width$}\", timestamp, width = padding), \n        self.theme.muted.clone());\n    \n    self.console.print_text(&text);\n}\n\n/// Format milliseconds as HH:MM:SS.mmm\nfn format_timestamp_ms(ms: u64) -> String {\n    let total_secs = ms / 1000;\n    let millis = ms % 1000;\n    let secs = total_secs % 60;\n    let mins = (total_secs / 60) % 60;\n    let hours = total_secs / 3600;\n    \n    format!(\"{:02}:{:02}:{:02}.{:03}\", hours, mins, secs, millis)\n}\n```\n\n## Design Decisions\n\n### Icons (● vs ○)\n- Filled circle (●) for pressed: Solid, active state\n- Empty circle (○) for released: Open, inactive state\n- Universal symbols that convey state visually\n- Color provides additional differentiation\n\n### Color Coding\n- Pressed: Green (success color) - active, happening now\n- Released: Dim/gray - past event, less important\n- Key index: Amber/warning - stands out for quick identification\n\n### Timestamp Format\n- HH:MM:SS.mmm format is standard and precise\n- Relative to session start (not wall clock) for simpler math\n- Millisecond precision for timing analysis\n- Right-aligned for visual column alignment\n\n### Line Layout\n```\n  ● Key 5  pressed                          00:00:01.234\n  │  │  │  │                                │\n  │  │  │  └─ action (left-padded)          └─ timestamp (right-aligned)\n  │  │  └─ key number (amber, 2-char width)\n  │  └─ label (dim)\n  └─ icon (green/dim)\n```\n\n### Streaming Considerations\n- Each event is a single line (no buffering issues)\n- stdout flush happens naturally after println\n- Events appear in real-time\n- No panel wrapping (would break streaming)\n\n## Watch Command Integration\nThe watch command needs to:\n1. Print header once at start\n2. Print each event as it arrives\n3. Print footer on Ctrl+C (if possible)\n\n```rust\n// In cmd_watch\nif !cli.use_json() {\n    output.watch_header();\n}\n\n// Event loop\nloop {\n    if let Some(event) = read_button_event(&device)? {\n        output.button_event(&event);\n        if args.once {\n            break;\n        }\n    }\n}\n\n// Footer (may not be reached on Ctrl+C)\nif !cli.use_json() {\n    output.watch_footer();\n}\n```\n\n## Testing\n```rust\n#[test]\nfn button_event_pressed_has_filled_icon() {\n    let output = HumanOutput::new(test_console());\n    let event = ButtonEvent { key: 5, pressed: true, timestamp_ms: 1234 };\n    \n    let captured = capture_output(|| output.button_event(&event));\n    \n    assert!(captured.contains(\"●\"));\n    assert!(captured.contains(\"pressed\"));\n}\n\n#[test]\nfn button_event_released_has_empty_icon() {\n    let output = HumanOutput::new(test_console());\n    let event = ButtonEvent { key: 5, pressed: false, timestamp_ms: 1456 };\n    \n    let captured = capture_output(|| output.button_event(&event));\n    \n    assert!(captured.contains(\"○\"));\n    assert!(captured.contains(\"released\"));\n}\n\n#[test]\nfn timestamp_format() {\n    assert_eq!(format_timestamp_ms(0), \"00:00:00.000\");\n    assert_eq!(format_timestamp_ms(1234), \"00:00:01.234\");\n    assert_eq!(format_timestamp_ms(61000), \"00:01:01.000\");\n    assert_eq!(format_timestamp_ms(3661234), \"01:01:01.234\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Pressed events show filled circle (●) in green\n- [ ] Released events show empty circle (○) in dim\n- [ ] Key index is highlighted in amber\n- [ ] Timestamp is right-aligned\n- [ ] Events stream in real-time (no buffering)\n- [ ] Header rule appears at start of watch\n- [ ] Footer hint shows how to stop","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:18.580938247Z","created_by":"ubuntu","updated_at":"2026-01-19T21:48:09.855321022Z","compaction_level":0,"original_size":0,"labels":["button","events","phase-2","rich-rust","watch"],"dependencies":[{"issue_id":"bd-35os","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:07:18.637423607Z","created_by":"ubuntu"},{"issue_id":"bd-35os","depends_on_id":"bd-3k6","type":"blocks","created_at":"2026-01-19T21:48:09.855252763Z","created_by":"ubuntu"},{"issue_id":"bd-35os","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:07:18.632431468Z","created_by":"ubuntu"}]}
{"id":"bd-36gs","title":"Phase 4: Testing and Verification","description":"# Phase 4: Testing and Verification\n\n## Purpose\nComprehensive testing to ensure the rich_rust integration works correctly and doesn't break existing functionality. This phase is CRITICAL because the primary users are AI agents who depend on consistent JSON output.\n\n## Background\nTesting has three main concerns:\n1. Robot mode regression: JSON output must be IDENTICAL to before\n2. Human mode validation: Styled output should render correctly\n3. Environment compliance: NO_COLOR, TTY detection, etc.\n\n## Test Categories\n\n### 1. Robot Mode Regression Tests\n- Verify JSON structure unchanged for all commands\n- Byte-for-byte comparison where possible\n- Schema validation for JSON responses\n\n### 2. Human Mode Visual Tests\n- Capture output and verify key elements present\n- Test theme colors are applied\n- Verify panels, tables, rules render\n\n### 3. Environment Tests\n- NO_COLOR disables all styling\n- Non-TTY output has no ANSI codes\n- FORCE_COLOR overrides detection\n\n### 4. Cross-Platform Tests\n- Works on Linux, macOS, Windows\n- ASCII fallback when Unicode not supported\n- Terminal width detection\n\n## Deliverables\n1. Unit tests for RobotOutput\n2. Unit tests for HumanOutput\n3. Integration tests for full command flow\n4. Environment variable tests\n5. Test utilities for output capture\n\n## Success Criteria\n- [ ] 100% of robot mode JSON structures verified unchanged\n- [ ] Human mode tests cover all output methods\n- [ ] NO_COLOR compliance verified\n- [ ] All tests pass in CI\n- [ ] Test coverage documented","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:09:54.852579134Z","created_by":"ubuntu","updated_at":"2026-01-19T21:09:54.894735677Z","compaction_level":0,"original_size":0,"labels":["phase-4","rich-rust","testing"],"dependencies":[{"issue_id":"bd-36gs","depends_on_id":"bd-1rhq","type":"blocks","created_at":"2026-01-19T21:09:54.894693507Z","created_by":"ubuntu"},{"issue_id":"bd-36gs","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:09:54.888469719Z","created_by":"ubuntu"}]}
{"id":"bd-37o","title":"Add snapshots list command","description":"Implement sd snapshots (list all):\n- Name, creation date, device model, key count\n- Robot mode: JSON array of snapshot objects\n- Human mode: formatted table","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.435833342Z","created_by":"ubuntu","updated_at":"2026-01-21T11:21:10.478327468Z","closed_at":"2026-01-21T11:21:10.478282393Z","close_reason":"Implemented snapshots list command in cmd_snapshots: lists all saved snapshots with name, device model, key count, brightness. Supports --long for detailed output including description and creation date. JSON output for robot mode.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37o","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.445494482Z","created_by":"ubuntu"}]}
{"id":"bd-37v","title":"Add error classification (is_connection_error)","description":"## Purpose\nAdd comprehensive error classification to enable intelligent retry logic and proper error reporting.\n\n## Implementation\n\\`\\`\\`rust\n// src/error.rs\nuse thiserror::Error;\nuse tracing::{debug, error};\n\n/// Main error type for the Stream Deck CLI\n#[derive(Debug, Error)]\npub enum SdError {\n    // === Connection Errors (retryable) ===\n    \n    #[error(\"No Stream Deck device found\")]\n    DeviceNotFound,\n    \n    #[error(\"Device disconnected unexpectedly\")]\n    DeviceDisconnected,\n    \n    #[error(\"USB error: {0}\")]\n    UsbError(String),\n    \n    #[error(\"Device busy (in use by another process)\")]\n    DeviceBusy,\n    \n    #[error(\"USB timeout waiting for device\")]\n    UsbTimeout,\n    \n    // === Hardware Errors (may be retryable) ===\n    \n    #[error(\"Invalid key index: {0} (device has {1} keys)\")]\n    InvalidKey(u8, u8),\n    \n    #[error(\"Hardware communication error: {0}\")]\n    HardwareError(String),\n    \n    // === Configuration Errors (not retryable) ===\n    \n    #[error(\"Configuration parse error: {0}\")]\n    ConfigParse(String),\n    \n    #[error(\"Invalid configuration: {0}\")]\n    ConfigInvalid(String),\n    \n    #[error(\"Configuration file not found: {0}\")]\n    ConfigNotFound(String),\n    \n    // === Image Errors (not retryable) ===\n    \n    #[error(\"Image not found: {0}\")]\n    ImageNotFound(String),\n    \n    #[error(\"Invalid image format: {0}\")]\n    ImageFormat(String),\n    \n    #[error(\"Image processing error: {0}\")]\n    ImageProcessing(String),\n    \n    // === Profile Errors ===\n    \n    #[error(\"Profile not found: {0}\")]\n    ProfileNotFound(String),\n    \n    #[error(\"Invalid profile format: {0}\")]\n    ProfileInvalid(String),\n    \n    // === System Errors ===\n    \n    #[error(\"Permission denied: {0}\")]\n    PermissionDenied(String),\n    \n    #[error(\"I/O error: {0}\")]\n    IoError(#[from] std::io::Error),\n    \n    #[error(\"{0}\")]\n    Other(String),\n}\n\nimpl SdError {\n    /// Check if this error is related to device connection\n    /// These errors may be recoverable by retrying\n    pub fn is_connection_error(&self) -> bool {\n        matches!(\n            self,\n            SdError::DeviceNotFound\n                | SdError::DeviceDisconnected\n                | SdError::UsbError(_)\n                | SdError::DeviceBusy\n                | SdError::UsbTimeout\n        )\n    }\n    \n    /// Check if this error is related to hardware communication\n    /// These may recover with retry or device reset\n    pub fn is_hardware_error(&self) -> bool {\n        matches!(\n            self,\n            SdError::HardwareError(_) | SdError::InvalidKey(_, _)\n        ) || self.is_connection_error()\n    }\n    \n    /// Check if this error is a configuration/user error\n    /// These will not recover from retry\n    pub fn is_config_error(&self) -> bool {\n        matches!(\n            self,\n            SdError::ConfigParse(_)\n                | SdError::ConfigInvalid(_)\n                | SdError::ConfigNotFound(_)\n        )\n    }\n    \n    /// Check if this error is related to images\n    pub fn is_image_error(&self) -> bool {\n        matches!(\n            self,\n            SdError::ImageNotFound(_)\n                | SdError::ImageFormat(_)\n                | SdError::ImageProcessing(_)\n        )\n    }\n    \n    /// Check if retrying might resolve this error\n    pub fn is_retryable(&self) -> bool {\n        self.is_connection_error() || matches!(self, SdError::HardwareError(_))\n    }\n    \n    /// Get suggested retry delay for this error type\n    pub fn suggested_retry_delay(&self) -> Option<std::time::Duration> {\n        use std::time::Duration;\n        \n        match self {\n            SdError::DeviceNotFound => Some(Duration::from_secs(2)),\n            SdError::DeviceDisconnected => Some(Duration::from_secs(1)),\n            SdError::DeviceBusy => Some(Duration::from_millis(500)),\n            SdError::UsbTimeout => Some(Duration::from_millis(100)),\n            SdError::UsbError(_) => Some(Duration::from_secs(1)),\n            SdError::HardwareError(_) => Some(Duration::from_millis(200)),\n            _ => None,\n        }\n    }\n    \n    /// Get a user-friendly suggestion for fixing this error\n    pub fn suggestion(&self) -> Option<&'static str> {\n        match self {\n            SdError::DeviceNotFound => Some(\n                \"Ensure Stream Deck is connected. Try unplugging and reconnecting.\"\n            ),\n            SdError::DeviceDisconnected => Some(\n                \"Device was disconnected. Reconnect and try again.\"\n            ),\n            SdError::DeviceBusy => Some(\n                \"Device is in use by another program. Close the Elgato software or other sd instances.\"\n            ),\n            SdError::PermissionDenied(_) => Some(\n                \"Add udev rules for Stream Deck or run with sudo. See: https://github.com/streamdeck-linux-gui/streamdeck-linux-gui#udev-rules\"\n            ),\n            SdError::InvalidKey(key, count) => Some(\n                \"Key index out of range. Use 'sd info' to see valid key indices for your device.\"\n            ),\n            SdError::ImageNotFound(_) => Some(\n                \"Check the file path. Use absolute paths or paths relative to current directory.\"\n            ),\n            SdError::ImageFormat(_) => Some(\n                \"Supported formats: PNG, JPEG, GIF, BMP. Ensure the file is a valid image.\"\n            ),\n            SdError::ConfigParse(_) => Some(\n                \"Check YAML/TOML syntax. Use 'sd validate config.yaml' to check.\"\n            ),\n            _ => None,\n        }\n    }\n    \n    /// Convert from hidapi error\n    pub fn from_hid_error(e: impl std::fmt::Display) -> Self {\n        let msg = e.to_string();\n        if msg.contains(\"not found\") || msg.contains(\"No such device\") {\n            SdError::DeviceNotFound\n        } else if msg.contains(\"busy\") || msg.contains(\"in use\") {\n            SdError::DeviceBusy\n        } else if msg.contains(\"permission\") || msg.contains(\"access\") {\n            SdError::PermissionDenied(msg)\n        } else if msg.contains(\"timeout\") {\n            SdError::UsbTimeout\n        } else {\n            SdError::UsbError(msg)\n        }\n    }\n}\n\n/// Result type alias\npub type Result<T> = std::result::Result<T, SdError>;\n\n/// Robot mode error output\n#[derive(serde::Serialize)]\npub struct ErrorResponse {\n    pub error: String,\n    pub error_type: String,\n    pub retryable: bool,\n    pub suggestion: Option<String>,\n    pub details: Option<serde_json::Value>,\n}\n\nimpl From<&SdError> for ErrorResponse {\n    fn from(e: &SdError) -> Self {\n        Self {\n            error: e.to_string(),\n            error_type: error_type_name(e),\n            retryable: e.is_retryable(),\n            suggestion: e.suggestion().map(String::from),\n            details: None,\n        }\n    }\n}\n\nfn error_type_name(e: &SdError) -> String {\n    match e {\n        SdError::DeviceNotFound => \"device_not_found\",\n        SdError::DeviceDisconnected => \"device_disconnected\",\n        SdError::UsbError(_) => \"usb_error\",\n        SdError::DeviceBusy => \"device_busy\",\n        SdError::UsbTimeout => \"usb_timeout\",\n        SdError::InvalidKey(_, _) => \"invalid_key\",\n        SdError::HardwareError(_) => \"hardware_error\",\n        SdError::ConfigParse(_) => \"config_parse\",\n        SdError::ConfigInvalid(_) => \"config_invalid\",\n        SdError::ConfigNotFound(_) => \"config_not_found\",\n        SdError::ImageNotFound(_) => \"image_not_found\",\n        SdError::ImageFormat(_) => \"image_format\",\n        SdError::ImageProcessing(_) => \"image_processing\",\n        SdError::ProfileNotFound(_) => \"profile_not_found\",\n        SdError::ProfileInvalid(_) => \"profile_invalid\",\n        SdError::PermissionDenied(_) => \"permission_denied\",\n        SdError::IoError(_) => \"io_error\",\n        SdError::Other(_) => \"other\",\n    }.to_string()\n}\n\\`\\`\\`\n\n## Unit Tests\n\\`\\`\\`rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_connection_errors() {\n        assert!(SdError::DeviceNotFound.is_connection_error());\n        assert!(SdError::DeviceDisconnected.is_connection_error());\n        assert!(SdError::UsbError(\"test\".to_string()).is_connection_error());\n        assert!(SdError::DeviceBusy.is_connection_error());\n        assert!(SdError::UsbTimeout.is_connection_error());\n        \n        assert!(!SdError::ConfigParse(\"test\".to_string()).is_connection_error());\n        assert!(!SdError::ImageNotFound(\"test\".to_string()).is_connection_error());\n    }\n    \n    #[test]\n    fn test_retryable() {\n        assert!(SdError::DeviceNotFound.is_retryable());\n        assert!(SdError::HardwareError(\"test\".to_string()).is_retryable());\n        \n        assert!(!SdError::ConfigParse(\"test\".to_string()).is_retryable());\n        assert!(!SdError::InvalidKey(50, 32).is_retryable());\n    }\n    \n    #[test]\n    fn test_suggestions() {\n        assert!(SdError::DeviceNotFound.suggestion().is_some());\n        assert!(SdError::PermissionDenied(\"test\".to_string()).suggestion().is_some());\n    }\n    \n    #[test]\n    fn test_retry_delays() {\n        assert!(SdError::DeviceNotFound.suggested_retry_delay().is_some());\n        assert!(SdError::ConfigParse(\"test\".to_string()).suggested_retry_delay().is_none());\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] All error types properly categorized\n- [ ] is_connection_error correctly identifies USB errors\n- [ ] is_retryable provides accurate retry guidance\n- [ ] Suggestions are helpful and actionable\n- [ ] Robot mode error output is well-structured\n- [ ] hidapi errors properly converted\n\n## Logging Requirements\n- TRACE: (none - error creation doesn't log)\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: When errors are displayed to user","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:24.493253348Z","created_by":"ubuntu","updated_at":"2026-01-21T09:55:28.320565265Z","closed_at":"2026-01-21T09:55:28.320508789Z","close_reason":"Added error classification helpers and tests","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-37v","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:24.509339205Z","created_by":"ubuntu"}]}
{"id":"bd-38o","title":"Test generated completions for zsh","description":"Manual testing (macOS/Linux with zsh):\n1. Generate: sd completions zsh > /tmp/_sd\n2. Add to fpath and compinit\n3. Test completion behavior\n4. Verify no errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.874093064Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:11.019910508Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38o","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:11.019858330Z","created_by":"ubuntu"},{"issue_id":"bd-38o","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.884045513Z","created_by":"ubuntu"}]}
{"id":"bd-38v","title":"Implement device_list rich output with Panel and styled cards","description":"# Implement device_list rich output with Panel and styled cards\n\n## Purpose\nTransform the device list output from plain text to a beautiful panel containing styled device cards. This is often the first command users run, so it sets the visual tone for the entire CLI.\n\n## Target Output\n```\n┌─────────────────── Stream Deck Devices ───────────────────┐\n│                                                           │\n│  1. Stream Deck XL                                        │\n│     Serial: AL12U1E1234                                   │\n│     Keys: 32 (8×4)  │  Firmware: 1.5.3                    │\n│                                                           │\n│  2. Stream Deck Mini                                      │\n│     Serial: AL12U1E5678                                   │\n│     Keys: 6 (3×2)   │  Firmware: 1.2.1                    │\n│                                                           │\n└───────────────────────────────────────────────────────────┘\n```\n\n## Empty State\n```\n┌─────────────────── Stream Deck Devices ───────────────────┐\n│                                                           │\n│  No devices found                                         │\n│                                                           │\n│  Ensure Stream Deck is connected via USB                  │\n│                                                           │\n└───────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### HumanOutput::device_list Method\n```rust\nfn device_list(&self, devices: &[DeviceInfo]) {\n    if devices.is_empty() {\n        // Empty state panel\n        let mut content = Text::new(\"\");\n        content.append_styled(\"  No devices found\\n\\n\", Style::new().italic());\n        content.append_styled(\"  Ensure Stream Deck is connected via USB\\n\", \n            self.theme.muted.clone());\n        \n        let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n            .title(\"Stream Deck Devices\")\n            .border_style(Style::new().color(self.theme.warning.clone()))\n            .rounded();\n        \n        self.console.print_renderable(&panel);\n        return;\n    }\n    \n    // Build content with device cards\n    let mut content = Text::new(\"\");\n    \n    for (i, device) in devices.iter().enumerate() {\n        // Device number and name (header style)\n        content.append_styled(\n            &format!(\"  {}. {}\\n\", i + 1, device.product_name),\n            self.theme.header.clone()\n        );\n        \n        // Serial (indented, muted)\n        content.append_styled(\"     Serial: \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", device.serial), \n            self.theme.device_serial.clone());\n        \n        // Keys and firmware on same line\n        content.append_styled(\"     Keys: \", self.theme.label.clone());\n        content.append_styled(\n            &format!(\"{} ({}×{})\", device.key_count, device.cols, device.rows),\n            self.theme.value.clone()\n        );\n        content.append_styled(\"  │  \", self.theme.muted.clone());\n        content.append_styled(\"Firmware: \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\", device.firmware_version), \n            self.theme.value.clone());\n        \n        // Add spacing between devices (except last)\n        if i < devices.len() - 1 {\n            content.append(\"\\n\\n\");\n        } else {\n            content.append(\"\\n\");\n        }\n    }\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"Stream Deck Devices\")\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n## Design Decisions\n\n### Why Panel Instead of Table?\n- Devices have varying amounts of information\n- Card-style layout is more scannable for 1-3 items\n- Table would have many empty cells or awkward layout\n- Panel creates visual grouping that feels cohesive\n\n### Information Display\n- Number prefix (1., 2.) helps when multiple devices\n- Product name is most prominent (it's what users recognize)\n- Serial is secondary (needed for --serial flag)\n- Keys and firmware are tertiary but useful\n\n### Empty State\n- Proactive helpful message instead of just \"No devices\"\n- Suggests the most common fix (USB connection)\n- Uses warning color to draw attention without alarm\n\n### Spacing\n- Blank line between devices for visual separation\n- Consistent indentation (5 spaces for detail lines)\n- Trailing newline inside panel for padding\n\n## Edge Cases\n- Single device: Panel still looks good\n- Many devices (5+): Panel grows but stays readable\n- Long serial numbers: Will wrap within panel width\n- Terminal too narrow: Content will wrap gracefully\n\n## Testing\n```rust\n#[test]\nfn device_list_multiple_devices() {\n    let console = test_console();\n    let output = HumanOutput::new(console);\n    \n    let devices = vec![\n        DeviceInfo { product_name: \"Stream Deck XL\".into(), ... },\n        DeviceInfo { product_name: \"Stream Deck Mini\".into(), ... },\n    ];\n    \n    // Visual verification - capture and check key elements\n    output.device_list(&devices);\n    // Verify panel title, device names, serials appear\n}\n```\n\n## Acceptance Criteria\n- [ ] Device list renders in styled panel\n- [ ] Empty state shows helpful message\n- [ ] Multiple devices display as distinct cards\n- [ ] Colors match theme specification\n- [ ] Output adapts to terminal width\n- [ ] Border uses rounded style","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:05:28.940504592Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:28.990692797Z","compaction_level":0,"original_size":0,"labels":["device","list","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-38v","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:05:28.990654354Z","created_by":"ubuntu"},{"issue_id":"bd-38v","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:05:28.985990724Z","created_by":"ubuntu"}]}
{"id":"bd-38x","title":"Add restore command with state application","description":"## Purpose\nImplement the `sd restore <name>` command to apply a saved snapshot to the device.\n\n## CLI Definition\n```rust\n#[derive(Parser, Debug)]\npub struct RestoreCommand {\n    /// Name of the snapshot to restore\n    #[arg(value_name = \"NAME\")]\n    pub name: String,\n    \n    /// Restore only specific keys (space-separated indices)\n    #[arg(long, short = 'k')]\n    pub keys: Vec<u8>,\n    \n    /// Skip brightness restoration\n    #[arg(long)]\n    pub no_brightness: bool,\n    \n    /// Continue restoring other keys if one fails\n    #[arg(long, short = 'c')]\n    pub continue_on_error: bool,\n    \n    /// Force restore even if device model differs\n    #[arg(long)]\n    pub force: bool,\n    \n    /// Show what would be restored without applying\n    #[arg(long)]\n    pub dry_run: bool,\n}\n```\n\n## Implementation\n```rust\n// src/cli/restore.rs\nuse crate::snapshot::{SnapshotDb, Snapshot, KeyState};\nuse tracing::{debug, info, warn, error, instrument};\n\n#[instrument(skip(device, opts))]\npub async fn cmd_restore(\n    device: &mut Device,\n    cmd: &RestoreCommand,\n    opts: &GlobalOpts,\n) -> Result<()> {\n    let db = SnapshotDb::open()?;\n    \n    // Load snapshot\n    let snapshot = db.load_snapshot(&cmd.name)?\n        .ok_or_else(|| SdError::ProfileNotFound(cmd.name.clone()))?;\n    \n    let device_info = device.info();\n    \n    // Check device compatibility\n    if snapshot.key_count != device_info.key_count && !cmd.force {\n        return Err(SdError::ConfigInvalid(format!(\n            \"Snapshot has {} keys but device has {}. Use --force to restore anyway.\",\n            snapshot.key_count, device_info.key_count\n        )));\n    }\n    \n    // Check device model\n    let device_model = format!(\"{:?}\", device_info.model);\n    if snapshot.device_model != device_model && !cmd.force {\n        warn!(\n            snapshot_model = %snapshot.device_model,\n            device_model = %device_model,\n            \"Device model mismatch\"\n        );\n    }\n    \n    // Filter keys if specified\n    let keys_to_restore: Vec<_> = if !cmd.keys.is_empty() {\n        snapshot.keys.iter()\n            .filter(|k| cmd.keys.contains(&k.key_index))\n            .collect()\n    } else {\n        snapshot.keys.iter().collect()\n    };\n    \n    // Dry run mode\n    if cmd.dry_run {\n        return output_dry_run(&snapshot, &keys_to_restore, opts);\n    }\n    \n    // Restore brightness first\n    if !cmd.no_brightness {\n        if let Some(brightness) = snapshot.brightness {\n            info!(brightness = %brightness, \"Restoring brightness\");\n            device.set_brightness(brightness).await?;\n        }\n    }\n    \n    // Restore each key\n    let mut results = Vec::new();\n    let mut succeeded = 0;\n    let mut failed = 0;\n    \n    for key in &keys_to_restore {\n        let result = restore_key(device, &db, key).await;\n        \n        match &result {\n            Ok(()) => {\n                debug!(key = %key.key_index, \"Key restored\");\n                succeeded += 1;\n            }\n            Err(e) => {\n                warn!(key = %key.key_index, error = %e, \"Key restore failed\");\n                failed += 1;\n                if !cmd.continue_on_error {\n                    return Err(e.clone());\n                }\n            }\n        }\n        \n        results.push(KeyRestoreResult {\n            key: key.key_index,\n            status: if result.is_ok() { \"restored\" } else { \"failed\" },\n            error: result.err().map(|e| e.to_string()),\n        });\n    }\n    \n    info!(\n        name = %cmd.name,\n        succeeded = %succeeded,\n        failed = %failed,\n        \"Snapshot restore complete\"\n    );\n    \n    // Output\n    if opts.robot {\n        println!(\"{}\", serde_json::to_string(&RestoreResponse {\n            command: \"restore\",\n            snapshot: cmd.name.clone(),\n            results,\n            summary: RestoreSummary {\n                total: keys_to_restore.len(),\n                succeeded,\n                failed,\n            },\n        })?);\n    } else {\n        println!(\n            \"Restored snapshot '{}': {} keys succeeded, {} failed\",\n            cmd.name, succeeded, failed\n        );\n    }\n    \n    Ok(())\n}\n\nasync fn restore_key(\n    device: &mut Device,\n    db: &SnapshotDb,\n    key: &SnapshotKey,\n) -> Result<()> {\n    match &key.state {\n        KeyState::Image { image_hash, .. } => {\n            let image_data = db.load_image(image_hash)?\n                .ok_or_else(|| SdError::ImageNotFound(image_hash.clone()))?;\n            device.set_key_image_raw(key.key_index, &image_data).await\n        }\n        KeyState::Color { hex } => {\n            let (r, g, b) = parse_hex_color(hex)?;\n            device.fill_key_color(key.key_index, r, g, b).await\n        }\n        KeyState::Clear => {\n            device.clear_key(key.key_index).await\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct RestoreResponse {\n    command: &'static str,\n    snapshot: String,\n    results: Vec<KeyRestoreResult>,\n    summary: RestoreSummary,\n}\n\n#[derive(Serialize)]\nstruct KeyRestoreResult {\n    key: u8,\n    status: &'static str,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    error: Option<String>,\n}\n\n#[derive(Serialize)]\nstruct RestoreSummary {\n    total: usize,\n    succeeded: usize,\n    failed: usize,\n}\n```\n\n## Robot Mode Output (Success)\n```json\n{\n  \"command\": \"restore\",\n  \"snapshot\": \"work-layout\",\n  \"results\": [\n    {\"key\": 0, \"status\": \"restored\"},\n    {\"key\": 1, \"status\": \"restored\"},\n    {\"key\": 5, \"status\": \"failed\", \"error\": \"Image not found in cache\"}\n  ],\n  \"summary\": {\n    \"total\": 24,\n    \"succeeded\": 23,\n    \"failed\": 1\n  }\n}\n```\n\n## Robot Mode Output (Dry Run)\n```json\n{\n  \"dry_run\": true,\n  \"command\": \"restore\",\n  \"snapshot\": \"work-layout\",\n  \"would_restore\": {\n    \"brightness\": 80,\n    \"keys\": [\n      {\"key\": 0, \"type\": \"image\", \"source\": \"/path/to/icon.png\"},\n      {\"key\": 1, \"type\": \"color\", \"hex\": \"#FF0000\"},\n      {\"key\": 2, \"type\": \"clear\"}\n    ]\n  },\n  \"compatibility\": {\n    \"model_match\": true,\n    \"key_count_match\": true\n  }\n}\n```\n\n## Error Cases\n```json\n{\n  \"error\": \"Snapshot 'missing' not found\",\n  \"error_type\": \"profile_not_found\"\n}\n```\n\n## Logging Requirements\n- TRACE: Individual key restore operations\n- DEBUG: Image loading, color parsing\n- INFO: Restore start/complete with stats\n- WARN: Model mismatch, individual key failures with continue-on-error\n- ERROR: Snapshot not found, fatal failures\n\n## Success Criteria\n- [ ] Loads and applies snapshot correctly\n- [ ] Checks device compatibility\n- [ ] Respects --keys filter\n- [ ] Handles --continue-on-error\n- [ ] Dry run shows what would happen\n- [ ] Robot mode outputs per-key results\n- [ ] Human mode shows progress","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.312916003Z","created_by":"ubuntu","updated_at":"2026-01-21T11:21:02.724104520Z","closed_at":"2026-01-21T11:21:02.724018599Z","close_reason":"Implemented restore command in cmd_restore: loads snapshot from database, applies brightness if present, applies key states (images from cache/source, colors, clears), tracks state changes, supports --no-brightness flag, validates device compatibility.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-38x","depends_on_id":"bd-2qo","type":"blocks","created_at":"2026-01-19T22:07:01.456768647Z","created_by":"ubuntu"},{"issue_id":"bd-38x","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.322663555Z","created_by":"ubuntu"},{"issue_id":"bd-38x","depends_on_id":"bd-3j5","type":"blocks","created_at":"2026-01-19T22:07:03.839216201Z","created_by":"ubuntu"}]}
{"id":"bd-3a2","title":"Implement keymap file loading","description":"Support --keymap <file.yaml>:\n```yaml\nkeys:\n  0:\n    press: open -a Chrome\n    release: null\n  8-15:\n    press: ~/scripts/macro-{key}.sh\n```\n\nReuse KeySelector from declarative config.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:20.205128062Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:20.223338890Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3a2","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:20.223284417Z","created_by":"ubuntu"}]}
{"id":"bd-3ab","title":"Add debouncing logic","description":"Prevent rapid re-applies:\n- Track last apply timestamp\n- Ignore events within debounce window (default 500ms)\n- Configurable via --debounce flag\n\nSome editors save multiple times (backup, then real).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:34.290122116Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:34.300511167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ab","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:34.300472524Z","created_by":"ubuntu"}]}
{"id":"bd-3aj","title":"Implement basic bash export","description":"## Purpose\nGenerate a valid, executable bash script that reproduces the current device state.\n\n## Implementation\n```rust\n// src/export/bash.rs\nuse std::path::Path;\nuse tracing::{debug, trace, info, instrument};\nuse crate::state::{SessionState, KeyState};\n\n/// Options for bash script generation\npub struct BashExportOptions {\n    /// Include shebang and set -e\n    pub include_header: bool,\n    /// Use absolute paths for images\n    pub absolute_paths: bool,\n    /// Include comments explaining each line\n    pub verbose_comments: bool,\n    /// Target device serial (for multi-device setups)\n    pub device_serial: Option<String>,\n}\n\nimpl Default for BashExportOptions {\n    fn default() -> Self {\n        Self {\n            include_header: true,\n            absolute_paths: true,\n            verbose_comments: false,\n            device_serial: None,\n        }\n    }\n}\n\n/// Generate a bash script from session state\n#[instrument(skip(state))]\npub fn generate_bash_script(state: &SessionState, opts: &BashExportOptions) -> String {\n    let mut lines = Vec::new();\n    \n    if opts.include_header {\n        lines.push(\"#!/bin/bash\".to_string());\n        lines.push(\"# Stream Deck configuration exported by sd\".to_string());\n        lines.push(format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()));\n        if let Some(ref serial) = opts.device_serial {\n            lines.push(format!(\"# Device serial: {}\", serial));\n        }\n        lines.push(\"\".to_string());\n        lines.push(\"set -e  # Exit on first error\".to_string());\n        lines.push(\"\".to_string());\n    }\n    \n    // Device selection (if specified)\n    let device_flag = opts.device_serial.as_ref()\n        .map(|s| format!(\" --serial \\\"{}\\\"\", s))\n        .unwrap_or_default();\n    \n    // Brightness command\n    if let Some(brightness) = state.brightness {\n        if opts.verbose_comments {\n            lines.push(format!(\"# Set display brightness to {}%\", brightness));\n        }\n        lines.push(format!(\"sd{} brightness {}\", device_flag, brightness));\n        trace!(brightness = %brightness, \"Added brightness command\");\n    }\n    \n    // Collect keys by type for organized output\n    let mut image_keys: Vec<(u8, &Path)> = Vec::new();\n    let mut color_keys: Vec<(u8, &str)> = Vec::new();\n    let mut cleared_keys: Vec<u8> = Vec::new();\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => image_keys.push((*key, path)),\n            KeyState::Color(color) => color_keys.push((*key, color)),\n            KeyState::Cleared => cleared_keys.push(*key),\n        }\n    }\n    \n    // Sort for consistent output\n    image_keys.sort_by_key(|(k, _)| *k);\n    color_keys.sort_by_key(|(k, _)| *k);\n    cleared_keys.sort();\n    \n    // Image keys\n    if !image_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Set key images\".to_string());\n        }\n        \n        for (key, path) in image_keys {\n            let path_str = if opts.absolute_paths {\n                path.canonicalize()\n                    .map(|p| p.display().to_string())\n                    .unwrap_or_else(|_| path.display().to_string())\n            } else {\n                path.display().to_string()\n            };\n            \n            // Properly escape the path for bash\n            let escaped_path = escape_bash_string(&path_str);\n            lines.push(format!(\"sd{} set-key {} {}\", device_flag, key, escaped_path));\n            trace!(key = %key, path = %path_str, \"Added set-key command\");\n        }\n    }\n    \n    // Color keys\n    if !color_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Fill keys with solid colors\".to_string());\n        }\n        \n        for (key, color) in color_keys {\n            lines.push(format!(\"sd{} fill-key {} \\\"{}\\\"\", device_flag, key, color));\n            trace!(key = %key, color = %color, \"Added fill-key command\");\n        }\n    }\n    \n    // Cleared keys\n    if !cleared_keys.is_empty() {\n        lines.push(\"\".to_string());\n        if opts.verbose_comments {\n            lines.push(\"# Clear unused keys\".to_string());\n        }\n        \n        for key in cleared_keys {\n            lines.push(format!(\"sd{} clear-key {}\", device_flag, key));\n            trace!(key = %key, \"Added clear-key command\");\n        }\n    }\n    \n    // Footer\n    lines.push(\"\".to_string());\n    lines.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    info!(\n        brightness = ?state.brightness,\n        key_count = %state.keys.len(),\n        \"Generated bash script\"\n    );\n    \n    lines.join(\"\\n\")\n}\n\n/// Escape a string for safe use in bash\nfn escape_bash_string(s: &str) -> String {\n    // If no special characters, no quoting needed\n    if s.chars().all(|c| c.is_alphanumeric() || c == '/' || c == '.' || c == '-' || c == '_') {\n        return s.to_string();\n    }\n    \n    // Use double quotes and escape special chars\n    let escaped = s\n        .replace('\\\\', \"\\\\\\\\\")\n        .replace('\"', \"\\\\\\\"\")\n        .replace('$', \"\\\\$\")\n        .replace('`', \"\\\\`\")\n        .replace('!', \"\\\\!\");\n    \n    format!(\"\\\"{}\\\"\", escaped)\n}\n\n/// Robot mode output structure\n#[derive(serde::Serialize)]\npub struct ExportResult {\n    pub format: String,\n    pub script: String,\n    pub commands_count: usize,\n    pub brightness_set: bool,\n    pub keys_with_images: usize,\n    pub keys_with_colors: usize,\n    pub keys_cleared: usize,\n}\n\nimpl ExportResult {\n    pub fn from_state(state: &SessionState, script: String) -> Self {\n        let (images, colors, cleared) = state.keys.values().fold(\n            (0, 0, 0),\n            |(i, c, cl), ks| match ks {\n                KeyState::Image(_) => (i + 1, c, cl),\n                KeyState::Color(_) => (i, c + 1, cl),\n                KeyState::Cleared => (i, c, cl + 1),\n            },\n        );\n        \n        Self {\n            format: \"bash\".to_string(),\n            script,\n            commands_count: state.keys.len() + state.brightness.map(|_| 1).unwrap_or(0),\n            brightness_set: state.brightness.is_some(),\n            keys_with_images: images,\n            keys_with_colors: colors,\n            keys_cleared: cleared,\n        }\n    }\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    \n    fn sample_state() -> SessionState {\n        let mut keys = HashMap::new();\n        keys.insert(0, KeyState::Image(PathBuf::from(\"/home/user/icons/chrome.png\")));\n        keys.insert(1, KeyState::Color(\"#FF5500\".to_string()));\n        keys.insert(31, KeyState::Cleared);\n        \n        SessionState {\n            brightness: Some(80),\n            keys,\n        }\n    }\n    \n    #[test]\n    fn test_basic_export() {\n        let state = sample_state();\n        let script = generate_bash_script(&state, &BashExportOptions::default());\n        \n        assert!(script.contains(\"#!/bin/bash\"));\n        assert!(script.contains(\"set -e\"));\n        assert!(script.contains(\"sd brightness 80\"));\n        assert!(script.contains(\"sd set-key 0\"));\n        assert!(script.contains(\"sd fill-key 1 \\\"#FF5500\\\"\"));\n        assert!(script.contains(\"sd clear-key 31\"));\n    }\n    \n    #[test]\n    fn test_path_escaping() {\n        assert_eq!(escape_bash_string(\"/simple/path.png\"), \"/simple/path.png\");\n        assert_eq!(escape_bash_string(\"/path with spaces/file.png\"), \"\\\"/path with spaces/file.png\\\"\");\n        assert_eq!(escape_bash_string(\"/path\\\"with\\\"quotes.png\"), \"\\\"/path\\\\\\\"with\\\\\\\"quotes.png\\\"\");\n    }\n    \n    #[test]\n    fn test_empty_state() {\n        let state = SessionState::default();\n        let script = generate_bash_script(&state, &BashExportOptions::default());\n        \n        assert!(script.contains(\"#!/bin/bash\"));\n        assert!(script.contains(\"Configuration applied successfully\"));\n        // Should not contain any sd commands except echo\n        assert!(!script.contains(\"sd brightness\"));\n        assert!(!script.contains(\"sd set-key\"));\n    }\n    \n    #[test]\n    fn test_device_serial_flag() {\n        let mut state = SessionState::default();\n        state.brightness = Some(50);\n        \n        let opts = BashExportOptions {\n            device_serial: Some(\"ABC123\".to_string()),\n            ..Default::default()\n        };\n        \n        let script = generate_bash_script(&state, &opts);\n        assert!(script.contains(\"sd --serial \\\"ABC123\\\" brightness 50\"));\n    }\n}\n```\n\n## Success Criteria\n- [ ] Generated script has valid bash syntax\n- [ ] Shebang and set -e included by default\n- [ ] Absolute paths used by default\n- [ ] Paths properly quoted/escaped for bash\n- [ ] Keys grouped by type (images, colors, cleared)\n- [ ] Device serial flag included when specified\n- [ ] Robot mode returns structured JSON with script\n\n## Logging Requirements\n- TRACE: Each command added to script\n- DEBUG: (none - generation is straightforward)\n- INFO: Script generated with summary stats\n- WARN: (none)\n- ERROR: (none - errors bubble up)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:01.820883805Z","created_by":"ubuntu","updated_at":"2026-01-19T20:51:11.076670486Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3aj","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:01.830765861Z","created_by":"ubuntu"}]}
{"id":"bd-3av","title":"Embed static files in binary","description":"Use rust-embed crate:\n```rust\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\nstruct Assets;\n```\n\nSingle binary deployment with embedded frontend.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:50.191473983Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:50.204423324Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3av","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:50.204358191Z","created_by":"ubuntu"}]}
{"id":"bd-3c2","title":"Add CLI flags for gesture thresholds","description":"## Purpose\nAdd CLI flags to configure gesture detection thresholds in the watch command.\n\n## Implementation\n\\`\\`\\`rust\n// In src/cli.rs - WatchCommand\n#[derive(Parser, Debug)]\npub struct WatchCommand {\n    /// Enable gesture detection (tap, double-tap, long-press, hold)\n    #[arg(long, default_value = \"false\")]\n    pub gestures: bool,\n    \n    /// Long press threshold in milliseconds [default: 800]\n    #[arg(long, value_name = \"MS\", default_value = \"800\")]\n    pub long_press_ms: u64,\n    \n    /// Double tap detection window in milliseconds [default: 300]\n    #[arg(long, value_name = \"MS\", default_value = \"300\")]\n    pub double_tap_ms: u64,\n    \n    /// Hold tick interval in milliseconds [default: 100]\n    #[arg(long, value_name = \"MS\", default_value = \"100\")]\n    pub hold_tick_ms: u64,\n    \n    // ... existing fields (exec, on-press, on-release, keymap)\n}\n\\`\\`\\`\n\n### Help Text\n\\`\\`\\`\nsd watch --help\n\nOPTIONS:\n    --gestures              Enable gesture detection (tap, double-tap, long-press, hold)\n    --long-press-ms <MS>    Long press threshold [default: 800]\n                            Holding a key longer than this triggers a long-press event\n    --double-tap-ms <MS>    Double tap detection window [default: 300]\n                            Two taps within this window trigger a double-tap event\n    --hold-tick-ms <MS>     Hold tick interval [default: 100]\n                            How often hold-tick events fire while key is held\n\\`\\`\\`\n\n### Integration with GestureDetector\n\\`\\`\\`rust\n// In watch command handler\nasync fn cmd_watch(opts: WatchCommand, device: Device) -> Result<()> {\n    let gesture_detector = if opts.gestures {\n        let config = GestureConfig {\n            long_press_threshold: Duration::from_millis(opts.long_press_ms),\n            double_tap_window: Duration::from_millis(opts.double_tap_ms),\n            hold_tick_interval: Duration::from_millis(opts.hold_tick_ms),\n        };\n        info!(\n            long_press_ms = %opts.long_press_ms,\n            double_tap_ms = %opts.double_tap_ms,\n            hold_tick_ms = %opts.hold_tick_ms,\n            \"Gesture detection enabled\"\n        );\n        Some(GestureDetector::new(config))\n    } else {\n        debug!(\"Gesture detection disabled\");\n        None\n    };\n    \n    // ... watch loop with gesture detector\n}\n\\`\\`\\`\n\n### Robot Mode Output with Gestures\n\\`\\`\\`json\n// Without gestures\n{\"event\": \"key_press\", \"key\": 5, \"timestamp\": \"2024-01-15T10:30:00Z\"}\n{\"event\": \"key_release\", \"key\": 5, \"timestamp\": \"2024-01-15T10:30:00.150Z\"}\n\n// With gestures enabled\n{\"event\": \"key_press\", \"key\": 5, \"timestamp\": \"2024-01-15T10:30:00Z\"}\n{\"event\": \"key_release\", \"key\": 5, \"timestamp\": \"2024-01-15T10:30:00.150Z\"}\n{\"event\": \"gesture\", \"type\": \"tap\", \"key\": 5, \"timestamp\": \"2024-01-15T10:30:00.450Z\"}\n\n// Double tap\n{\"event\": \"gesture\", \"type\": \"double_tap\", \"key\": 5, \"interval_ms\": 200, \"timestamp\": \"...\"}\n\n// Long press\n{\"event\": \"gesture\", \"type\": \"long_press\", \"key\": 5, \"duration_ms\": 1200, \"timestamp\": \"...\"}\n\n// Hold sequence\n{\"event\": \"gesture\", \"type\": \"hold_start\", \"key\": 5, \"timestamp\": \"...\"}\n{\"event\": \"gesture\", \"type\": \"hold_tick\", \"key\": 5, \"held_for_ms\": 900, \"timestamp\": \"...\"}\n{\"event\": \"gesture\", \"type\": \"hold_tick\", \"key\": 5, \"held_for_ms\": 1000, \"timestamp\": \"...\"}\n{\"event\": \"gesture\", \"type\": \"hold_end\", \"key\": 5, \"total_ms\": 1150, \"timestamp\": \"...\"}\n\\`\\`\\`\n\n### Validation\n\\`\\`\\`rust\nimpl WatchCommand {\n    pub fn validate(&self) -> Result<(), ConfigError> {\n        // Warn about unusual values\n        if self.long_press_ms < 200 {\n            warn!(\"Long press threshold very low ({} ms) - may cause false triggers\", self.long_press_ms);\n        }\n        if self.long_press_ms > 5000 {\n            warn!(\"Long press threshold very high ({} ms) - difficult to trigger\", self.long_press_ms);\n        }\n        if self.double_tap_ms < 100 {\n            warn!(\"Double tap window very short ({} ms) - difficult to trigger\", self.double_tap_ms);\n        }\n        if self.double_tap_ms > 1000 {\n            warn!(\"Double tap window very long ({} ms) - may cause delays\", self.double_tap_ms);\n        }\n        if self.hold_tick_ms < 50 {\n            warn!(\"Hold tick interval very short ({} ms) - high event frequency\", self.hold_tick_ms);\n        }\n        \n        Ok(())\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] --gestures flag enables gesture detection\n- [ ] --long-press-ms configures threshold\n- [ ] --double-tap-ms configures window\n- [ ] --hold-tick-ms configures tick interval\n- [ ] Robot mode outputs gesture events\n- [ ] Validation warns about unusual values\n- [ ] Help text clearly explains each option\n\n## Logging Requirements\n- TRACE: (none)\n- DEBUG: Gesture detection disabled\n- INFO: Gesture detection enabled with config\n- WARN: Unusual threshold values\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.896069405Z","created_by":"ubuntu","updated_at":"2026-01-19T21:29:16.408257774Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c2","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.905825153Z","created_by":"ubuntu"}]}
{"id":"bd-3c8","title":"Implement device info endpoint","description":"GET /api/device:\n```json\n{\n  \"model\": \"Stream Deck XL\",\n  \"serial\": \"ABC123\",\n  \"key_count\": 32,\n  \"key_width\": 72,\n  \"key_height\": 72,\n  \"firmware\": \"1.0.0\"\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.004989866Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.016076239Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3c8","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.016018160Z","created_by":"ubuntu"}]}
{"id":"bd-3d5","title":"Add human-friendly progress output for batch","description":"## Human-Friendly Progress Output for Batch Operations\n\n### Visual Design\n\n**Scanning Phase:**\n```\nScanning /home/user/layout/ for images...\nFound 30 matching files (pattern: key-{index}.png)\n```\n\n**Progress Phase (with TTY):**\n```\nSetting keys [██████████████░░░░░░░░░░░░░░░░░░] 14/32\n  Key 13: key-13.png (128x128 → 72x72)\n```\n\n**Progress Phase (without TTY):**\n```\nSetting key 0/32: key-00.png\nSetting key 1/32: key-01.png\n...\n```\n\n**Completion (Success):**\n```\n✓ Set 30 keys in 1.2s\n\nSummary:\n  Applied: 30 keys\n  Skipped: 2 keys (files not found)\n  Duration: 1.25s\n```\n\n**Completion (With Errors):**\n```\n⚠ Set 28 keys with 2 errors in 1.4s\n\nSummary:\n  Applied: 28 keys\n  Failed: 2 keys\n  Skipped: 2 keys (files not found)\n\nErrors:\n  Key 5 (key-05.png): Image corrupted - invalid PNG header\n  Key 12 (key-12.png): Permission denied\n```\n\n### Color Scheme (when TTY and color enabled)\n\n- Progress bar: cyan\n- Success checkmark (✓): green\n- Warning (⚠): yellow\n- Error (✗): red\n- Key numbers: bold\n- File names: blue\n- Dimensions: dim\n\n### Implementation Requirements\n\n1. **TTY Detection**: Use `atty` or `is_terminal` crate\n2. **Color Support**: Use `colored` crate with TTY detection\n3. **Progress Bar**: Use `indicatif` crate or simple counter\n4. **Unicode Fallback**: Use ASCII if unicode not supported\n   - ✓ → [OK]\n   - ⚠ → [WARN]\n   - ✗ → [FAIL]\n   - █ → #\n\n### Quiet Mode\n\nWith `--quiet` or `-q`:\n- No progress output\n- Only final summary\n- Errors still printed to stderr\n\n### Verbose Mode\n\nWith `--verbose` or `-v`:\n- Show each file being loaded\n- Show resize operations\n- Show timing per key\n- Show cache hit/miss\n\n### Accessibility\n\n- Don't rely solely on color (use symbols too)\n- Provide machine-readable alternative (--robot)\n- Support NO_COLOR environment variable","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.949008857Z","created_by":"ubuntu","updated_at":"2026-01-21T10:58:12.540796849Z","closed_at":"2026-01-21T10:58:12.540750091Z","close_reason":"Already implemented with per-key output and summary in main.rs","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3d5","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.965774463Z","created_by":"ubuntu"}]}
{"id":"bd-3du5","title":"Add --ascii flag for forced ASCII box drawing","description":"# Add --ascii flag for forced ASCII box drawing\n\n## Purpose\nAdd a CLI flag that forces ASCII-only box drawing characters for users with terminals that don't support Unicode, or who prefer ASCII output for compatibility.\n\n## Background\nWhile most modern terminals support Unicode box-drawing characters (╭─╮), some environments may not:\n- Legacy terminals\n- Some screen readers\n- Certain remote/SSH connections\n- User preference\n\n## Implementation\n\n### CLI Flag (src/cli/mod.rs)\n```rust\n#[derive(Parser)]\npub struct Cli {\n    // ... existing fields ...\n    \n    /// Use ASCII box-drawing characters instead of Unicode\n    #[arg(long, global = true)]\n    pub ascii: bool,\n}\n```\n\n### Integration with OutputMode\n```rust\nimpl OutputMode {\n    pub fn from_cli(cli: &Cli) -> Self {\n        if cli.use_json() {\n            // ... robot mode unchanged ...\n        } else {\n            let console = Console::builder()\n                .safe_box(cli.ascii || cli.no_color)  // ASCII with --ascii or --no-color\n                .build();\n            Self::Human(console)\n        }\n    }\n}\n```\n\n### ASCII Box Style\nWhen safe_box is enabled, rich_rust uses ASCII characters:\n```\n+----------------------+\n|                      |\n| Content here         |\n|                      |\n+----------------------+\n```\n\nInstead of Unicode:\n```\n╭──────────────────────╮\n│                      │\n│ Content here         │\n│                      │\n╰──────────────────────╯\n```\n\n## Design Decisions\n\n### Why --ascii Instead of --unicode?\n- Default to Unicode (better looking for most users)\n- Opt-in to ASCII for those who need it\n- Consistent with other CLIs\n\n### Combining with --no-color\nIf --no-color is set, it makes sense to also use ASCII since the user likely wants maximum compatibility.\n\n## Usage Examples\n```bash\n# Unicode output (default)\nsd list\n\n# ASCII output\nsd list --ascii\n\n# JSON output (unaffected)\nsd list --robot --ascii  # --ascii ignored in robot mode\n```\n\n## Acceptance Criteria\n- [ ] --ascii flag added to CLI\n- [ ] Flag causes ASCII box characters\n- [ ] Flag is global (works with all commands)\n- [ ] Robot mode ignores flag\n- [ ] Help text explains purpose","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T21:11:59.245987022Z","created_by":"ubuntu","updated_at":"2026-01-19T21:11:59.284687958Z","compaction_level":0,"original_size":0,"labels":["accessibility","cli","phase-5","rich-rust"],"dependencies":[{"issue_id":"bd-3du5","depends_on_id":"bd-1z7d","type":"parent-child","created_at":"2026-01-19T21:11:59.278963581Z","created_by":"ubuntu"},{"issue_id":"bd-3du5","depends_on_id":"bd-2mvm","type":"blocks","created_at":"2026-01-19T21:11:59.284642333Z","created_by":"ubuntu"}]}
{"id":"bd-3dy","title":"Implement directory scanning with pattern matching","description":"## Purpose\nScan a directory for images matching a pattern and map them to Stream Deck key indices.\n\n## Implementation\n\n```rust\n// src/batch/scanner.rs\nuse std::path::{Path, PathBuf};\nuse tracing::{debug, trace, info, warn, instrument};\n\n#[derive(Debug, Clone)]\npub struct ScanResult {\n    pub mappings: Vec<KeyMapping>,\n    pub unmatched: Vec<PathBuf>,\n    pub invalid: Vec<(PathBuf, String)>,\n}\n\n#[derive(Debug, Clone)]\npub struct KeyMapping {\n    pub key: u8,\n    pub path: PathBuf,\n    pub size_bytes: u64,\n}\n\n/// Scan a directory for files matching the pattern\n#[instrument(fields(dir = %dir.display(), pattern = %pattern))]\npub fn scan_directory(\n    dir: &Path,\n    pattern: &str,\n    key_count: u8,\n) -> Result<ScanResult, ScanError> {\n    info!(\"Starting directory scan\");\n    \n    if !dir.exists() {\n        return Err(ScanError::DirectoryNotFound(dir.to_path_buf()));\n    }\n    \n    if !dir.is_dir() {\n        return Err(ScanError::NotADirectory(dir.to_path_buf()));\n    }\n    \n    let mut mappings = Vec::new();\n    let mut unmatched = Vec::new();\n    let mut invalid = Vec::new();\n    \n    let entries = std::fs::read_dir(dir)\n        .map_err(|e| ScanError::ReadError(dir.to_path_buf(), e))?;\n    \n    for entry in entries {\n        let entry = entry.map_err(|e| ScanError::EntryError(e))?;\n        let path = entry.path();\n        \n        // Skip directories\n        if path.is_dir() {\n            trace!(path = %path.display(), \"Skipping directory\");\n            continue;\n        }\n        \n        // Try to extract key index from filename\n        match extract_key_index(&path, pattern) {\n            Some(key) if key < key_count => {\n                let metadata = std::fs::metadata(&path)?;\n                debug!(\n                    key = %key,\n                    path = %path.display(),\n                    size = %metadata.len(),\n                    \"Matched key file\"\n                );\n                mappings.push(KeyMapping {\n                    key,\n                    path,\n                    size_bytes: metadata.len(),\n                });\n            }\n            Some(key) => {\n                warn!(\n                    key = %key,\n                    max = %key_count,\n                    path = %path.display(),\n                    \"Key index out of range\"\n                );\n                invalid.push((path, format!(\"key {} out of range (max {})\", key, key_count - 1)));\n            }\n            None => {\n                trace!(path = %path.display(), \"File doesn't match pattern\");\n                unmatched.push(path);\n            }\n        }\n    }\n    \n    // Sort mappings by key index for consistent ordering\n    mappings.sort_by_key(|m| m.key);\n    \n    info!(\n        matched = %mappings.len(),\n        unmatched = %unmatched.len(),\n        invalid = %invalid.len(),\n        \"Directory scan complete\"\n    );\n    \n    Ok(ScanResult { mappings, unmatched, invalid })\n}\n\n/// Extract key index from filename based on pattern\nfn extract_key_index(path: &Path, pattern: &str) -> Option<u8> {\n    let filename = path.file_name()?.to_str()?;\n    \n    // Pattern like \"key-{index}.png\" or \"key-{index:02d}.png\"\n    // Find where {index} would be and extract the number there\n    let parts: Vec<&str> = pattern.split(\"{index\").collect();\n    if parts.len() != 2 {\n        return None;\n    }\n    \n    let prefix = parts[0];\n    let suffix = parts[1].split('}').nth(1)?;\n    \n    if !filename.starts_with(prefix) || !filename.ends_with(suffix) {\n        return None;\n    }\n    \n    let start = prefix.len();\n    let end = filename.len() - suffix.len();\n    let num_str = &filename[start..end];\n    \n    num_str.parse().ok()\n}\n```\n\n## Edge Cases\n- Empty directory → empty mappings, no error\n- No matching files → empty mappings with all in unmatched\n- Duplicate key indices → last one wins (warn logged)\n- Symlinks → followed (like regular files)\n- Permission denied on file → added to invalid with reason\n\n## Logging Requirements\n- TRACE: Each file examined (match/no-match decision)\n- DEBUG: Each matched file with key index and size\n- INFO: Scan start/complete with summary counts\n- WARN: Key index out of range, duplicates\n- ERROR: Directory access failures\n\n## Success Criteria\n- [ ] Scans flat directory correctly\n- [ ] Pattern matching works for common patterns\n- [ ] Out-of-range keys handled gracefully\n- [ ] Missing directory returns clear error\n- [ ] Empty directory returns empty result (not error)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:23:42.150275826Z","created_by":"ubuntu","updated_at":"2026-01-21T09:18:03.046463451Z","closed_at":"2026-01-21T09:18:03.046140864Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3dy","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T18:23:42.166727231Z","created_by":"ubuntu"}]}
{"id":"bd-3fo","title":"Implement path resolution (absolute, relative, ~)","description":"## Purpose\nImplement cross-platform path resolution for config file paths, handling absolute, relative, and home-expanded paths.\n\n## Implementation\n\n```rust\n// src/config/path.rs\nuse std::path::{Path, PathBuf};\nuse crate::error::{Result, SdError};\nuse tracing::{debug, trace};\n\n/// Resolve a path from a config file\n/// \n/// Resolution rules:\n/// 1. Absolute paths: used as-is\n/// 2. Paths starting with ~: expanded to home directory\n/// 3. Relative paths: resolved relative to config file's directory\npub fn resolve_path(path: &Path, config_dir: &Path) -> Result<PathBuf> {\n    trace!(path = %path.display(), config_dir = %config_dir.display(), \"Resolving path\");\n    \n    let path_str = path.to_string_lossy();\n    \n    // Handle home directory expansion\n    if path_str.starts_with(\"~/\") || path_str == \"~\" {\n        let home = home_dir()?;\n        let rest = path_str.strip_prefix(\"~/\").unwrap_or(\"\");\n        let resolved = home.join(rest);\n        debug!(original = %path.display(), resolved = %resolved.display(), \"Expanded ~ path\");\n        return Ok(resolved);\n    }\n    \n    // Handle absolute paths\n    if path.is_absolute() {\n        debug!(path = %path.display(), \"Using absolute path as-is\");\n        return Ok(path.to_path_buf());\n    }\n    \n    // Handle relative paths\n    let resolved = config_dir.join(path);\n    debug!(\n        original = %path.display(),\n        config_dir = %config_dir.display(),\n        resolved = %resolved.display(),\n        \"Resolved relative path\"\n    );\n    \n    Ok(resolved)\n}\n\n/// Get home directory cross-platform\npub fn home_dir() -> Result<PathBuf> {\n    dirs::home_dir()\n        .ok_or_else(|| SdError::ConfigInvalid(\n            \"Could not determine home directory\".to_string()\n        ))\n}\n\n/// Check if a path exists and is a file\npub fn validate_image_path(path: &Path) -> Result<()> {\n    if !path.exists() {\n        return Err(SdError::ImageNotFound(path.display().to_string()));\n    }\n    \n    if !path.is_file() {\n        return Err(SdError::ImageNotFound(\n            format!(\"{} is not a file\", path.display())\n        ));\n    }\n    \n    // Check extension for supported formats\n    let ext = path.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| e.to_lowercase());\n    \n    match ext.as_deref() {\n        Some(\"png\" | \"jpg\" | \"jpeg\" | \"gif\" | \"bmp\" | \"webp\") => Ok(()),\n        Some(other) => Err(SdError::ImageFormat(\n            format!(\"Unsupported image format: .{}\", other)\n        )),\n        None => Err(SdError::ImageFormat(\n            \"Image file has no extension\".to_string()\n        )),\n    }\n}\n\n/// Path resolution context for a config file\npub struct PathResolver {\n    config_dir: PathBuf,\n}\n\nimpl PathResolver {\n    /// Create resolver for a config file path\n    pub fn new(config_path: &Path) -> Result<Self> {\n        let config_dir = config_path.parent()\n            .ok_or_else(|| SdError::ConfigInvalid(\n                format!(\"Config path has no parent directory: {}\", config_path.display())\n            ))?\n            .to_path_buf();\n        \n        // Canonicalize if possible (resolves symlinks)\n        let config_dir = config_dir.canonicalize()\n            .unwrap_or(config_dir);\n        \n        Ok(Self { config_dir })\n    }\n    \n    /// Resolve a path relative to config file\n    pub fn resolve(&self, path: &Path) -> Result<PathBuf> {\n        resolve_path(path, &self.config_dir)\n    }\n    \n    /// Resolve and validate an image path\n    pub fn resolve_image(&self, path: &Path) -> Result<PathBuf> {\n        let resolved = self.resolve(path)?;\n        validate_image_path(&resolved)?;\n        Ok(resolved)\n    }\n    \n    /// Get the config directory\n    pub fn config_dir(&self) -> &Path {\n        &self.config_dir\n    }\n}\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::{self, File};\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_absolute_path() {\n        let config_dir = Path::new(\"/some/config/dir\");\n        let path = Path::new(\"/absolute/path/to/image.png\");\n        \n        let resolved = resolve_path(path, config_dir).unwrap();\n        assert_eq!(resolved, PathBuf::from(\"/absolute/path/to/image.png\"));\n    }\n    \n    #[test]\n    fn test_relative_path() {\n        let config_dir = Path::new(\"/home/user/.config/sd\");\n        let path = Path::new(\"icons/test.png\");\n        \n        let resolved = resolve_path(path, config_dir).unwrap();\n        assert_eq!(resolved, PathBuf::from(\"/home/user/.config/sd/icons/test.png\"));\n    }\n    \n    #[test]\n    fn test_relative_path_with_dots() {\n        let config_dir = Path::new(\"/home/user/.config/sd/profiles\");\n        let path = Path::new(\"../icons/test.png\");\n        \n        let resolved = resolve_path(path, config_dir).unwrap();\n        // Note: doesn't canonicalize, just joins\n        assert_eq!(resolved, PathBuf::from(\"/home/user/.config/sd/profiles/../icons/test.png\"));\n    }\n    \n    #[test]\n    fn test_home_expansion() {\n        let config_dir = Path::new(\"/some/config/dir\");\n        let path = Path::new(\"~/icons/test.png\");\n        \n        let resolved = resolve_path(path, config_dir).unwrap();\n        \n        // Should start with home directory\n        let home = home_dir().unwrap();\n        assert!(resolved.starts_with(&home));\n        assert!(resolved.ends_with(\"icons/test.png\"));\n    }\n    \n    #[test]\n    fn test_home_only() {\n        let config_dir = Path::new(\"/some/config/dir\");\n        let path = Path::new(\"~\");\n        \n        let resolved = resolve_path(path, config_dir).unwrap();\n        let home = home_dir().unwrap();\n        assert_eq!(resolved, home);\n    }\n    \n    #[test]\n    fn test_validate_existing_image() {\n        let temp = TempDir::new().unwrap();\n        let img_path = temp.path().join(\"test.png\");\n        File::create(&img_path).unwrap();\n        \n        assert!(validate_image_path(&img_path).is_ok());\n    }\n    \n    #[test]\n    fn test_validate_missing_image() {\n        let result = validate_image_path(Path::new(\"/nonexistent/image.png\"));\n        assert!(matches!(result, Err(SdError::ImageNotFound(_))));\n    }\n    \n    #[test]\n    fn test_validate_directory_not_file() {\n        let temp = TempDir::new().unwrap();\n        let result = validate_image_path(temp.path());\n        assert!(matches!(result, Err(SdError::ImageNotFound(_))));\n    }\n    \n    #[test]\n    fn test_validate_unsupported_format() {\n        let temp = TempDir::new().unwrap();\n        let txt_path = temp.path().join(\"test.txt\");\n        File::create(&txt_path).unwrap();\n        \n        let result = validate_image_path(&txt_path);\n        assert!(matches!(result, Err(SdError::ImageFormat(_))));\n    }\n    \n    #[test]\n    fn test_validate_no_extension() {\n        let temp = TempDir::new().unwrap();\n        let no_ext = temp.path().join(\"noextension\");\n        File::create(&no_ext).unwrap();\n        \n        let result = validate_image_path(&no_ext);\n        assert!(matches!(result, Err(SdError::ImageFormat(_))));\n    }\n    \n    #[test]\n    fn test_supported_formats() {\n        let temp = TempDir::new().unwrap();\n        \n        for ext in &[\"png\", \"jpg\", \"jpeg\", \"gif\", \"bmp\", \"webp\"] {\n            let path = temp.path().join(format!(\"test.{}\", ext));\n            File::create(&path).unwrap();\n            assert!(validate_image_path(&path).is_ok(), \"Should support .{}\", ext);\n        }\n    }\n    \n    #[test]\n    fn test_path_resolver() {\n        let temp = TempDir::new().unwrap();\n        let config_path = temp.path().join(\"config.yaml\");\n        File::create(&config_path).unwrap();\n        \n        let resolver = PathResolver::new(&config_path).unwrap();\n        \n        // Relative path resolves from config dir\n        let resolved = resolver.resolve(Path::new(\"icons/test.png\")).unwrap();\n        assert!(resolved.starts_with(temp.path()));\n    }\n    \n    #[test]\n    fn test_path_resolver_image() {\n        let temp = TempDir::new().unwrap();\n        let config_path = temp.path().join(\"config.yaml\");\n        File::create(&config_path).unwrap();\n        \n        let icons_dir = temp.path().join(\"icons\");\n        fs::create_dir(&icons_dir).unwrap();\n        let img_path = icons_dir.join(\"test.png\");\n        File::create(&img_path).unwrap();\n        \n        let resolver = PathResolver::new(&config_path).unwrap();\n        let resolved = resolver.resolve_image(Path::new(\"icons/test.png\")).unwrap();\n        \n        assert_eq!(resolved, img_path.canonicalize().unwrap_or(img_path));\n    }\n}\n```\n\n## Success Criteria\n- [ ] Absolute paths returned unchanged\n- [ ] Relative paths resolved from config directory\n- [ ] ~ expanded to home directory\n- [ ] Image validation checks existence\n- [ ] Unsupported formats rejected with clear error\n- [ ] PathResolver provides convenient API\n- [ ] All tests pass\n\n## Dependencies\n- dirs crate (already in Cargo.toml for home_dir)\n\n## Logging Requirements\n- TRACE: Path resolution attempts\n- DEBUG: Resolved paths, home directory expansion\n- INFO: (none)\n- WARN: Path resolution fallbacks\n- ERROR: Missing home directory, invalid paths","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:56.799582382Z","created_by":"ubuntu","updated_at":"2026-01-19T21:42:07.844573062Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3fo","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:56.814993518Z","created_by":"ubuntu"}]}
{"id":"bd-3g6","title":"Implement config list command","description":"Implement sd config list:\n- List all imported/saved profiles\n- Show: name, creation date, device type, key count\n- Robot mode: JSON array\n- Human mode: Table format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.869558183Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.879394173Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3g6","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.879347044Z","created_by":"ubuntu"}]}
{"id":"bd-3gj","title":"Design gesture state machine","description":"Document state machine design:\n- States: Idle, Pressed, PotentialDoubleTap\n- Transitions based on press/release and timing\n- Gesture outputs: Tap, DoubleTap, LongPress, HoldStart/Tick/End\n\nCritical timing decisions:\n- Long press threshold (default 800ms)\n- Double tap window (default 300ms)\n- Hold tick interval (default 100ms)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:59.836520761Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:59.867034192Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3gj","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:27:59.866981643Z","created_by":"ubuntu"}]}
{"id":"bd-3il","title":"Implement hold start/tick/end","description":"Hold events for continuous actions:\n1. HoldStart when duration exceeds threshold while pressed\n2. HoldTick every interval while held\n3. HoldEnd on release (includes total duration)\n\nUsed for push-to-talk, volume adjustment, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.465425065Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.476661571Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3il","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.476608130Z","created_by":"ubuntu"}]}
{"id":"bd-3ix","title":"Implement validate command","description":"## Purpose\nImplement the `sd validate <config>` command that validates a configuration file without applying it.\n\n## CLI Interface\n\n```\nsd validate <CONFIG> [OPTIONS]\n\nArguments:\n  <CONFIG>  Path to config file to validate\n\nOptions:\n  --strict       Treat warnings as errors\n  --robot        Output JSON instead of human-readable\n```\n\n## Implementation\n\n```rust\n// src/commands/validate.rs\nuse std::path::Path;\nuse crate::config::{ProfileConfig, PathResolver, KeySelector, KeyConfig};\nuse crate::device::DeviceInfo;\nuse crate::error::{Result, SdError};\nuse crate::output::{Output, ValidationResult, ValidationIssue, IssueSeverity};\nuse tracing::{debug, info, warn, instrument};\n\n#[derive(Debug)]\npub struct ValidateOptions {\n    pub strict: bool,\n}\n\n#[instrument(skip(output), fields(config = %config_path.display()))]\npub fn cmd_validate(\n    config_path: &Path,\n    device_info: Option<&DeviceInfo>,\n    options: ValidateOptions,\n    output: &dyn Output,\n) -> Result<ValidationResult> {\n    info!(\"Validating configuration\");\n    \n    let mut result = ValidationResult::new(config_path);\n    \n    // Phase 1: Check file exists and is readable\n    if !config_path.exists() {\n        result.add_error(\"config_file\", \"File not found\");\n        return output.validation_result(&result);\n    }\n    \n    // Phase 2: Parse syntax\n    let content = match std::fs::read_to_string(config_path) {\n        Ok(c) => c,\n        Err(e) => {\n            result.add_error(\"config_file\", &format!(\"Cannot read: {}\", e));\n            return output.validation_result(&result);\n        }\n    };\n    \n    let config: ProfileConfig = match parse_config(&content, config_path) {\n        Ok(c) => c,\n        Err(e) => {\n            result.add_error(\"syntax\", &e.to_string());\n            return output.validation_result(&result);\n        }\n    };\n    \n    debug!(name = ?config.name, \"Parsed configuration\");\n    result.config_name = config.name.clone();\n    \n    // Phase 3: Validate brightness\n    if let Some(brightness) = config.brightness {\n        if brightness > 100 {\n            result.add_error(\"brightness\", &format!(\n                \"Brightness {} exceeds maximum of 100\", brightness\n            ));\n        }\n    }\n    \n    // Phase 4: Create path resolver and validate paths\n    let resolver = match PathResolver::new(config_path) {\n        Ok(r) => r,\n        Err(e) => {\n            result.add_error(\"paths\", &e.to_string());\n            return output.validation_result(&result);\n        }\n    };\n    \n    // Phase 5: Validate each key configuration\n    for (selector_str, key_config) in &config.keys {\n        validate_selector(&selector_str, device_info, &mut result);\n        validate_key_config(key_config, &resolver, &selector_str, &mut result);\n    }\n    \n    // Phase 6: Check for selector conflicts\n    check_selector_conflicts(&config.keys, &mut result);\n    \n    // Phase 7: Device-specific validation\n    if let Some(device) = device_info {\n        validate_device_compatibility(&config, device, &mut result);\n    } else {\n        result.add_warning(\"device\", \"No device connected; skipping device-specific validation\");\n    }\n    \n    info!(\n        errors = result.error_count(),\n        warnings = result.warning_count(),\n        \"Validation complete\"\n    );\n    \n    output.validation_result(&result)\n}\n\nfn parse_config(content: &str, path: &Path) -> Result<ProfileConfig> {\n    let ext = path.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| e.to_lowercase());\n    \n    match ext.as_deref() {\n        Some(\"yaml\" | \"yml\") => {\n            serde_yaml::from_str(content)\n                .map_err(|e| SdError::ConfigParse(format!(\"YAML: {}\", e)))\n        }\n        Some(\"toml\") => {\n            toml::from_str(content)\n                .map_err(|e| SdError::ConfigParse(format!(\"TOML: {}\", e)))\n        }\n        Some(\"json\") => {\n            serde_json::from_str(content)\n                .map_err(|e| SdError::ConfigParse(format!(\"JSON: {}\", e)))\n        }\n        _ => Err(SdError::ConfigParse(\n            \"Unknown file extension. Use .yaml, .yml, .toml, or .json\".to_string()\n        ))\n    }\n}\n\nfn validate_selector(\n    selector_str: &str,\n    device_info: Option<&DeviceInfo>,\n    result: &mut ValidationResult,\n) {\n    match KeySelector::parse(selector_str) {\n        Ok(selector) => {\n            if let Some(device) = device_info {\n                if let Err(e) = selector.resolve(device) {\n                    result.add_error(\n                        &format!(\"key[{}]\", selector_str),\n                        &format!(\"Invalid for this device: {}\", e),\n                    );\n                }\n            }\n        }\n        Err(e) => {\n            result.add_error(&format!(\"key[{}]\", selector_str), &e.to_string());\n        }\n    }\n}\n\nfn validate_key_config(\n    config: &KeyConfig,\n    resolver: &PathResolver,\n    selector: &str,\n    result: &mut ValidationResult,\n) {\n    let field = format!(\"key[{}]\", selector);\n    \n    match config {\n        KeyConfig::Image { image, .. } => {\n            match resolver.resolve(image) {\n                Ok(path) => {\n                    if !path.exists() {\n                        result.add_error(&field, &format!(\n                            \"Image not found: {}\", image.display()\n                        ));\n                    }\n                }\n                Err(e) => {\n                    result.add_error(&field, &format!(\"Path error: {}\", e));\n                }\n            }\n        }\n        KeyConfig::Pattern { pattern, .. } => {\n            if !pattern.contains(\"{index}\") {\n                result.add_error(&field, \"Pattern must contain {index} placeholder\");\n            }\n            // Note: Can't fully validate patterns without knowing target keys\n        }\n        KeyConfig::Color { color } => {\n            if let Err(e) = color.to_rgb() {\n                result.add_error(&field, &format!(\"Invalid color: {}\", e));\n            }\n        }\n        KeyConfig::Clear { clear } => {\n            if !clear {\n                result.add_warning(&field, \"clear: false is redundant; omit the key instead\");\n            }\n        }\n    }\n}\n\nfn check_selector_conflicts(\n    keys: &HashMap<String, KeyConfig>,\n    result: &mut ValidationResult,\n) {\n    // Check for overlapping selectors that might cause confusion\n    let selectors: Vec<_> = keys.keys().collect();\n    \n    for i in 0..selectors.len() {\n        for j in (i + 1)..selectors.len() {\n            if let (Ok(a), Ok(b)) = (\n                KeySelector::parse(selectors[i]),\n                KeySelector::parse(selectors[j])\n            ) {\n                // Check if both are the same type with same parameters\n                if a == b {\n                    result.add_warning(\n                        \"selectors\",\n                        &format!(\"Duplicate selector: {} and {}\", selectors[i], selectors[j]),\n                    );\n                }\n            }\n        }\n    }\n}\n\nfn validate_device_compatibility(\n    config: &ProfileConfig,\n    device: &DeviceInfo,\n    result: &mut ValidationResult,\n) {\n    // Check device filter\n    if let Some(filter) = &config.device {\n        if let Some(model) = &filter.model {\n            if model != &format!(\"{:?}\", device.model) {\n                result.add_error(\"device\", &format!(\n                    \"Config targets {} but connected device is {:?}\",\n                    model, device.model\n                ));\n            }\n        }\n    }\n}\n```\n\n## Robot Mode JSON Output\n\n### Valid Config\n```json\n{\n  \"valid\": true,\n  \"config\": {\n    \"path\": \"/home/user/work.yaml\",\n    \"name\": \"Work Profile\"\n  },\n  \"errors\": [],\n  \"warnings\": [],\n  \"summary\": {\n    \"total_keys\": 15,\n    \"brightness\": 80\n  }\n}\n```\n\n### Invalid Config\n```json\n{\n  \"valid\": false,\n  \"config\": {\n    \"path\": \"/home/user/broken.yaml\",\n    \"name\": null\n  },\n  \"errors\": [\n    {\n      \"field\": \"key[0]\",\n      \"message\": \"Image not found: ~/missing.png\",\n      \"suggestion\": \"Check file path or create the image\"\n    },\n    {\n      \"field\": \"key[99]\",\n      \"message\": \"Key index 99 out of range for Stream Deck XL (0-31)\",\n      \"suggestion\": \"Use 'sd info' to see valid key range\"\n    }\n  ],\n  \"warnings\": [\n    {\n      \"field\": \"key[5]\",\n      \"message\": \"Image dimensions (512x512) will be resized to 96x96\"\n    }\n  ],\n  \"summary\": {\n    \"error_count\": 2,\n    \"warning_count\": 1\n  }\n}\n```\n\n## Human Output\n\n### Valid\n```\nValidating work.yaml...\n\n✓ Valid YAML syntax\n✓ Profile name: Work Profile\n✓ Brightness: 80\n✓ 15 key configurations\n✓ All image paths exist\n✓ All color values valid\n✓ All key indices within range\n\n✓ Configuration is valid\n```\n\n### Invalid\n```\nValidating broken.yaml...\n\n✓ Valid YAML syntax\n✓ Profile name: (none)\n\nERRORS:\n  key[0]: Image not found: ~/missing.png\n          Suggestion: Check file path or create the image\n  key[99]: Key index 99 out of range for Stream Deck XL (0-31)\n           Suggestion: Use 'sd info' to see valid key range\n\nWARNINGS:\n  key[5]: Image dimensions (512x512) will be resized to 96x96\n\n✗ Configuration has 2 errors and 1 warning\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::output::TestOutput;\n    use tempfile::TempDir;\n    use std::fs;\n    \n    fn xl_device() -> DeviceInfo {\n        DeviceInfo {\n            model: DeviceModel::XL,\n            key_count: 32,\n            key_cols: 8,\n            key_rows: 4,\n            ..Default::default()\n        }\n    }\n    \n    #[test]\n    fn test_validate_valid_config() {\n        let temp = TempDir::new().unwrap();\n        \n        // Create test image\n        let img_path = temp.path().join(\"test.png\");\n        fs::write(&img_path, &[0u8; 100]).unwrap();\n        \n        let config = format!(r#\"\nbrightness: 80\nkeys:\n  0:\n    image: {}\n  1:\n    color: \"#FF0000\"\n\"#, img_path.display());\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            Some(&xl_device()),\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(result.is_valid());\n        assert_eq!(result.error_count(), 0);\n    }\n    \n    #[test]\n    fn test_validate_missing_file() {\n        let output = TestOutput::new();\n        let result = cmd_validate(\n            Path::new(\"/nonexistent/config.yaml\"),\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n        assert!(result.errors.iter().any(|e| e.message.contains(\"not found\")));\n    }\n    \n    #[test]\n    fn test_validate_invalid_yaml() {\n        let temp = TempDir::new().unwrap();\n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, \"invalid: yaml: syntax:\").unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n    }\n    \n    #[test]\n    fn test_validate_missing_image() {\n        let temp = TempDir::new().unwrap();\n        \n        let config = r#\"\nkeys:\n  0:\n    image: ./missing.png\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n        assert!(result.errors.iter().any(|e| e.message.contains(\"not found\")));\n    }\n    \n    #[test]\n    fn test_validate_invalid_color() {\n        let temp = TempDir::new().unwrap();\n        \n        let config = r#\"\nkeys:\n  0:\n    color: \"not-a-color\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n    }\n    \n    #[test]\n    fn test_validate_key_out_of_range() {\n        let temp = TempDir::new().unwrap();\n        \n        let config = r#\"\nkeys:\n  99:\n    color: \"#FF0000\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            Some(&xl_device()),  // XL has 32 keys (0-31)\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n        assert!(result.errors.iter().any(|e| e.message.contains(\"out of range\")));\n    }\n    \n    #[test]\n    fn test_validate_brightness_out_of_range() {\n        let temp = TempDir::new().unwrap();\n        \n        let config = r#\"\nbrightness: 150\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n        assert!(result.errors.iter().any(|e| e.message.contains(\"100\")));\n    }\n    \n    #[test]\n    fn test_validate_pattern_missing_placeholder() {\n        let temp = TempDir::new().unwrap();\n        \n        let config = r#\"\nkeys:\n  \"8-15\":\n    pattern: \"./no-placeholder.png\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config).unwrap();\n        \n        let output = TestOutput::new();\n        let result = cmd_validate(\n            &config_path,\n            None,\n            ValidateOptions { strict: false },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.is_valid());\n        assert!(result.errors.iter().any(|e| e.message.contains(\"{index}\")));\n    }\n}\n```\n\n## Success Criteria\n- [ ] Checks file existence and readability\n- [ ] Validates YAML/TOML/JSON syntax\n- [ ] Validates brightness range (0-100)\n- [ ] Validates all image paths exist\n- [ ] Validates color formats\n- [ ] Validates key indices against device\n- [ ] Detects pattern placeholder missing\n- [ ] Reports all issues found (not just first)\n- [ ] Exit code 0 if valid, 1 if errors\n- [ ] Robot mode outputs structured JSON\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Individual field validation\n- DEBUG: Parsed config, resolved paths\n- INFO: Validation start/complete with counts\n- WARN: Validation warnings (non-fatal)\n- ERROR: Validation errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:58.360885986Z","created_by":"ubuntu","updated_at":"2026-01-19T21:44:42.695917741Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ix","depends_on_id":"bd-169","type":"blocks","created_at":"2026-01-19T21:44:42.048548562Z","created_by":"ubuntu"},{"issue_id":"bd-3ix","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.375651196Z","created_by":"ubuntu"},{"issue_id":"bd-3ix","depends_on_id":"bd-3fo","type":"blocks","created_at":"2026-01-19T21:44:42.695869720Z","created_by":"ubuntu"},{"issue_id":"bd-3ix","depends_on_id":"bd-a1n","type":"blocks","created_at":"2026-01-19T21:44:41.412498878Z","created_by":"ubuntu"}]}
{"id":"bd-3j4","title":"Implement exponential backoff with cap","description":"Implement proper exponential backoff:\n- Start with configured delay (default 1s)\n- Multiply by backoff_factor each attempt (default 2.0)\n- Cap at maximum (30s) to prevent extremely long waits\n- Reset on successful connection","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:26.072744747Z","created_by":"ubuntu","updated_at":"2026-01-21T11:04:23.064980908Z","closed_at":"2026-01-21T11:04:23.064930312Z","close_reason":"Already implemented in open_device_with_retry() at real.rs:171-173. Uses backoff_factor and caps at max_delay.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j4","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:26.087313507Z","created_by":"ubuntu"}]}
{"id":"bd-3j5","title":"Add save command with state serialization","description":"## Purpose\nImplement the `sd save <name>` command to persist current device state as a named snapshot.\n\n## CLI Definition\n```rust\n#[derive(Parser, Debug)]\npub struct SaveCommand {\n    /// Name for the snapshot (alphanumeric, hyphens, underscores)\n    #[arg(value_name = \"NAME\")]\n    pub name: String,\n    \n    /// Description for the snapshot\n    #[arg(long, short = 'd')]\n    pub description: Option<String>,\n    \n    /// Overwrite existing snapshot without prompting\n    #[arg(long)]\n    pub force: bool,\n    \n    /// Save only specific keys (space-separated indices)\n    #[arg(long, short = 'k')]\n    pub keys: Vec<u8>,\n    \n    /// Save only keys that have been modified in this session\n    #[arg(long)]\n    pub session_only: bool,\n    \n    /// Include brightness in snapshot\n    #[arg(long, default_value = \"true\")]\n    pub include_brightness: bool,\n}\n```\n\n## Implementation\n```rust\n// src/cli/save.rs\nuse crate::snapshot::{SnapshotDb, Snapshot, SnapshotKey, KeyState};\nuse crate::state::session_state;\nuse tracing::{debug, info, warn, error, instrument};\n\n#[instrument(skip(device, opts))]\npub async fn cmd_save(\n    device: &Device,\n    cmd: &SaveCommand,\n    opts: &GlobalOpts,\n) -> Result<()> {\n    // Validate name format\n    if !is_valid_snapshot_name(&cmd.name) {\n        return Err(SdError::ConfigInvalid(\n            \"Snapshot name must be alphanumeric with hyphens/underscores\".into()\n        ));\n    }\n    \n    let db = SnapshotDb::open()?;\n    \n    // Check for existing snapshot\n    if let Some(existing) = db.load_snapshot(&cmd.name)? {\n        if !cmd.force {\n            if opts.robot {\n                return Err(SdError::ConfigInvalid(format!(\n                    \"Snapshot '{}' already exists (use --force to overwrite)\",\n                    cmd.name\n                )));\n            }\n            // In human mode, could prompt - but we'll require --force for simplicity\n            return Err(SdError::ConfigInvalid(format!(\n                \"Snapshot '{}' already exists. Use --force to overwrite.\",\n                cmd.name\n            )));\n        }\n        info!(name = %cmd.name, \"Overwriting existing snapshot\");\n    }\n    \n    // Build snapshot from device info and session state\n    let device_info = device.info();\n    let session = session_state();\n    \n    let mut keys = Vec::new();\n    let key_indices: Vec<u8> = if !cmd.keys.is_empty() {\n        cmd.keys.clone()\n    } else if cmd.session_only {\n        session.keys.keys().copied().collect()\n    } else {\n        (0..device_info.key_count).collect()\n    };\n    \n    for key_index in key_indices {\n        if let Some(state) = session.keys.get(&key_index) {\n            let key_state = match state {\n                crate::state::KeyState::Image(path) => {\n                    // Hash and cache the image\n                    let hash = cache_image(&db, path)?;\n                    KeyState::Image {\n                        source_path: Some(path.display().to_string()),\n                        image_hash: hash,\n                    }\n                }\n                crate::state::KeyState::Color(hex) => {\n                    KeyState::Color { hex: hex.clone() }\n                }\n                crate::state::KeyState::Cleared => KeyState::Clear,\n            };\n            keys.push(SnapshotKey { key_index, state: key_state });\n        }\n    }\n    \n    let brightness = if cmd.include_brightness {\n        session.brightness\n    } else {\n        None\n    };\n    \n    let snapshot = Snapshot {\n        id: 0, // Will be assigned by DB\n        name: cmd.name.clone(),\n        description: cmd.description.clone(),\n        device_model: format!(\"{:?}\", device_info.model),\n        device_serial: device.serial().map(|s| s.to_string()),\n        key_count: device_info.key_count,\n        key_width: device_info.key_width,\n        key_height: device_info.key_height,\n        brightness,\n        created_at: Utc::now(),\n        updated_at: Utc::now(),\n        keys,\n    };\n    \n    let id = db.save_snapshot(&snapshot)?;\n    info!(id = %id, name = %cmd.name, keys = %snapshot.keys.len(), \"Snapshot saved\");\n    \n    // Output\n    if opts.robot {\n        println!(\"{}\", serde_json::to_string(&SaveResponse {\n            command: \"save\",\n            snapshot: SnapshotSummary {\n                name: cmd.name.clone(),\n                device_model: snapshot.device_model.clone(),\n                key_count: snapshot.key_count,\n                brightness: snapshot.brightness,\n                keys_saved: snapshot.keys.len(),\n            }\n        })?);\n    } else {\n        println!(\"Saved snapshot '{}' with {} keys\", cmd.name, snapshot.keys.len());\n    }\n    \n    Ok(())\n}\n\nfn is_valid_snapshot_name(name: &str) -> bool {\n    !name.is_empty() \n        && name.len() <= 64\n        && name.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_')\n}\n\nfn cache_image(db: &SnapshotDb, path: &Path) -> Result<String> {\n    // Read image, compute SHA256, store in content-addressable cache\n    let data = std::fs::read(path)?;\n    let hash = sha256_hex(&data);\n    db.store_image(&hash, &data, path)?;\n    Ok(hash)\n}\n```\n\n## Robot Mode Output\n```json\n{\n  \"command\": \"save\",\n  \"snapshot\": {\n    \"name\": \"work-layout\",\n    \"device_model\": \"StreamDeckXL\",\n    \"key_count\": 32,\n    \"brightness\": 80,\n    \"keys_saved\": 24\n  }\n}\n```\n\n## Error Cases\n```json\n{\n  \"error\": \"Snapshot 'work-layout' already exists (use --force to overwrite)\",\n  \"error_type\": \"config_invalid\"\n}\n```\n\n## Logging Requirements\n- TRACE: Individual key caching operations\n- DEBUG: Image hashing, database writes\n- INFO: Snapshot save start/complete with stats\n- WARN: Missing source images (skip or error based on flags)\n- ERROR: Database failures, I/O errors\n\n## Success Criteria\n- [ ] Creates snapshot with name and optional description\n- [ ] Caches images to content-addressable storage\n- [ ] Handles name collisions with --force\n- [ ] Respects --keys and --session-only filters\n- [ ] Robot mode outputs structured JSON\n- [ ] Human mode shows confirmation","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.196769381Z","created_by":"ubuntu","updated_at":"2026-01-21T11:20:49.008944101Z","closed_at":"2026-01-21T11:20:49.008891562Z","close_reason":"Implemented save command: added Save, Restore, Snapshots CLI commands with args structs, implemented cmd_save with session state serialization, image hashing (SHA256), content-addressable caching, snapshot name validation. Also implemented cmd_restore and cmd_snapshots as part of the snapshot workflow.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j5","depends_on_id":"bd-2qo","type":"blocks","created_at":"2026-01-19T22:06:56.782534445Z","created_by":"ubuntu"},{"issue_id":"bd-3j5","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.205885675Z","created_by":"ubuntu"},{"issue_id":"bd-3j5","depends_on_id":"bd-e36","type":"blocks","created_at":"2026-01-19T22:06:58.906283432Z","created_by":"ubuntu"}]}
{"id":"bd-3ju","title":"EPIC: Batch Operations with Directory Import","description":"## Overview\n**Rank: #1 of 15** | **Impact: Very High** | **Effort: Low** | **Confidence: Very High**\n\nAdd `sd set-keys <DIR>` command that loads all images from a directory and sets them to keys based on filename pattern (e.g., `key-00.png`, `key-01.png`).\n\n## Problem Statement\nThe single biggest pain point with the current CLI is setting up a full device. For a Stream Deck XL (32 keys), users must call `sd set-key` 32 separate times. This is:\n- Tedious for humans\n- Inefficient for AI agents (32 tool calls instead of 1)\n- Error-prone (easy to miss keys or use wrong indices)\n- Not scriptable in a clean way\n\n## Solution\nA single command that atomically applies a directory of images to the device:\n```bash\nsd set-keys ~/my-deck-layout/\n# Reads key-00.png through key-31.png and applies them\n```\n\n## Why This Is #1 Priority\n1. **Immediate utility**: Solves the most common workflow pain point\n2. **Obvious accretion**: Uses existing image loading, key validation, and device communication\n3. **Robot-mode friendly**: Agents prepare a directory, apply atomically, get per-key error reporting\n4. **Low complexity**: ~50-75 lines of code, no new dependencies\n\n## Implementation Approach\n```rust\n// In src/cli/mod.rs - add new command variant\nSetKeys { \n    /// Directory containing key-NN.png/jpg files\n    dir: PathBuf,\n    /// Naming pattern (default: key-{index}.png)\n    #[arg(long, default_value = \"key-{index}.png\")]\n    pattern: String,\n    /// Continue on error (report failures but keep going)\n    #[arg(long)]\n    continue_on_error: bool,\n}\n\n// In main.rs - implement command handler\nfn cmd_set_keys(device: &Device, dir: &Path, pattern: &str, continue_on_error: bool) -> Result<()> {\n    let key_count = device.info().key_count;\n    let mut results = Vec::new();\n    \n    for key in 0..key_count {\n        let filename = pattern.replace(\"{index}\", &format!(\"{key:02}\"));\n        let path = dir.join(&filename);\n        \n        if path.exists() {\n            match set_key_image(device, key, &path) {\n                Ok(()) => results.push((key, Ok(()))),\n                Err(e) if continue_on_error => results.push((key, Err(e))),\n                Err(e) => return Err(e),\n            }\n        }\n    }\n    \n    // Robot mode: return JSON array of results\n    // Human mode: print summary\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Pattern-based naming**: Flexible filename patterns support different conventions\n2. **Two-digit zero-padding**: `key-00.png` not `key-0.png` for proper sorting\n3. **Skip missing files**: Only set keys that have corresponding images\n4. **Continue-on-error option**: Batch operations should be resilient by default for agents\n5. **Detailed reporting**: Each key gets success/failure status in robot mode\n\n## Success Criteria\n- [ ] `sd set-keys <dir>` applies all matching images in one command\n- [ ] Pattern flag allows custom naming conventions\n- [ ] Robot mode returns per-key success/failure JSON\n- [ ] Human mode shows progress and summary\n- [ ] Errors include which key/file failed and why\n- [ ] Works with all Stream Deck variants (different key counts)\n\n## Files to Modify\n- `src/cli/mod.rs`: Add SetKeys command struct\n- `src/main.rs`: Add cmd_set_keys handler and dispatch\n\n## Testing Strategy\n1. Create test directory with sample images\n2. Test with full set (32 images)\n3. Test with partial set (some keys missing)\n4. Test with invalid images (wrong format, corrupted)\n5. Test continue-on-error behavior\n6. Verify robot mode JSON output structure\n\n## Dependencies\nNone - uses existing infrastructure\n\n## Estimated Subtasks\n1. Add CLI command definition\n2. Implement directory scanning with pattern matching\n3. Implement batch application loop\n4. Add error handling and continue-on-error\n5. Implement robot mode JSON output\n6. Add human-friendly progress output\n7. Write tests\n8. Update help text and examples","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:09:28.552254273Z","created_by":"ubuntu","updated_at":"2026-01-21T11:07:55.113727857Z","closed_at":"2026-01-21T11:07:55.113676871Z","close_reason":"All core batch operations implemented: set-keys (with pattern, dry-run, error handling), fill-keys, clear-keys. Success criteria met.","compaction_level":0,"original_size":0,"labels":["agent-friendly","cli","priority-1","user-experience"]}
{"id":"bd-3jv","title":"Add error handling for invalid configs","description":"When config file becomes invalid:\n- Parse error: show error, keep watching\n- Missing images: warn and skip those keys\n- Invalid colors: warn and skip\n- Never crash - always continue watching","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:35.076134526Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:35.087156148Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3jv","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:35.087109520Z","created_by":"ubuntu"}]}
{"id":"bd-3k6","title":"Implement brightness_set with ProgressBar visualization","description":"# Implement brightness_set with ProgressBar visualization\n\n## Purpose\nDisplay brightness changes with a visual progress bar that immediately communicates the brightness level. This provides instant feedback that the command worked and shows the current state.\n\n## Target Output\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ████████████████████░░░░░░░░░░░░░░░░  50%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Low Brightness (0%)\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   0%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Max Brightness (100%)\n```\n╭─────────────────────────────────────────────────────────╮\n│  Brightness: ████████████████████████████████████ 100%  │\n╰─────────────────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### Using rich_rust ProgressBar\n```rust\nfn brightness_set(&self, level: u8) {\n    // Calculate bar width (leave room for label and percentage)\n    // \"  Brightness: \" = 14 chars, \" XXX%\" = 5 chars, padding = 4\n    let bar_width = self.width().saturating_sub(27).min(40);\n    \n    // Create progress bar\n    let bar = ProgressBar::new()\n        .completed(level as usize)\n        .total(100)\n        .width(bar_width)\n        .style(BarStyle::Block);  // Uses █ and ░\n    \n    // Render bar to string\n    let bar_str = bar.render_to_string();\n    \n    // Build content with label and percentage\n    let mut content = Text::new(\"\");\n    content.append_styled(\"  Brightness: \", self.theme.label.clone());\n    content.append_styled(&bar_str, self.theme.brightness.clone());\n    content.append_styled(&format!(\" {:>3}%\", level), self.theme.value.clone());\n    content.append(\"  \");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .border_style(Style::new().color(self.theme.success.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n### Alternative: Custom Bar Rendering\nIf rich_rust ProgressBar doesn't fit exactly, custom render:\n```rust\nfn render_brightness_bar(&self, level: u8, width: usize) -> String {\n    let filled = (level as usize * width) / 100;\n    let empty = width - filled;\n    \n    format!(\"{}{}\", \n        \"█\".repeat(filled),\n        \"░\".repeat(empty)\n    )\n}\n```\n\n## Design Decisions\n\n### Progress Bar Style\n- Block style (█░) is universally recognized\n- High contrast between filled and empty\n- Works in most terminals with Unicode support\n\n### Green Success Border\n- Confirms the operation succeeded\n- Consistent with other success indicators\n- Not red (would imply error) or blue (informational)\n\n### Percentage Display\n- Right-aligned with fixed width (\" 50%\", \"100%\")\n- Numeric precision for exact value\n- Combined with visual bar for quick scanning\n\n### No Title\n- \"Brightness\" label is sufficient\n- Title would add visual noise\n- Simple, clean appearance\n\n### Width Calculation\n- Bar adapts to terminal width\n- Maximum 40 characters (readable at a glance)\n- Minimum ensures bar is visible\n\n## Edge Cases\n- 0%: All empty blocks, still visible\n- 100%: All filled blocks\n- Narrow terminal: Bar shrinks but stays functional\n- Very narrow (<30): May need to drop bar, show just number\n\n## Testing\n```rust\n#[test]\nfn brightness_bar_at_50_percent() {\n    let bar = render_brightness_bar(50, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '█').count(), 10);\n    assert_eq!(bar.chars().filter(|&c| c == '░').count(), 10);\n}\n\n#[test]\nfn brightness_bar_at_0_percent() {\n    let bar = render_brightness_bar(0, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '█').count(), 0);\n}\n\n#[test]\nfn brightness_bar_at_100_percent() {\n    let bar = render_brightness_bar(100, 20);\n    assert_eq!(bar.chars().filter(|&c| c == '░').count(), 0);\n}\n```\n\n## Acceptance Criteria\n- [ ] Brightness displays with visual progress bar\n- [ ] Bar uses block characters (█░)\n- [ ] Percentage shows exact value\n- [ ] Panel has success (green) border\n- [ ] Works for all values 0-100\n- [ ] Adapts to terminal width","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:06:48.092074463Z","created_by":"ubuntu","updated_at":"2026-01-19T21:06:48.137479302Z","compaction_level":0,"original_size":0,"labels":["brightness","phase-2","progress","rich-rust"],"dependencies":[{"issue_id":"bd-3k6","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:06:48.137441090Z","created_by":"ubuntu"},{"issue_id":"bd-3k6","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:06:48.131866123Z","created_by":"ubuntu"}]}
{"id":"bd-3lf","title":"Design and implement robot mode JSON structure","description":"## Purpose\nDefine consistent JSON structure for all dry-run command outputs.\n\n## Implementation\n\n### Base Structure\n\\`\\`\\`rust\n// src/output/dry_run.rs\nuse serde::Serialize;\n\n/// Common dry-run response wrapper\n#[derive(Debug, Serialize)]\npub struct DryRunResponse<T: Serialize> {\n    /// Always true in dry-run mode\n    pub dry_run: bool,\n    \n    /// The action that would be performed\n    pub action: String,\n    \n    /// Whether the operation would succeed\n    pub would_succeed: bool,\n    \n    /// If would_succeed is false, the reason why\n    pub failure_reason: Option<String>,\n    \n    /// Validation details\n    pub validation: ValidationDetails,\n    \n    /// Action-specific details\n    pub details: T,\n    \n    /// Device context\n    pub device: DeviceContext,\n}\n\n#[derive(Debug, Serialize)]\npub struct ValidationDetails {\n    /// Whether all inputs are valid\n    pub inputs_valid: bool,\n    /// List of validation errors\n    pub errors: Vec<ValidationError>,\n    /// List of validation warnings\n    pub warnings: Vec<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ValidationError {\n    pub field: String,\n    pub error: String,\n    pub suggestion: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct DeviceContext {\n    pub model: String,\n    pub serial: Option<String>,\n    pub connected: bool,\n    pub key_count: u8,\n    pub key_dimensions: (u32, u32),\n}\n\\`\\`\\`\n\n### Brightness Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"set_brightness\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"target_brightness\": 80,\n    \"current_brightness\": null,\n    \"brightness_change\": null\n  },\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"serial\": \"ABC123\",\n    \"connected\": true,\n    \"key_count\": 32,\n    \"key_dimensions\": [96, 96]\n  }\n}\n\\`\\`\\`\n\n### Set-Key Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key_image\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": [\"Image dimensions (256x256) will be resized to 96x96\"]\n  },\n  \"details\": {\n    \"key\": 5,\n    \"source\": {\n      \"path\": \"/home/user/icons/chrome.png\",\n      \"exists\": true,\n      \"readable\": true,\n      \"format\": \"png\",\n      \"dimensions\": [256, 256],\n      \"size_bytes\": 24576\n    },\n    \"processing\": {\n      \"resize_needed\": true,\n      \"target_dimensions\": [96, 96],\n      \"estimated_time_ms\": 45\n    }\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Set-Key Dry-Run (Failure)\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key_image\",\n  \"would_succeed\": false,\n  \"failure_reason\": \"Image file not found\",\n  \"validation\": {\n    \"inputs_valid\": false,\n    \"errors\": [\n      {\n        \"field\": \"image_path\",\n        \"error\": \"File not found: /home/user/missing.png\",\n        \"suggestion\": \"Check the file path or use --create-missing\"\n      }\n    ],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"key\": 5,\n    \"source\": {\n      \"path\": \"/home/user/missing.png\",\n      \"exists\": false,\n      \"readable\": false,\n      \"format\": null,\n      \"dimensions\": null,\n      \"size_bytes\": null\n    },\n    \"processing\": null\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Fill-Key Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"fill_key_color\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"key\": 10,\n    \"color\": {\n      \"input\": \"#FF5500\",\n      \"normalized\": \"#FF5500\",\n      \"rgb\": [255, 85, 0]\n    }\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Clear-Key Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"clear_key\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"key\": 15\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Set-Keys (Batch) Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"set_keys_batch\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": [\"3 images will be resized\"]\n  },\n  \"details\": {\n    \"directory\": \"/home/user/icons/\",\n    \"pattern\": \"{index}.png\",\n    \"operations\": [\n      {\n        \"key\": 0,\n        \"source\": \"/home/user/icons/0.png\",\n        \"would_succeed\": true,\n        \"resize_needed\": true\n      },\n      {\n        \"key\": 1,\n        \"source\": \"/home/user/icons/1.png\",\n        \"would_succeed\": true,\n        \"resize_needed\": false\n      },\n      {\n        \"key\": 2,\n        \"source\": null,\n        \"would_succeed\": false,\n        \"error\": \"No matching file for key 2\"\n      }\n    ],\n    \"summary\": {\n      \"total_keys\": 32,\n      \"matching_files\": 2,\n      \"would_succeed\": 2,\n      \"would_fail\": 1,\n      \"unmatched\": 29\n    }\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Clear-Keys (Batch) Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"clear_keys_batch\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"keys\": [0, 1, 2, 3, 4, 5, 6, 7],\n    \"pattern\": \"range\",\n    \"range_spec\": \"0-7\",\n    \"count\": 8\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n### Fill-Keys (Batch) Dry-Run\n\\`\\`\\`json\n{\n  \"dry_run\": true,\n  \"action\": \"fill_keys_batch\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"keys\": [8, 9, 10, 11, 12, 13, 14, 15],\n    \"pattern\": \"range\",\n    \"range_spec\": \"8-15\",\n    \"color\": {\n      \"input\": \"#00FF00\",\n      \"normalized\": \"#00FF00\",\n      \"rgb\": [0, 255, 0]\n    },\n    \"count\": 8\n  },\n  \"device\": {...}\n}\n\\`\\`\\`\n\n## Implementation Helper\n\\`\\`\\`rust\nimpl<T: Serialize> DryRunResponse<T> {\n    pub fn success(action: &str, details: T, device: DeviceContext) -> Self {\n        Self {\n            dry_run: true,\n            action: action.to_string(),\n            would_succeed: true,\n            failure_reason: None,\n            validation: ValidationDetails {\n                inputs_valid: true,\n                errors: vec![],\n                warnings: vec![],\n            },\n            details,\n            device,\n        }\n    }\n    \n    pub fn failure(\n        action: &str,\n        reason: &str,\n        errors: Vec<ValidationError>,\n        details: T,\n        device: DeviceContext,\n    ) -> Self {\n        Self {\n            dry_run: true,\n            action: action.to_string(),\n            would_succeed: false,\n            failure_reason: Some(reason.to_string()),\n            validation: ValidationDetails {\n                inputs_valid: false,\n                errors,\n                warnings: vec![],\n            },\n            details,\n            device,\n        }\n    }\n    \n    pub fn with_warnings(mut self, warnings: Vec<String>) -> Self {\n        self.validation.warnings = warnings;\n        self\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Consistent structure across all dry-run commands\n- [ ] would_succeed accurately predicts outcome\n- [ ] Validation errors include actionable suggestions\n- [ ] Device context always included\n- [ ] Batch operations show per-key details\n- [ ] Output is valid, parseable JSON\n\n## Logging Requirements\n- TRACE: (none - robot mode doesn't log)\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.936881067Z","created_by":"ubuntu","updated_at":"2026-01-19T21:31:47.042552188Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lf","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.946932873Z","created_by":"ubuntu"}]}
{"id":"bd-3ln","title":"Complete ProfileLoader extraction logic","description":"Finish the ProfileLoader implementation:\n1. from_zip(): Open and validate profile ZIP\n2. extract_to(): Extract to temp directory\n3. parse(): Parse manifest.json and profile.json\n4. Map Elgato structures to our types\n\nHandle version differences in Elgato format.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.194682502Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.204058626Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ln","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.204012749Z","created_by":"ubuntu"}]}
{"id":"bd-3lp","title":"Write comprehensive tests for declarative config","description":"## Test Coverage for Declarative YAML/TOML Configuration\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **YAML Parsing Tests**\n   - Valid YAML parses without error\n   - Invalid YAML returns clear syntax error with line number\n   - Missing required fields return helpful error\n   - Unknown fields ignored (forward compatibility)\n   - Comments preserved in round-trip (if supported)\n\n2. **TOML Parsing Tests**\n   - Valid TOML parses without error\n   - Invalid TOML returns clear syntax error\n   - Equivalent to YAML (same schema)\n\n3. **KeySelector Parsing Tests**\n   - Single key: \"0\", \"15\", \"31\"\n   - Range: \"8-15\", \"0-7\"\n   - Row: \"row-0\", \"row-3\"\n   - Default: \"default\"\n   - Invalid: \"32\", \"-1\", \"row-5\", \"abc\"\n\n4. **KeyConfig Parsing Tests**\n   - Image with absolute path: `/path/to/image.png`\n   - Image with relative path: `./icons/app.png`\n   - Image with home: `~/stream-deck/icon.png`\n   - Color hex: `\"#FF5500\"`\n   - Color RGB array: `[255, 85, 0]`\n   - Clear flag: `clear: true`\n   - Pattern: `pattern: \"~/icons/row2/{index}.png\"`\n\n5. **Path Resolution Tests**\n   - Absolute paths unchanged\n   - Relative paths resolved from config file location\n   - Home directory expanded correctly\n   - Non-existent paths return error with suggestion\n   - Permission denied returns clear error\n\n6. **Pattern Expansion Tests**\n   - `{index}` replaced with key number\n   - `{index:02d}` formats with leading zeros\n   - Multiple placeholders in one pattern\n   - Escaped braces `{{` and `}}`\n\n7. **Device Filtering Tests**\n   - Config with `device.model: StreamDeckXL` only applies to XL\n   - Config with `device.serial: ABC123` only applies to that device\n   - No filter applies to any device\n   - Mismatched filter returns clear message\n\n### Integration Tests (require MockDevice)\n\n1. **Full Config Application**\n   - Load YAML config with brightness + 32 keys\n   - Apply to MockDevice\n   - Verify all keys set correctly\n   - Verify brightness set correctly\n\n2. **Partial Config Application**\n   - Config with only some keys specified\n   - Unspecified keys unchanged\n   - Default rule applies to remaining\n\n3. **Diff Command**\n   - Shows keys that would change\n   - Shows keys that would stay same\n   - Shows brightness change\n   - Robot mode returns structured diff\n\n4. **Validate Command**\n   - Reports all errors (not just first)\n   - Validates image paths exist\n   - Validates color values\n   - Validates key indices for device\n   - Returns exit 0 for valid config\n\n5. **Config Layering**\n   - Base config + override config\n   - Override wins for same keys\n   - Both merged for different keys\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Workflow**\n   - `sd apply work.yaml` applies configuration\n   - `sd apply work` finds ~/.config/sd/profiles/work.yaml\n   - `sd validate work.yaml` validates without applying\n   - `sd diff work.yaml` shows what would change\n\n2. **Error Handling**\n   - Missing config file → clear error with path\n   - Invalid YAML → syntax error with line number\n   - Missing images → list of missing files\n   - Invalid colors → which color and why\n\n3. **Config Discovery**\n   - Finds configs in ~/.config/sd/profiles/\n   - Finds configs in XDG_CONFIG_HOME/sd/profiles/\n   - Lists available profiles with `sd config list`\n\n### Logging Requirements\n- TRACE: Each key being processed\n- DEBUG: Path resolution, pattern expansion details\n- INFO: Config loaded, apply complete with key count\n- WARN: Unknown config fields, skipped keys\n- ERROR: Parse errors, missing files, invalid values\n\n### Test Data\n- tests/fixtures/config/work.yaml - complete profile\n- tests/fixtures/config/gaming.yaml - another profile\n- tests/fixtures/config/minimal.yaml - just brightness\n- tests/fixtures/config/invalid-syntax.yaml - parse error\n- tests/fixtures/config/missing-images.yaml - path errors\n- tests/fixtures/config/work.toml - TOML equivalent","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:59.218810453Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:46.857942203Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lp","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:35.958349203Z","created_by":"ubuntu"},{"issue_id":"bd-3lp","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:59.229375715Z","created_by":"ubuntu"},{"issue_id":"bd-3lp","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:46.857908801Z","created_by":"ubuntu"}]}
{"id":"bd-3mz","title":"Implement apply command for declarative config","description":"## Purpose\nImplement the `sd apply <config>` command that applies a declarative configuration to the device.\n\n## CLI Interface\n\n```\nsd apply <CONFIG> [OPTIONS]\n\nArguments:\n  <CONFIG>  Path to config file, or profile name to load from ~/.config/sd/profiles/\n\nOptions:\n  --dry-run       Show what would change without applying\n  --force         Apply even if some keys would fail\n  --diff          Show diff before applying\n  --no-brightness Don't change brightness setting\n  --robot         Output JSON instead of human-readable\n```\n\n## Implementation\n\n```rust\n// src/commands/apply.rs\nuse std::path::Path;\nuse crate::config::{ProfileConfig, PathResolver, KeySelector, ResolvedKey};\nuse crate::device::DeviceOperations;\nuse crate::error::{Result, SdError};\nuse crate::output::{Output, ApplyResult, KeyApplyResult};\nuse tracing::{debug, info, warn, error, instrument};\n\n#[derive(Debug)]\npub struct ApplyOptions {\n    pub dry_run: bool,\n    pub force: bool,\n    pub show_diff: bool,\n    pub skip_brightness: bool,\n}\n\nimpl Default for ApplyOptions {\n    fn default() -> Self {\n        Self {\n            dry_run: false,\n            force: false,\n            show_diff: false,\n            skip_brightness: false,\n        }\n    }\n}\n\n#[instrument(skip(device, output), fields(config = %config_path.display()))]\npub async fn cmd_apply(\n    device: &mut dyn DeviceOperations,\n    config_path: &Path,\n    options: ApplyOptions,\n    output: &dyn Output,\n) -> Result<()> {\n    info!(\"Applying configuration\");\n    \n    // Load and parse config\n    let config = load_config(config_path)?;\n    debug!(name = ?config.name, \"Loaded configuration\");\n    \n    // Create path resolver\n    let resolver = PathResolver::new(config_path)?;\n    \n    // Check device filter if specified\n    if let Some(filter) = &config.device {\n        if !filter.matches(device.info()) {\n            return Err(SdError::ConfigInvalid(format!(\n                \"Config targets {} but connected device is {}\",\n                filter.description(),\n                device.info().model\n            )));\n        }\n    }\n    \n    // Resolve all selectors to concrete key assignments\n    let resolved = config.resolve(device.info(), &resolver)?;\n    debug!(key_count = resolved.keys.len(), \"Resolved configuration\");\n    \n    // Show diff if requested\n    if options.show_diff {\n        show_diff(device, &resolved, output).await?;\n        if options.dry_run {\n            return Ok(());\n        }\n    }\n    \n    // Dry run - just validate and report\n    if options.dry_run {\n        return output.dry_run_apply(&resolved, device.info());\n    }\n    \n    // Track results\n    let mut results = ApplyResult::new();\n    \n    // Apply brightness\n    if !options.skip_brightness {\n        if let Some(brightness) = resolved.brightness {\n            debug!(brightness, \"Setting brightness\");\n            match device.set_brightness(brightness).await {\n                Ok(()) => results.brightness_applied = Some(brightness),\n                Err(e) => {\n                    warn!(error = %e, \"Failed to set brightness\");\n                    results.brightness_error = Some(e.to_string());\n                    if !options.force {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n    }\n    \n    // Apply keys\n    for (index, key_config) in &resolved.keys {\n        debug!(key = index, config = ?key_config, \"Applying key\");\n        \n        let result = apply_key(device, *index, key_config).await;\n        \n        match &result {\n            Ok(()) => {\n                results.keys_succeeded.push(*index);\n            }\n            Err(e) => {\n                error!(key = index, error = %e, \"Failed to apply key\");\n                results.keys_failed.push(KeyApplyResult {\n                    key: *index,\n                    error: e.to_string(),\n                });\n                \n                if !options.force {\n                    return Err(e.clone());\n                }\n            }\n        }\n    }\n    \n    info!(\n        succeeded = results.keys_succeeded.len(),\n        failed = results.keys_failed.len(),\n        \"Apply completed\"\n    );\n    \n    output.apply_result(&results)\n}\n\nasync fn apply_key(\n    device: &mut dyn DeviceOperations,\n    index: u8,\n    config: &ResolvedKey,\n) -> Result<()> {\n    match config {\n        ResolvedKey::Image(path) => {\n            device.set_key_image(index, path).await\n        }\n        ResolvedKey::Color(r, g, b) => {\n            device.fill_key_color(index, *r, *g, *b).await\n        }\n        ResolvedKey::Clear => {\n            device.clear_key(index).await\n        }\n    }\n}\n\nfn load_config(path: &Path) -> Result<ProfileConfig> {\n    let content = std::fs::read_to_string(path)\n        .map_err(|e| SdError::ConfigNotFound(format!(\"{}: {}\", path.display(), e)))?;\n    \n    // Determine format from extension\n    let ext = path.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| e.to_lowercase());\n    \n    match ext.as_deref() {\n        Some(\"yaml\" | \"yml\") => {\n            serde_yaml::from_str(&content)\n                .map_err(|e| SdError::ConfigParse(format!(\"YAML error: {}\", e)))\n        }\n        Some(\"toml\") => {\n            toml::from_str(&content)\n                .map_err(|e| SdError::ConfigParse(format!(\"TOML error: {}\", e)))\n        }\n        Some(\"json\") => {\n            serde_json::from_str(&content)\n                .map_err(|e| SdError::ConfigParse(format!(\"JSON error: {}\", e)))\n        }\n        _ => Err(SdError::ConfigParse(\n            \"Config file must have .yaml, .yml, .toml, or .json extension\".to_string()\n        ))\n    }\n}\n\nasync fn show_diff(\n    device: &dyn DeviceOperations,\n    resolved: &ResolvedProfile,\n    output: &dyn Output,\n) -> Result<()> {\n    // For now, we don't have a way to read current state\n    // Just show what would be set\n    output.apply_diff(resolved)\n}\n```\n\n## Robot Mode JSON Output\n\n```json\n{\n  \"success\": true,\n  \"action\": \"apply\",\n  \"config\": {\n    \"path\": \"/home/user/.config/sd/work.yaml\",\n    \"name\": \"Work Profile\"\n  },\n  \"results\": {\n    \"brightness\": {\n      \"applied\": true,\n      \"value\": 80\n    },\n    \"keys\": {\n      \"total\": 32,\n      \"succeeded\": 30,\n      \"failed\": 2,\n      \"skipped\": 0\n    },\n    \"details\": [\n      {\"key\": 0, \"action\": \"image\", \"path\": \"~/icons/chrome.png\", \"success\": true},\n      {\"key\": 1, \"action\": \"image\", \"path\": \"~/icons/slack.png\", \"success\": true},\n      {\"key\": 2, \"action\": \"color\", \"color\": \"#FF5500\", \"success\": true},\n      {\"key\": 15, \"action\": \"image\", \"path\": \"~/missing.png\", \"success\": false, \"error\": \"Image not found\"}\n    ]\n  },\n  \"timing_ms\": 1250\n}\n```\n\n### Dry Run Output\n\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"apply\",\n  \"would_succeed\": true,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": [\"Key 15: Image file not found\"]\n  },\n  \"planned_operations\": {\n    \"brightness\": 80,\n    \"keys\": [\n      {\"key\": 0, \"action\": \"image\", \"path\": \"~/icons/chrome.png\", \"exists\": true},\n      {\"key\": 1, \"action\": \"image\", \"path\": \"~/icons/slack.png\", \"exists\": true},\n      {\"key\": 2, \"action\": \"color\", \"color\": \"#FF5500\"},\n      {\"key\": 15, \"action\": \"image\", \"path\": \"~/missing.png\", \"exists\": false}\n    ]\n  },\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"key_count\": 32\n  }\n}\n```\n\n## Human Output\n\n```\nApplying work.yaml to Stream Deck XL (serial: ABC123)\n\nBrightness: 50 → 80\nKey  0: ~/icons/chrome.png\nKey  1: ~/icons/slack.png\nKey  2: #FF5500\nKey  3: (clear)\n...\nKey 15: ~/missing.png [MISSING]\n\nSummary: 31 keys applied, 1 failed\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::device::MockDevice;\n    use crate::output::TestOutput;\n    use tempfile::TempDir;\n    use std::fs;\n    \n    #[tokio::test]\n    async fn test_apply_simple_config() {\n        let temp = TempDir::new().unwrap();\n        \n        // Create a test image\n        let img_path = temp.path().join(\"test.png\");\n        fs::write(&img_path, &[0u8; 100]).unwrap();\n        \n        // Create config file\n        let config_content = format!(r#\"\nname: Test Profile\nbrightness: 80\nkeys:\n  0:\n    image: {}\n  1:\n    color: \"#FF0000\"\n  2:\n    clear: true\n\"#, img_path.display());\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config_content).unwrap();\n        \n        // Apply\n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        cmd_apply(\n            &mut device,\n            &config_path,\n            ApplyOptions::default(),\n            &output,\n        ).await.unwrap();\n        \n        // Verify\n        assert_eq!(device.brightness(), 80);\n        device.assert_key_has_image(0);\n        device.assert_key_color(1, 255, 0, 0);\n        device.assert_key_cleared(2);\n    }\n    \n    #[tokio::test]\n    async fn test_apply_dry_run() {\n        let temp = TempDir::new().unwrap();\n        \n        let config_content = r#\"\nbrightness: 80\nkeys:\n  0:\n    color: \"#FF0000\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config_content).unwrap();\n        \n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        cmd_apply(\n            &mut device,\n            &config_path,\n            ApplyOptions { dry_run: true, ..Default::default() },\n            &output,\n        ).await.unwrap();\n        \n        // Nothing should be applied\n        assert_ne!(device.brightness(), 80);\n    }\n    \n    #[tokio::test]\n    async fn test_apply_force_continues_on_error() {\n        let temp = TempDir::new().unwrap();\n        \n        let config_content = r#\"\nkeys:\n  0:\n    image: /nonexistent/missing.png\n  1:\n    color: \"#00FF00\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config_content).unwrap();\n        \n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        // Without force, should fail\n        let result = cmd_apply(\n            &mut device,\n            &config_path,\n            ApplyOptions::default(),\n            &output,\n        ).await;\n        assert!(result.is_err());\n        \n        // With force, should continue\n        let mut device = MockDevice::new_xl();\n        let result = cmd_apply(\n            &mut device,\n            &config_path,\n            ApplyOptions { force: true, ..Default::default() },\n            &output,\n        ).await;\n        \n        // Key 1 should be applied even though key 0 failed\n        device.assert_key_color(1, 0, 255, 0);\n    }\n    \n    #[tokio::test]\n    async fn test_apply_device_filter() {\n        let temp = TempDir::new().unwrap();\n        \n        let config_content = r#\"\ndevice:\n  model: StreamDeckMini\nkeys:\n  0:\n    color: \"#FF0000\"\n\"#;\n        \n        let config_path = temp.path().join(\"config.yaml\");\n        fs::write(&config_path, config_content).unwrap();\n        \n        let mut device = MockDevice::new_xl(); // XL, not Mini\n        let output = TestOutput::new();\n        \n        let result = cmd_apply(\n            &mut device,\n            &config_path,\n            ApplyOptions::default(),\n            &output,\n        ).await;\n        \n        // Should fail due to device mismatch\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_load_config_yaml() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.yaml\");\n        fs::write(&path, \"brightness: 80\\n\").unwrap();\n        \n        let config = load_config(&path).unwrap();\n        assert_eq!(config.brightness, Some(80));\n    }\n    \n    #[test]\n    fn test_load_config_toml() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.toml\");\n        fs::write(&path, \"brightness = 80\\n\").unwrap();\n        \n        let config = load_config(&path).unwrap();\n        assert_eq!(config.brightness, Some(80));\n    }\n    \n    #[test]\n    fn test_load_config_invalid_extension() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(&path, \"brightness: 80\\n\").unwrap();\n        \n        let result = load_config(&path);\n        assert!(result.is_err());\n    }\n}\n```\n\n## Success Criteria\n- [ ] Loads YAML, TOML, and JSON configs\n- [ ] Resolves all key selectors correctly\n- [ ] Applies brightness when specified\n- [ ] Applies all key configurations\n- [ ] --dry-run validates without applying\n- [ ] --force continues after failures\n- [ ] Device filter prevents mismatched configs\n- [ ] Robot mode outputs structured JSON\n- [ ] Human mode shows clear progress\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Per-key application attempts\n- DEBUG: Config loading, resolution details\n- INFO: Apply start/complete with counts\n- WARN: Skipped keys, partial failures\n- ERROR: Failed key applications with details","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.880977922Z","created_by":"ubuntu","updated_at":"2026-01-19T21:43:43.254514282Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3mz","depends_on_id":"bd-169","type":"blocks","created_at":"2026-01-19T21:43:41.101739430Z","created_by":"ubuntu"},{"issue_id":"bd-3mz","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.896482794Z","created_by":"ubuntu"},{"issue_id":"bd-3mz","depends_on_id":"bd-2vg","type":"blocks","created_at":"2026-01-19T21:43:43.254466481Z","created_by":"ubuntu"},{"issue_id":"bd-3mz","depends_on_id":"bd-3fo","type":"blocks","created_at":"2026-01-19T21:43:41.828318916Z","created_by":"ubuntu"},{"issue_id":"bd-3mz","depends_on_id":"bd-3qj","type":"blocks","created_at":"2026-01-19T21:43:42.472377860Z","created_by":"ubuntu"},{"issue_id":"bd-3mz","depends_on_id":"bd-a1n","type":"blocks","created_at":"2026-01-19T21:43:40.461008575Z","created_by":"ubuntu"}]}
{"id":"bd-3p6","title":"EPIC: Image Caching with Content-Addressable Storage","description":"## Overview\n**Rank: #9 of 15** | **Impact: Medium** | **Effort: Low** | **Confidence: High**\n\nCache resized images by content hash so repeated operations are instant.\n\n## Problem Statement\nEvery `sd set-key` call:\n1. Opens the image file\n2. Decodes the image format (PNG, JPG, etc.)\n3. Resizes to device key dimensions (e.g., 72x72)\n4. Encodes to device format\n5. Sends to device\n\nSteps 1-4 take ~50-150ms per image depending on source size. For a 32-key device, full setup takes 2-5 seconds. Repeated applications of the same configuration waste this time.\n\n## Solution\nContent-addressable cache that stores pre-processed images:\n```\n~/.cache/sd/\n└── images/\n    ├── a1b2c3d4e5f6...72x72.bin    # Pre-resized, ready to send\n    ├── f6e5d4c3b2a1...72x72.bin\n    └── ...\n```\n\nCache key: `SHA256(file_content + target_dimensions)`\n\n```bash\n# First run: processes all images (~3s)\nsd set-keys ~/layout/\n\n# Second run: uses cache (~0.3s)\nsd set-keys ~/layout/\n\n# Cache statistics\nsd cache stats\n# Output:\n# Cache location: ~/.cache/sd/images/\n# Entries: 47\n# Size: 2.3 MB\n# Hit rate: 94%\n\n# Clear cache\nsd cache clear\n```\n\n## Why This Is #9 Priority\n1. **Performance**: 10x speedup for repeated operations\n2. **Agent efficiency**: Agents often apply same configs repeatedly\n3. **Batch speedup**: Setting 32 keys goes from ~3s to ~0.3s\n4. **Low effort**: Well-understood pattern, ~100 lines\n5. **Invisible improvement**: Users just notice things are faster\n\n## Implementation Approach\n\n### Phase 1: Cache Infrastructure\n```rust\n// In src/cache.rs (new file)\nuse sha2::{Sha256, Digest};\nuse std::path::PathBuf;\n\npub struct ImageCache {\n    cache_dir: PathBuf,\n}\n\nimpl ImageCache {\n    pub fn new() -> Result<Self> {\n        let cache_dir = dirs::cache_dir()\n            .ok_or(SdError::NoCacheDir)?\n            .join(\"sd\")\n            .join(\"images\");\n        std::fs::create_dir_all(&cache_dir)?;\n        Ok(Self { cache_dir })\n    }\n    \n    /// Generate cache key from source file and target dimensions\n    fn cache_key(source: &Path, width: u32, height: u32) -> String {\n        let content = std::fs::read(source).unwrap_or_default();\n        let mut hasher = Sha256::new();\n        hasher.update(&content);\n        hasher.update(width.to_le_bytes());\n        hasher.update(height.to_le_bytes());\n        let hash = hasher.finalize();\n        format\\!(\"{:x}-{}x{}.bin\", hash, width, height)\n    }\n    \n    /// Get cached image or None if not cached\n    pub fn get(&self, source: &Path, width: u32, height: u32) -> Option<Vec<u8>> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::read(&cache_path).ok()\n    }\n    \n    /// Store processed image in cache\n    pub fn put(&self, source: &Path, width: u32, height: u32, data: &[u8]) -> Result<()> {\n        let key = Self::cache_key(source, width, height);\n        let cache_path = self.cache_dir.join(&key);\n        std::fs::write(&cache_path, data)?;\n        Ok(())\n    }\n    \n    /// Get cache statistics\n    pub fn stats(&self) -> CacheStats {\n        let entries: Vec<_> = std::fs::read_dir(&self.cache_dir)\n            .map(|rd| rd.filter_map(|e| e.ok()).collect())\n            .unwrap_or_default();\n        \n        let total_size: u64 = entries.iter()\n            .filter_map(|e| e.metadata().ok())\n            .map(|m| m.len())\n            .sum();\n        \n        CacheStats {\n            location: self.cache_dir.clone(),\n            entries: entries.len(),\n            size_bytes: total_size,\n        }\n    }\n    \n    /// Clear all cached images\n    pub fn clear(&self) -> Result<usize> {\n        let entries = std::fs::read_dir(&self.cache_dir)?;\n        let mut count = 0;\n        for entry in entries.filter_map(|e| e.ok()) {\n            if entry.path().extension().map(|e| e == \"bin\").unwrap_or(false) {\n                std::fs::remove_file(entry.path())?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }\n}\n\n#[derive(Debug)]\npub struct CacheStats {\n    pub location: PathBuf,\n    pub entries: usize,\n    pub size_bytes: u64,\n}\n```\n\n### Phase 2: Integration with set_key_image\n```rust\n// In src/main.rs or src/device.rs\nfn set_key_image_cached(\n    device: &Device,\n    key: u8,\n    path: &Path,\n    cache: &ImageCache,\n) -> Result<()> {\n    let (width, height) = device.info().key_size();\n    \n    // Check cache first\n    if let Some(data) = cache.get(path, width, height) {\n        device.set_key_raw(key, &data)?;\n        return Ok(());\n    }\n    \n    // Cache miss: process image\n    let img = image::open(path)?;\n    let resized = img.resize_exact(width, height, FilterType::Lanczos3);\n    let data = encode_for_device(&resized)?;\n    \n    // Store in cache\n    cache.put(path, width, height, &data)?;\n    \n    // Send to device\n    device.set_key_raw(key, &data)?;\n    Ok(())\n}\n```\n\n### Phase 3: Cache Commands\n```rust\n// In src/cli/mod.rs\nCache {\n    #[command(subcommand)]\n    action: CacheAction,\n}\n\n#[derive(Subcommand)]\nenum CacheAction {\n    /// Show cache statistics\n    Stats,\n    /// Clear all cached images\n    Clear,\n    /// Show cache location\n    Location,\n}\n```\n\n## Cache Invalidation Strategy\nThe content-addressable approach means:\n- If source file changes, hash changes, new cache entry created\n- Old entries become orphaned but harmless\n- Periodic cleanup can remove orphaned entries\n- No explicit invalidation needed for correctness\n\n## Key Design Decisions\n1. **Content-addressable**: Hash-based keys ensure correctness\n2. **Include dimensions in key**: Same image at different sizes = different entries\n3. **Binary format**: Store device-ready bytes, not intermediate images\n4. **Lazy population**: Only cache images that are actually used\n5. **Simple cleanup**: `sd cache clear` removes everything\n\n## Success Criteria\n- [ ] Cache directory created at ~/.cache/sd/images/\n- [ ] Repeated set-key calls use cache (measurable speedup)\n- [ ] Cache key includes source content hash and target dimensions\n- [ ] `sd cache stats` shows cache statistics\n- [ ] `sd cache clear` removes all cached entries\n- [ ] Cache miss processes and stores image\n- [ ] Robot mode reports cache hit/miss\n\n## Files to Create/Modify\n- `src/cache.rs`: New cache module\n- `src/cli/mod.rs`: Add Cache command\n- `src/main.rs`: Integrate cache into set-key operations\n- `Cargo.toml`: Add sha2 dependency\n\n## Dependencies\n- Soft: BATCH-OPS benefits most from caching (many images at once)\n\n## Estimated Subtasks\n1. Add sha2 dependency to Cargo.toml\n2. Implement ImageCache struct with get/put\n3. Implement cache key generation\n4. Integrate cache into set_key_image\n5. Add cache stats command\n6. Add cache clear command\n7. Add robot mode cache hit/miss reporting\n8. Write tests","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-19T18:19:23.156441630Z","created_by":"ubuntu","updated_at":"2026-01-19T18:19:23.195793021Z","compaction_level":0,"original_size":0,"labels":["cache","optimization","performance","priority-9"]}
{"id":"bd-3pm","title":"Implement init --import command","description":"## Purpose\nImplement the `sd init --import <file>` command to import Elgato Stream Deck profile files.\n\n## CLI Interface\n\n```\nsd init --import <FILE> [OPTIONS]\n\nArguments:\n  <FILE>  Path to .streamDeckProfile file\n\nOptions:\n  --name <NAME>     Override profile name (default: from profile)\n  --force           Overwrite existing profile with same name\n  --dry-run         Show what would be imported without saving\n  --robot           Output JSON instead of human-readable\n```\n\n## Implementation\n\n```rust\n// src/commands/init.rs\nuse std::path::Path;\nuse crate::config::{ProfileDb, ProfileLoader, get_config_dir};\nuse crate::error::{Result, SdError};\nuse crate::output::{Output, ImportResult};\nuse tracing::{debug, info, warn, instrument};\n\n#[derive(Debug)]\npub struct ImportOptions {\n    pub profile_path: PathBuf,\n    pub name_override: Option<String>,\n    pub force: bool,\n    pub dry_run: bool,\n}\n\n#[instrument(skip(output), fields(profile = %options.profile_path.display()))]\npub fn cmd_init_import(\n    options: ImportOptions,\n    output: &dyn Output,\n) -> Result<ImportResult> {\n    info!(\"Importing profile\");\n    \n    // Validate file exists\n    if !options.profile_path.exists() {\n        return Err(SdError::ConfigNotFound(\n            options.profile_path.display().to_string()\n        ));\n    }\n    \n    // Validate file extension\n    let ext = options.profile_path.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| e.to_lowercase());\n    \n    if ext.as_deref() != Some(\"streamdeckprofile\") {\n        warn!(ext = ?ext, \"Unexpected file extension\");\n        // Continue anyway, might still be valid\n    }\n    \n    // Initialize database\n    let config_dir = get_config_dir()?;\n    let db_path = config_dir.join(\"profiles.db\");\n    let db = ProfileDb::open(&db_path)?;\n    \n    // Create loader\n    let loader = ProfileLoader::new(&db);\n    \n    // Preview mode - analyze without importing\n    if options.dry_run {\n        return preview_import(&options.profile_path, output);\n    }\n    \n    // Check for existing profile with same name\n    let file_stem = options.profile_path.file_stem()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"Imported Profile\");\n    \n    let profile_name = options.name_override.as_deref()\n        .unwrap_or(file_stem);\n    \n    if let Ok(packages) = db.list_packages() {\n        if let Some(existing) = packages.iter().find(|p| p.name == profile_name) {\n            if options.force {\n                debug!(id = existing.id, \"Deleting existing profile\");\n                db.delete_package(existing.id)?;\n            } else {\n                return Err(SdError::ConfigInvalid(format!(\n                    \"Profile '{}' already exists. Use --force to overwrite.\",\n                    profile_name\n                )));\n            }\n        }\n    }\n    \n    // Perform import\n    info!(path = %options.profile_path.display(), \"Loading profile\");\n    let package_id = loader.load_file(&options.profile_path)?;\n    \n    // Gather import statistics\n    let result = gather_import_stats(&db, package_id, profile_name)?;\n    \n    info!(\n        profile = profile_name,\n        pages = result.page_count,\n        actions = result.action_count,\n        images = result.image_count,\n        \"Import complete\"\n    );\n    \n    output.import_result(&result)\n}\n\nfn preview_import(path: &Path, output: &dyn Output) -> Result<ImportResult> {\n    use std::io::Cursor;\n    use zip::ZipArchive;\n    \n    let file = std::fs::File::open(path)?;\n    let mut archive = ZipArchive::new(file)\n        .map_err(|e| SdError::Other(format!(\"Invalid ZIP: {}\", e)))?;\n    \n    // Count contents without actually importing\n    let mut profile_count = 0;\n    let mut page_count = 0;\n    let mut image_count = 0;\n    \n    for i in 0..archive.len() {\n        let entry = archive.by_index(i)?;\n        let name = entry.name();\n        \n        if name.ends_with(\".sdProfile/manifest.json\") {\n            profile_count += 1;\n        } else if name.contains(\"/manifest.json\") && name.contains(\".sdProfile/\") {\n            page_count += 1;\n        } else if name.contains(\"/Images/\") && !entry.is_dir() {\n            image_count += 1;\n        }\n    }\n    \n    let result = ImportResult {\n        dry_run: true,\n        profile_name: path.file_stem()\n            .and_then(|s| s.to_str())\n            .unwrap_or(\"Unknown\")\n            .to_string(),\n        source_path: path.to_path_buf(),\n        profile_count,\n        page_count,\n        action_count: 0, // Would need deeper parsing\n        image_count,\n        warnings: vec![],\n    };\n    \n    output.import_result(&result)\n}\n\nfn gather_import_stats(\n    db: &ProfileDb,\n    package_id: i64,\n    profile_name: &str,\n) -> Result<ImportResult> {\n    let profiles = db.list_profiles(package_id)?;\n    let profile_count = profiles.len();\n    \n    let mut page_count = 0;\n    let mut action_count = 0;\n    \n    for profile in &profiles {\n        let pages = db.list_pages(profile.id)?;\n        page_count += pages.len();\n        \n        for page in &pages {\n            let actions = db.list_actions(page.id)?;\n            action_count += actions.len();\n        }\n    }\n    \n    let images = db.list_images(package_id)?;\n    let image_count = images.len();\n    \n    Ok(ImportResult {\n        dry_run: false,\n        profile_name: profile_name.to_string(),\n        source_path: PathBuf::new(), // Not stored in DB\n        profile_count,\n        page_count,\n        action_count,\n        image_count,\n        warnings: vec![],\n    })\n}\n```\n\n## Robot Mode JSON Output\n\n### Success\n```json\n{\n  \"success\": true,\n  \"action\": \"import_profile\",\n  \"result\": {\n    \"dry_run\": false,\n    \"profile_name\": \"My Work Setup\",\n    \"source_path\": \"/home/user/Downloads/MySetup.streamDeckProfile\",\n    \"statistics\": {\n      \"profiles\": 1,\n      \"pages\": 3,\n      \"actions\": 24,\n      \"images\": 18\n    },\n    \"warnings\": []\n  }\n}\n```\n\n### Dry Run\n```json\n{\n  \"success\": true,\n  \"action\": \"import_profile\",\n  \"result\": {\n    \"dry_run\": true,\n    \"profile_name\": \"My Work Setup\",\n    \"source_path\": \"/home/user/Downloads/MySetup.streamDeckProfile\",\n    \"would_import\": {\n      \"profiles\": 1,\n      \"pages\": 3,\n      \"images\": 18\n    },\n    \"warnings\": [\"Action count not available in preview mode\"]\n  }\n}\n```\n\n### Error (Profile Exists)\n```json\n{\n  \"success\": false,\n  \"error\": \"config_invalid\",\n  \"message\": \"Profile 'My Work Setup' already exists. Use --force to overwrite.\",\n  \"suggestion\": \"Use --force to replace the existing profile\"\n}\n```\n\n## Human Mode Output\n\n```\nImporting My Work Setup from MySetup.streamDeckProfile...\n\nProfiles:    1\nPages:       3\nActions:     24\nImages:      18\n\n✓ Profile imported successfully\n\nUse 'sd config show \"My Work Setup\"' to view the configuration\nUse 'sd apply \"My Work Setup\"' to apply to your device\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::output::TestOutput;\n    use tempfile::TempDir;\n    use std::fs;\n    \n    fn create_test_profile(dir: &Path) -> PathBuf {\n        use std::io::{Cursor, Write};\n        use zip::write::SimpleFileOptions;\n        use zip::ZipWriter;\n        \n        let mut buf = Vec::new();\n        {\n            let cursor = Cursor::new(&mut buf);\n            let mut zip = ZipWriter::new(cursor);\n            let opts = SimpleFileOptions::default();\n            \n            // package.json\n            zip.start_file(\"package.json\", opts).unwrap();\n            write!(zip, r#\"{{\"AppVersion\":\"7.1.0\",\"DeviceModel\":\"TEST\",\"FormatVersion\":1,\"RequiredPlugins\":[]}}\"#).unwrap();\n            \n            // profile manifest\n            zip.start_file(\"Profiles/test.sdProfile/manifest.json\", opts).unwrap();\n            write!(zip, r#\"{{\"Device\":{{\"Model\":\"TEST\",\"UUID\":\"uuid\"}},\"Name\":\"Test\",\"Pages\":{{\"Current\":\"p1\",\"Default\":\"p1\",\"Pages\":[\"p1\"]}},\"Version\":\"3.0\"}}\"#).unwrap();\n            \n            // page manifest\n            zip.start_file(\"Profiles/test.sdProfile/p1/manifest.json\", opts).unwrap();\n            write!(zip, r#\"{{\"Controllers\":[{{\"Actions\":{{}}}}]}}\"#).unwrap();\n            \n            zip.finish().unwrap();\n        }\n        \n        let path = dir.join(\"test.streamDeckProfile\");\n        fs::write(&path, buf).unwrap();\n        path\n    }\n    \n    #[test]\n    fn test_import_new_profile() {\n        let temp = TempDir::new().unwrap();\n        let profile_path = create_test_profile(temp.path());\n        \n        // Set up temp config dir\n        let config_dir = temp.path().join(\"config\");\n        std::env::set_var(\"SD_CONFIG_DIR\", &config_dir);\n        \n        let output = TestOutput::new();\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: None,\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        ).unwrap();\n        \n        assert!(!result.dry_run);\n        assert!(result.profile_count > 0);\n    }\n    \n    #[test]\n    fn test_import_dry_run() {\n        let temp = TempDir::new().unwrap();\n        let profile_path = create_test_profile(temp.path());\n        \n        let output = TestOutput::new();\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: None,\n                force: false,\n                dry_run: true,\n            },\n            &output,\n        ).unwrap();\n        \n        assert!(result.dry_run);\n    }\n    \n    #[test]\n    fn test_import_missing_file() {\n        let output = TestOutput::new();\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: PathBuf::from(\"/nonexistent/profile.streamDeckProfile\"),\n                name_override: None,\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        );\n        \n        assert!(matches!(result, Err(SdError::ConfigNotFound(_))));\n    }\n    \n    #[test]\n    fn test_import_with_name_override() {\n        let temp = TempDir::new().unwrap();\n        let profile_path = create_test_profile(temp.path());\n        \n        let config_dir = temp.path().join(\"config\");\n        std::env::set_var(\"SD_CONFIG_DIR\", &config_dir);\n        \n        let output = TestOutput::new();\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: Some(\"Custom Name\".to_string()),\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        ).unwrap();\n        \n        assert_eq!(result.profile_name, \"Custom Name\");\n    }\n    \n    #[test]\n    fn test_import_duplicate_without_force() {\n        let temp = TempDir::new().unwrap();\n        let profile_path = create_test_profile(temp.path());\n        \n        let config_dir = temp.path().join(\"config\");\n        std::env::set_var(\"SD_CONFIG_DIR\", &config_dir);\n        \n        let output = TestOutput::new();\n        \n        // First import succeeds\n        cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: Some(\"Test Profile\".to_string()),\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        ).unwrap();\n        \n        // Second import without force fails\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: Some(\"Test Profile\".to_string()),\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        );\n        \n        assert!(matches!(result, Err(SdError::ConfigInvalid(_))));\n    }\n    \n    #[test]\n    fn test_import_duplicate_with_force() {\n        let temp = TempDir::new().unwrap();\n        let profile_path = create_test_profile(temp.path());\n        \n        let config_dir = temp.path().join(\"config\");\n        std::env::set_var(\"SD_CONFIG_DIR\", &config_dir);\n        \n        let output = TestOutput::new();\n        \n        // First import\n        cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: Some(\"Test Profile\".to_string()),\n                force: false,\n                dry_run: false,\n            },\n            &output,\n        ).unwrap();\n        \n        // Second import with force succeeds\n        let result = cmd_init_import(\n            ImportOptions {\n                profile_path: profile_path.clone(),\n                name_override: Some(\"Test Profile\".to_string()),\n                force: true,\n                dry_run: false,\n            },\n            &output,\n        );\n        \n        assert!(result.is_ok());\n    }\n}\n```\n\n## Success Criteria\n- [ ] Loads valid .streamDeckProfile files\n- [ ] Extracts all images to config storage\n- [ ] Stores profile data in SQLite database\n- [ ] --dry-run previews without importing\n- [ ] --force overwrites existing profiles\n- [ ] --name overrides imported name\n- [ ] Robot mode outputs structured JSON\n- [ ] All tests pass\n\n## Dependencies\n- ProfileLoader in src/config/loader.rs (already implemented)\n- ProfileDb in src/config/db.rs (already implemented)\n\n## Logging Requirements\n- TRACE: ZIP entry processing\n- DEBUG: Profile/page/action counts\n- INFO: Import start/complete with summary\n- WARN: Unexpected file extensions, unsupported actions\n- ERROR: Invalid ZIP, missing manifests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.417682158Z","created_by":"ubuntu","updated_at":"2026-01-19T21:47:38.152928690Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pm","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.427205538Z","created_by":"ubuntu"}]}
{"id":"bd-3pp","title":"Add Fish output format","description":"With --format fish:\n- Use fish shell syntax\n- Different variable handling\n- Proper path quoting for fish","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:03.698067351Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:03.710521380Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3pp","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:03.710482687Z","created_by":"ubuntu"}]}
{"id":"bd-3pu","title":"EPIC: Shell Completion Scripts","description":"## Overview\n**Rank: #5 of 15** | **Impact: Medium** | **Effort: Very Low** | **Confidence: Very High**\n\nFully implement the `sd completions <shell>` command to generate shell completion scripts for bash, zsh, fish, and PowerShell.\n\n## Problem Statement\nThe `sd completions` command is already stubbed in the CLI definition but the actual clap_complete integration is missing. Without shell completions:\n- Users must remember exact command names and flags\n- Tab completion shows nothing or wrong suggestions\n- The CLI feels unpolished compared to mature tools\n- Discovery of features requires reading help text\n\n## Solution\nComplete the existing stubbed command:\n```bash\n# Generate completions for your shell\nsd completions bash > ~/.local/share/bash-completion/completions/sd\nsd completions zsh > ~/.zfunc/_sd\nsd completions fish > ~/.config/fish/completions/sd.fish\nsd completions powershell > sd.ps1\n\n# Then enjoy tab completion\nsd <TAB>\n# list  info  brightness  set-key  fill-key  clear-key  ...\n\nsd set-key <TAB>\n# Shows: 0 1 2 3 4 5 ... (key indices)\n\nsd --<TAB>\n# Shows: --robot --format --serial --help --version\n```\n\n## Why This Is #5 Priority\n1. **Already stubbed**: The command exists, just needs wiring\n2. **Very low effort**: ~20 lines using clap_complete crate\n3. **High polish signal**: Completions indicate a mature, well-maintained CLI\n4. **Developer experience**: Makes daily use much more pleasant\n5. **Standard pattern**: clap_complete is the canonical solution\n\n## Implementation Approach\n```rust\n// Add to Cargo.toml\n[dependencies]\nclap_complete = \"4\"\n\n// In src/cli/mod.rs - already exists\n#[derive(Subcommand)]\npub enum Command {\n    /// Generate shell completion scripts\n    Completions {\n        /// Shell to generate completions for\n        #[arg(value_enum)]\n        shell: clap_complete::Shell,\n    },\n    // ...\n}\n\n// In main.rs - implement the handler\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n\n// In main dispatch\nCommand::Completions { shell } => cmd_completions(shell),\n```\n\n## Supported Shells\nclap_complete supports:\n- **Bash**: Most common on Linux\n- **Zsh**: Default on macOS, popular on Linux\n- **Fish**: Modern shell with excellent completion support\n- **PowerShell**: Windows default\n- **Elvish**: Niche but supported\n\n## Installation Instructions (to include in help)\n```\nINSTALLATION:\n\nBash (Linux):\n  sd completions bash > ~/.local/share/bash-completion/completions/sd\n  # Or system-wide: sudo sd completions bash > /etc/bash_completion.d/sd\n\nBash (macOS with Homebrew):\n  sd completions bash > $(brew --prefix)/etc/bash_completion.d/sd\n\nZsh:\n  sd completions zsh > ~/.zfunc/_sd\n  # Ensure ~/.zfunc is in fpath and compinit is called\n\nFish:\n  sd completions fish > ~/.config/fish/completions/sd.fish\n\nPowerShell:\n  sd completions powershell >> $PROFILE\n```\n\n## Key Design Decisions\n1. **Use clap_complete**: Standard solution, well-maintained\n2. **Output to stdout**: Let users redirect to appropriate location\n3. **Include installation help**: Show how to install for each shell\n4. **All shells supported**: Dont pick favorites, support what clap_complete offers\n\n## Success Criteria\n- [ ] `sd completions bash` generates valid bash completions\n- [ ] `sd completions zsh` generates valid zsh completions\n- [ ] `sd completions fish` generates valid fish completions\n- [ ] `sd completions powershell` generates valid PowerShell completions\n- [ ] Completions include all commands and flags\n- [ ] Help text includes installation instructions\n\n## Files to Modify\n- `Cargo.toml`: Add clap_complete dependency\n- `src/cli/mod.rs`: Ensure Shell enum is properly defined\n- `src/main.rs`: Implement cmd_completions handler\n\n## Dependencies\nNone - standalone feature, uses existing CLI structure\n\n## Estimated Subtasks\n1. Add clap_complete to Cargo.toml\n2. Implement cmd_completions handler in main.rs\n3. Test generated completions for bash\n4. Test generated completions for zsh\n5. Test generated completions for fish\n6. Add installation instructions to help text","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:11:22.364835803Z","created_by":"ubuntu","updated_at":"2026-01-21T11:00:03.411583636Z","closed_at":"2026-01-21T11:00:03.411533432Z","close_reason":"Shell completions fully implemented - fixed -f flag conflict, bash/zsh/fish/powershell all work","compaction_level":0,"original_size":0,"labels":["cli","developer-experience","polish","priority-5"]}
{"id":"bd-3q3","title":"Implement image caching for snapshots","description":"When saving snapshots:\n1. Read and resize source images\n2. Store processed images in snapshot directory\n3. Use content-addressable naming (SHA256)\n4. On restore, use cached images if source missing\n\nThis provides resilience when source images are moved/deleted.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.703366526Z","created_by":"ubuntu","updated_at":"2026-01-21T11:24:33.291330580Z","closed_at":"2026-01-21T11:24:33.291254437Z","close_reason":"Implemented in cache_image function. Save command hashes images with SHA256 and stores them in content-addressable cache at ~/.local/share/sd/snapshots/images/{prefix}/{hash}.webp. Restore uses cached images when available.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3q3","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.712985466Z","created_by":"ubuntu"}]}
{"id":"bd-3qj","title":"Implement pattern expansion","description":"## Purpose\nImplement {index} placeholder expansion for batch key assignments in patterns.\n\n## Implementation\n\n```rust\n// src/config/pattern.rs\nuse std::path::{Path, PathBuf};\nuse crate::error::{Result, SdError};\nuse tracing::{debug, trace};\n\n/// Pattern expansion configuration\n#[derive(Debug, Clone)]\npub struct PatternExpander {\n    /// Zero-pad width for index (default: 2)\n    pub pad_width: usize,\n    /// Placeholder string (default: \"{index}\")\n    pub placeholder: String,\n}\n\nimpl Default for PatternExpander {\n    fn default() -> Self {\n        Self {\n            pad_width: 2,\n            placeholder: \"{index}\".to_string(),\n        }\n    }\n}\n\nimpl PatternExpander {\n    /// Create with custom padding width\n    pub fn with_pad_width(pad_width: usize) -> Self {\n        Self {\n            pad_width,\n            ..Default::default()\n        }\n    }\n    \n    /// Expand pattern for a specific key index\n    /// \n    /// Example: \"~/icons/{index}.png\" with index 8 → \"~/icons/08.png\"\n    pub fn expand(&self, pattern: &str, index: u8) -> String {\n        trace!(pattern, index, \"Expanding pattern\");\n        \n        let replacement = format!(\"{:0>width$}\", index, width = self.pad_width);\n        let expanded = pattern.replace(&self.placeholder, &replacement);\n        \n        debug!(pattern, index, expanded = %expanded, \"Pattern expanded\");\n        expanded\n    }\n    \n    /// Expand pattern to PathBuf\n    pub fn expand_path(&self, pattern: &str, index: u8) -> PathBuf {\n        PathBuf::from(self.expand(pattern, index))\n    }\n    \n    /// Check if string contains the placeholder\n    pub fn has_placeholder(&self, s: &str) -> bool {\n        s.contains(&self.placeholder)\n    }\n    \n    /// Validate pattern syntax\n    pub fn validate_pattern(&self, pattern: &str) -> Result<()> {\n        if !self.has_placeholder(pattern) {\n            return Err(SdError::ConfigInvalid(format!(\n                \"Pattern '{}' must contain {} placeholder\",\n                pattern, self.placeholder\n            )));\n        }\n        \n        // Check for multiple placeholders (could be valid, but warn)\n        let count = pattern.matches(&self.placeholder).count();\n        if count > 1 {\n            debug!(pattern, count, \"Pattern contains multiple placeholders\");\n        }\n        \n        Ok(())\n    }\n}\n\n/// Expand all keys in a range using a pattern\npub fn expand_range_pattern(\n    pattern: &str,\n    start: u8,\n    end: u8,\n) -> Result<Vec<(u8, PathBuf)>> {\n    let expander = PatternExpander::default();\n    expander.validate_pattern(pattern)?;\n    \n    let mut result = Vec::new();\n    for index in start..=end {\n        let path = expander.expand_path(pattern, index);\n        result.push((index, path));\n    }\n    \n    Ok(result)\n}\n\n/// Batch expand result with validation status\n#[derive(Debug)]\npub struct ExpandedPattern {\n    pub index: u8,\n    pub path: PathBuf,\n    pub exists: bool,\n}\n\n/// Expand and validate all paths in a range\npub fn expand_and_validate(\n    pattern: &str,\n    start: u8,\n    end: u8,\n    base_dir: &Path,\n) -> Result<Vec<ExpandedPattern>> {\n    use crate::config::path::resolve_path;\n    \n    let expander = PatternExpander::default();\n    expander.validate_pattern(pattern)?;\n    \n    let mut results = Vec::new();\n    for index in start..=end {\n        let raw_path = expander.expand_path(pattern, index);\n        let resolved = resolve_path(&raw_path, base_dir)?;\n        let exists = resolved.exists();\n        \n        results.push(ExpandedPattern {\n            index,\n            path: resolved,\n            exists,\n        });\n    }\n    \n    Ok(results)\n}\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_expand_single_digit() {\n        let expander = PatternExpander::default();\n        \n        assert_eq!(expander.expand(\"icons/{index}.png\", 0), \"icons/00.png\");\n        assert_eq!(expander.expand(\"icons/{index}.png\", 5), \"icons/05.png\");\n        assert_eq!(expander.expand(\"icons/{index}.png\", 9), \"icons/09.png\");\n    }\n    \n    #[test]\n    fn test_expand_double_digit() {\n        let expander = PatternExpander::default();\n        \n        assert_eq!(expander.expand(\"icons/{index}.png\", 10), \"icons/10.png\");\n        assert_eq!(expander.expand(\"icons/{index}.png\", 31), \"icons/31.png\");\n        assert_eq!(expander.expand(\"icons/{index}.png\", 99), \"icons/99.png\");\n    }\n    \n    #[test]\n    fn test_expand_with_path() {\n        let expander = PatternExpander::default();\n        \n        assert_eq!(\n            expander.expand(\"~/stream-deck/row{index}/icon.png\", 2),\n            \"~/stream-deck/row02/icon.png\"\n        );\n    }\n    \n    #[test]\n    fn test_expand_multiple_placeholders() {\n        let expander = PatternExpander::default();\n        \n        // Multiple placeholders all get expanded\n        assert_eq!(\n            expander.expand(\"{index}/{index}.png\", 5),\n            \"05/05.png\"\n        );\n    }\n    \n    #[test]\n    fn test_custom_pad_width() {\n        let expander = PatternExpander::with_pad_width(3);\n        \n        assert_eq!(expander.expand(\"key_{index}.png\", 5), \"key_005.png\");\n        assert_eq!(expander.expand(\"key_{index}.png\", 42), \"key_042.png\");\n    }\n    \n    #[test]\n    fn test_no_pad_width() {\n        let expander = PatternExpander::with_pad_width(0);\n        \n        assert_eq!(expander.expand(\"key_{index}.png\", 5), \"key_5.png\");\n        assert_eq!(expander.expand(\"key_{index}.png\", 42), \"key_42.png\");\n    }\n    \n    #[test]\n    fn test_has_placeholder() {\n        let expander = PatternExpander::default();\n        \n        assert!(expander.has_placeholder(\"icons/{index}.png\"));\n        assert!(!expander.has_placeholder(\"icons/static.png\"));\n    }\n    \n    #[test]\n    fn test_validate_pattern_valid() {\n        let expander = PatternExpander::default();\n        assert!(expander.validate_pattern(\"icons/{index}.png\").is_ok());\n    }\n    \n    #[test]\n    fn test_validate_pattern_missing_placeholder() {\n        let expander = PatternExpander::default();\n        let result = expander.validate_pattern(\"icons/static.png\");\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_expand_range() {\n        let result = expand_range_pattern(\"key_{index}.png\", 8, 10).unwrap();\n        \n        assert_eq!(result.len(), 3);\n        assert_eq!(result[0], (8, PathBuf::from(\"key_08.png\")));\n        assert_eq!(result[1], (9, PathBuf::from(\"key_09.png\")));\n        assert_eq!(result[2], (10, PathBuf::from(\"key_10.png\")));\n    }\n    \n    #[test]\n    fn test_expand_and_validate() {\n        let temp = TempDir::new().unwrap();\n        \n        // Create some test files\n        File::create(temp.path().join(\"key_08.png\")).unwrap();\n        File::create(temp.path().join(\"key_09.png\")).unwrap();\n        // key_10.png intentionally missing\n        \n        let results = expand_and_validate(\n            \"key_{index}.png\",\n            8,\n            10,\n            temp.path(),\n        ).unwrap();\n        \n        assert_eq!(results.len(), 3);\n        assert!(results[0].exists);  // key_08.png exists\n        assert!(results[1].exists);  // key_09.png exists\n        assert!(!results[2].exists); // key_10.png missing\n    }\n    \n    #[test]\n    fn test_expand_path_type() {\n        let expander = PatternExpander::default();\n        let path = expander.expand_path(\"icons/{index}.png\", 5);\n        \n        assert_eq!(path, PathBuf::from(\"icons/05.png\"));\n    }\n    \n    #[test]\n    fn test_home_path_expansion() {\n        let expander = PatternExpander::default();\n        \n        // ~ should be preserved (resolved by PathResolver)\n        assert_eq!(\n            expander.expand(\"~/icons/{index}.png\", 5),\n            \"~/icons/05.png\"\n        );\n    }\n}\n```\n\n## Success Criteria\n- [ ] {index} expands to zero-padded number\n- [ ] Default padding is 2 digits (00-99)\n- [ ] Custom padding widths supported\n- [ ] Multiple placeholders all expand\n- [ ] Missing placeholder detected as error\n- [ ] Range expansion generates all paths\n- [ ] Validation checks file existence\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Pattern expansion attempts\n- DEBUG: Expanded paths, multiple placeholder warnings\n- INFO: (none)\n- WARN: Missing files in pattern ranges\n- ERROR: Invalid patterns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:57.088705856Z","created_by":"ubuntu","updated_at":"2026-01-19T21:42:39.113409908Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3qj","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:57.098753924Z","created_by":"ubuntu"}]}
{"id":"bd-3ro","title":"EPIC: Integrate rich_rust for Premium Terminal Output","description":"# EPIC: Integrate rich_rust for Premium Terminal Output\n\n## Executive Summary\n\nThis epic encompasses the complete integration of the rich_rust library into the Stream Deck CLI (sd) to provide beautiful, stylish terminal output for human observers while strictly preserving the clean JSON robot mode that AI coding agents depend on.\n\n## Background & Context\n\n### The Problem\nThe current Stream Deck CLI uses the `colored` crate for basic terminal coloring. While functional, this approach has limitations:\n1. Limited styling options (just colors, no tables, panels, progress bars)\n2. No automatic terminal capability detection\n3. No consistent visual identity across commands\n4. Output looks utilitarian rather than premium\n\n### The Solution\nrich_rust is a Rust port of Python's Rich library, providing:\n- Markup syntax: [bold red]text[/]\n- Tables with auto-sizing columns\n- Panels with box drawing characters\n- Progress bars and spinners\n- Automatic terminal capability detection (4-bit, 8-bit, 24-bit color)\n- NO_COLOR environment variable compliance\n- TTY vs pipe detection (auto-disables colors when piped)\n\n### Why This Matters\nThe Stream Deck CLI has two distinct user categories:\n1. AI Agents (Primary): Use --robot mode for pure JSON output. These users must NOT be affected.\n2. Human Observers: Watch agents work or use the CLI directly. These users deserve a premium visual experience.\n\nThis integration serves the overarching goal of making sd a best-in-class CLI that is both agent-friendly AND visually impressive for humans.\n\n## Architectural Approach\n\nOutput Mode Bifurcation:\n- Robot Mode: Pure JSON via serde, no ANSI codes, unchanged from current behavior\n- Human Mode: rich_rust Console with styled panels, tables, progress bars\n\nKey Design Decisions:\n1. Output Trait Abstraction: Commands call output.device_list(), output.error(), etc. without knowing the output mode\n2. Zero Agent Impact: Robot mode produces identical JSON to current behavior\n3. Automatic Detection: rich_rust handles NO_COLOR, TTY, color capabilities\n4. Cohesive Theme: Stream Deck blue (#0080FF) accent with consistent styling\n\n## Success Criteria\n- All commands produce beautiful styled output in human mode\n- Robot mode JSON output is byte-for-byte identical to current behavior\n- NO_COLOR environment variable disables all styling\n- Piped output (non-TTY) has no ANSI codes\n- All existing tests pass\n- New visual and regression tests added\n- colored crate removed from dependencies\n\n## Implementation Phases\n1. Foundation Infrastructure (output module, theme system)\n2. Command Implementations (device list, info, errors, etc.)\n3. Main.rs Integration (wire up new output system)\n4. Testing & Verification\n5. Polish & Documentation\n\n## Risk Considerations\n- Breaking agent workflows: Mitigated by extensive robot mode regression tests\n- Terminal compatibility: Mitigated by rich_rust auto-detection and safe_box fallback\n- Binary size increase: Acceptable tradeoff for functionality\n\n## References\n- rich_rust crate: /dp/rich_rust\n- Python Rich (inspiration): https://github.com/Textualize/rich\n- NO_COLOR standard: https://no-color.org/","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T21:01:56.022368636Z","created_by":"ubuntu","updated_at":"2026-01-19T21:01:56.061179540Z","compaction_level":0,"original_size":0,"labels":["infrastructure","rich-rust","ui"]}
{"id":"bd-3w1","title":"Write tests for dry-run behavior","description":"## Test Coverage for Dry-Run Mode\n\n### Unit Tests (require MockDevice - bd-180)\n\n1. **Flag Parsing Tests**\n   - Global `--dry-run` flag recognized\n   - Works with all mutating commands\n   - Combines with `--robot` flag correctly\n   - Short form `-n` if supported\n\n2. **Validation Without Execution Tests**\n   - Image path validated (exists, readable)\n   - Image format validated (PNG, JPG)\n   - Image dimensions extracted\n   - Color values validated (#RRGGBB format)\n   - Key indices validated against device model\n\n3. **Output Format Tests**\n   - Human output shows \"DRY RUN:\" prefix\n   - Human output describes intended action\n   - Robot output includes `\"dry_run\": true`\n   - Robot output includes all details that would be used\n\n### Integration Tests (require MockDevice)\n\n1. **Brightness Dry-Run**\n   - Shows target brightness level\n   - Shows current brightness (if readable)\n   - Device brightness NOT changed\n   - MockDevice confirms no set_brightness call\n\n2. **Set-Key Dry-Run**\n   - Shows source image path and dimensions\n   - Shows target key index\n   - Shows resize details (if needed)\n   - Device key NOT changed\n   - MockDevice confirms no set_key_image call\n\n3. **Fill-Key Dry-Run**\n   - Shows target key and color\n   - Color value parsed and displayed\n   - Device key NOT changed\n\n4. **Clear-Key Dry-Run**\n   - Shows key(s) that would be cleared\n   - Device key NOT changed\n\n5. **Set-Keys (Batch) Dry-Run**\n   - Shows full manifest of directory contents\n   - Each key shows: index, source, dimensions, resize needed\n   - Missing files noted\n   - Pattern matching explained\n   - NO device operations performed\n\n6. **Error Preview**\n   - Invalid image shows error that would occur\n   - Invalid key index shows error\n   - Missing file shows error\n   - All errors include suggestions\n\n### E2E Tests (require E2E harness - bd-1xy)\n\n1. **CLI Verification**\n   - `sd brightness 80 --dry-run` shows preview, exit 0\n   - `sd set-key 0 icon.png --dry-run` shows preview, exit 0\n   - `sd set-key 99 icon.png --dry-run` shows error, exit 1\n   - `sd set-keys ./dir/ --dry-run` shows full manifest\n\n2. **Robot Mode Integration**\n   - `sd brightness 80 --dry-run --robot` returns valid JSON\n   - JSON includes `dry_run`, `would_succeed`, `details`\n   - CI can validate operations without hardware\n\n3. **No Side Effects Verification**\n   - Run dry-run command\n   - Verify no state files created\n   - Verify no cache files created\n   - Verify no device communication attempted\n\n### Logging Requirements\n- DEBUG: Validation steps performed\n- INFO: Dry-run summary (what would happen)\n- WARN: Potential issues that would occur\n- ERROR: Validation failures\n\n### Test Assertions\n- MockDevice operation count == 0 after all dry-run tests\n- Exit code 0 for valid dry-run operations\n- Exit code non-zero for invalid operations (even in dry-run)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:24:45.129502306Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:39.133671236Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3w1","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:38:37.325986601Z","created_by":"ubuntu"},{"issue_id":"bd-3w1","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:02:39.133615090Z","created_by":"ubuntu"},{"issue_id":"bd-3w1","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:45.138653376Z","created_by":"ubuntu"}]}
{"id":"bd-4zd","title":"Implement key image upload endpoint","description":"POST /api/keys/:id with multipart form:\n- Accept image file upload\n- Process and resize\n- Apply to device\n- Return success/error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:44.553749212Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:44.570008184Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-4zd","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:44.569957699Z","created_by":"ubuntu"}]}
{"id":"bd-533","title":"Phase 2: Command Output Implementations","description":"# Phase 2: Command Output Implementations\n\n## Purpose\nImplement detailed, polished rich_rust formatting for each CLI command's human-mode output. This phase transforms the HumanOutput skeleton into production-quality visual output.\n\n## Background\nPhase 1 established the infrastructure (Output trait, RobotOutput, HumanOutput skeleton). Phase 2 fills in the skeleton with beautiful, information-rich formatting using rich_rust's full capabilities:\n- Tables for structured data (device info, key layouts)\n- Panels for grouped content (errors, version info)\n- Progress bars for numeric values (brightness)\n- Styled text for events (button presses)\n- Rules for visual separation\n\n## Deliverables\nEach command gets a dedicated task with specific visual design:\n1. Device list - Panel with device cards\n2. Device info - Table in panel with key layout grid\n3. Error output - Error panel with styled suggestion\n4. Brightness - Progress bar visualization\n5. Key operations - Checkmark confirmations\n6. Button events - Styled event stream with timestamps\n7. Version info - Styled info panel\n8. Watch header - Section divider with hint\n\n## Visual Design Guidelines\n\n### Consistency\n- All panels use rounded box style (╭─╮)\n- Accent color (#0080FF) for informational panels\n- Success color (#00D26A) for confirmations\n- Error color (#FF4757) for errors\n- Warning color (#FFA502) for key indices\n\n### Information Hierarchy\n1. Primary: Bold, accent colored (device names, section headers)\n2. Secondary: Regular weight, default color (values)\n3. Tertiary: Dim, muted color (labels, hints)\n\n### Spacing\n- Single blank line between major sections\n- Consistent padding inside panels (1 space)\n- Table cell padding for readability\n\n## Success Criteria\n- [ ] Each command produces visually appealing output\n- [ ] Consistent visual style across all commands\n- [ ] Information is easy to scan and understand\n- [ ] Output adapts to terminal width\n- [ ] ASCII fallback works when needed (safe_box mode)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-19T21:05:01.203352029Z","created_by":"ubuntu","updated_at":"2026-01-19T21:05:01.248739926Z","compaction_level":0,"original_size":0,"labels":["commands","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-533","depends_on_id":"bd-1vw","type":"blocks","created_at":"2026-01-19T21:05:01.248711212Z","created_by":"ubuntu"},{"issue_id":"bd-533","depends_on_id":"bd-3ro","type":"parent-child","created_at":"2026-01-19T21:05:01.244967924Z","created_by":"ubuntu"}]}
{"id":"bd-53g","title":"Add --embed-images with base64 encoding","description":"## Purpose\nGenerate self-contained shell scripts with embedded base64-encoded images that can run without external dependencies.\n\n## Implementation\n\\`\\`\\`rust\n// src/export/bash.rs (extend existing file)\nuse std::path::Path;\nuse base64::Engine;\nuse tracing::{debug, trace, info, warn, instrument};\n\n/// Options for embedded image export\npub struct EmbedOptions {\n    /// Use heredocs for cleaner output (bash 4+)\n    pub use_heredocs: bool,\n    /// Create temp directory for images\n    pub temp_dir: String,\n    /// Cleanup temp files after apply\n    pub cleanup: bool,\n}\n\nimpl Default for EmbedOptions {\n    fn default() -> Self {\n        Self {\n            use_heredocs: true,\n            temp_dir: \"${TMPDIR:-/tmp}/sd-export-$$\".to_string(),\n            cleanup: true,\n        }\n    }\n}\n\n/// Generate embedded image section\n#[instrument(skip(state))]\npub fn generate_embedded_images(\n    state: &SessionState,\n    opts: &EmbedOptions,\n) -> Result<String, ExportError> {\n    let mut lines = Vec::new();\n    \n    // Create temp directory\n    lines.push(format!(\"# Create temporary directory for images\"));\n    lines.push(format!(\"SD_TMPDIR=\\\"{}\\\"\", opts.temp_dir));\n    lines.push(\"mkdir -p \\\"$SD_TMPDIR\\\"\".to_string());\n    lines.push(\"\".to_string());\n    \n    // Track which images we've embedded (avoid duplicates)\n    let mut embedded: std::collections::HashSet<String> = std::collections::HashSet::new();\n    \n    // Collect images\n    lines.push(\"# Embedded images (base64-encoded)\".to_string());\n    \n    for (key, key_state) in &state.keys {\n        if let KeyState::Image(path) = key_state {\n            let path_str = path.display().to_string();\n            if embedded.contains(&path_str) {\n                continue;\n            }\n            embedded.insert(path_str.clone());\n            \n            // Read and encode image\n            let data = match std::fs::read(path) {\n                Ok(d) => d,\n                Err(e) => {\n                    warn!(path = %path.display(), error = %e, \"Failed to read image\");\n                    return Err(ExportError::ImageReadFailed {\n                        path: path.clone(),\n                        source: e,\n                    });\n                }\n            };\n            \n            let base64_data = base64::engine::general_purpose::STANDARD.encode(&data);\n            let filename = path.file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"image.png\");\n            let safe_name = sanitize_filename(filename);\n            \n            trace!(key = %key, size = %data.len(), \"Embedding image\");\n            \n            if opts.use_heredocs {\n                // Use heredoc for cleaner output\n                lines.push(format!(\"base64 -d > \\\"$SD_TMPDIR/{safe_name}\\\" << 'EOF'\"));\n                \n                // Split base64 into 76-char lines for readability\n                for chunk in base64_data.as_bytes().chunks(76) {\n                    lines.push(String::from_utf8_lossy(chunk).to_string());\n                }\n                lines.push(\"EOF\".to_string());\n            } else {\n                // Echo approach (more portable but messier)\n                lines.push(format!(\n                    \"echo '{}' | base64 -d > \\\"$SD_TMPDIR/{safe_name}\\\"\",\n                    base64_data\n                ));\n            }\n            lines.push(\"\".to_string());\n        }\n    }\n    \n    info!(count = %embedded.len(), \"Embedded images\");\n    Ok(lines.join(\"\\n\"))\n}\n\n/// Generate commands using embedded images\npub fn generate_embedded_commands(\n    state: &SessionState,\n    opts: &BashExportOptions,\n) -> String {\n    let mut lines = Vec::new();\n    let device_flag = opts.device_serial.as_ref()\n        .map(|s| format!(\" --serial \\\"{}\\\"\", s))\n        .unwrap_or_default();\n    \n    lines.push(\"# Apply configuration using embedded images\".to_string());\n    \n    for (key, key_state) in &state.keys {\n        match key_state {\n            KeyState::Image(path) => {\n                let filename = path.file_name()\n                    .and_then(|n| n.to_str())\n                    .unwrap_or(\"image.png\");\n                let safe_name = sanitize_filename(filename);\n                lines.push(format!(\n                    \"sd{} set-key {} \\\"$SD_TMPDIR/{safe_name}\\\"\",\n                    device_flag, key\n                ));\n            }\n            KeyState::Color(color) => {\n                lines.push(format!(\n                    \"sd{} fill-key {} \\\"{}\\\"\",\n                    device_flag, key, color\n                ));\n            }\n            KeyState::Cleared => {\n                lines.push(format!(\"sd{} clear-key {}\", device_flag, key));\n            }\n        }\n    }\n    \n    lines.join(\"\\n\")\n}\n\n/// Generate cleanup section\npub fn generate_cleanup(opts: &EmbedOptions) -> String {\n    if opts.cleanup {\n        format!(\n            r#\"\n# Cleanup temporary files\nrm -rf \"$SD_TMPDIR\"\necho \"Cleaned up temporary files\"\n\"#\n        )\n    } else {\n        format!(\n            r#\"\n# Temporary files preserved in: $SD_TMPDIR\necho \"Images saved to: $SD_TMPDIR\"\n\"#\n        )\n    }\n}\n\n/// Sanitize filename for safe shell usage\nfn sanitize_filename(name: &str) -> String {\n    name.chars()\n        .map(|c| if c.is_alphanumeric() || c == '.' || c == '-' || c == '_' {\n            c\n        } else {\n            '_'\n        })\n        .collect()\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ExportError {\n    #[error(\"Failed to read image {path}: {source}\")]\n    ImageReadFailed {\n        path: std::path::PathBuf,\n        source: std::io::Error,\n    },\n}\n\n/// Complete embedded export function\n#[instrument(skip(state))]\npub fn generate_embedded_script(\n    state: &SessionState,\n    opts: &BashExportOptions,\n    embed_opts: &EmbedOptions,\n) -> Result<String, ExportError> {\n    let mut sections = Vec::new();\n    \n    // Header\n    sections.push(\"#!/bin/bash\".to_string());\n    sections.push(\"# Stream Deck configuration (self-contained with embedded images)\".to_string());\n    sections.push(format!(\"# Exported: {}\", chrono::Utc::now().to_rfc3339()));\n    sections.push(\"\".to_string());\n    sections.push(\"set -e\".to_string());\n    sections.push(\"\".to_string());\n    \n    // Embedded images\n    sections.push(generate_embedded_images(state, embed_opts)?);\n    \n    // Brightness (if set)\n    if let Some(brightness) = state.brightness {\n        let device_flag = opts.device_serial.as_ref()\n            .map(|s| format!(\" --serial \\\"{}\\\"\", s))\n            .unwrap_or_default();\n        sections.push(format!(\"# Set brightness\"));\n        sections.push(format!(\"sd{} brightness {}\", device_flag, brightness));\n        sections.push(\"\".to_string());\n    }\n    \n    // Key commands\n    sections.push(generate_embedded_commands(state, opts));\n    sections.push(\"\".to_string());\n    \n    // Cleanup\n    sections.push(generate_cleanup(embed_opts));\n    \n    // Success message\n    sections.push(\"echo \\\"Configuration applied successfully\\\"\".to_string());\n    \n    info!(\n        images = %state.keys.values().filter(|k| matches!(k, KeyState::Image(_))).count(),\n        \"Generated embedded script\"\n    );\n    \n    Ok(sections.join(\"\\n\"))\n}\n\\`\\`\\`\n\n## Unit Tests\n\\`\\`\\`rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n    \n    fn sample_state_with_images() -> (SessionState, NamedTempFile) {\n        // Create a temp image file\n        let mut temp = NamedTempFile::new().unwrap();\n        temp.write_all(&[0x89, 0x50, 0x4E, 0x47]).unwrap(); // PNG magic\n        \n        let mut keys = HashMap::new();\n        keys.insert(0, KeyState::Image(temp.path().to_path_buf()));\n        keys.insert(1, KeyState::Color(\"#FF5500\".to_string()));\n        \n        (SessionState { brightness: Some(80), keys }, temp)\n    }\n    \n    #[test]\n    fn test_embedded_export() {\n        let (state, _temp) = sample_state_with_images();\n        let opts = BashExportOptions::default();\n        let embed_opts = EmbedOptions::default();\n        \n        let script = generate_embedded_script(&state, &opts, &embed_opts).unwrap();\n        \n        assert!(script.contains(\"#!/bin/bash\"));\n        assert!(script.contains(\"mkdir -p \\\"$SD_TMPDIR\\\"\"));\n        assert!(script.contains(\"base64 -d\"));\n        assert!(script.contains(\"sd brightness 80\"));\n        assert!(script.contains(\"rm -rf \\\"$SD_TMPDIR\\\"\"));\n    }\n    \n    #[test]\n    fn test_sanitize_filename() {\n        assert_eq!(sanitize_filename(\"simple.png\"), \"simple.png\");\n        assert_eq!(sanitize_filename(\"with spaces.png\"), \"with_spaces.png\");\n        assert_eq!(sanitize_filename(\"special!@#chars.png\"), \"special___chars.png\");\n    }\n    \n    #[test]\n    fn test_heredoc_format() {\n        let (state, _temp) = sample_state_with_images();\n        let embed_opts = EmbedOptions {\n            use_heredocs: true,\n            ..Default::default()\n        };\n        \n        let images = generate_embedded_images(&state, &embed_opts).unwrap();\n        assert!(images.contains(\"<< 'EOF'\"));\n        assert!(images.contains(\"EOF\"));\n    }\n    \n    #[test]\n    fn test_no_cleanup() {\n        let embed_opts = EmbedOptions {\n            cleanup: false,\n            ..Default::default()\n        };\n        \n        let cleanup = generate_cleanup(&embed_opts);\n        assert!(!cleanup.contains(\"rm -rf\"));\n        assert!(cleanup.contains(\"Images saved to\"));\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Images embedded as base64 in script\n- [ ] Temp directory created for extracted images\n- [ ] Duplicate images handled (embed once)\n- [ ] Cleanup removes temp files by default\n- [ ] --no-cleanup option preserves temp files\n- [ ] Cross-platform base64 decoding works\n\n## Logging Requirements\n- TRACE: Individual image embedding details\n- DEBUG: (none)\n- INFO: Image count embedded, script generated\n- WARN: Failed to read image file\n- ERROR: (none - bubbles up as Result)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:02.311118252Z","created_by":"ubuntu","updated_at":"2026-01-19T21:27:15.006841730Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-53g","depends_on_id":"bd-1q4","type":"parent-child","created_at":"2026-01-19T18:27:02.327718307Z","created_by":"ubuntu"}]}
{"id":"bd-5v0","title":"Implement dry-run for fill-key command","description":"## Purpose\nImplement dry-run mode for all fill operations (fill-key, fill-keys).\n\n## Implementation\n\n### fill-key (single)\n```rust\nif dry_run {\n    let parsed_color = parse_color(&opts.color)?;\n    output.dry_run_preview(DryRunAction::FillKey {\n        key: opts.key,\n        color_input: opts.color.clone(),\n        color_hex: parsed_color.to_hex(),\n        color_rgb: parsed_color.to_rgb_tuple(),\n    });\n    return Ok(());\n}\n```\n\n### fill-keys (batch)\n```rust\nif dry_run {\n    let parsed_color = parse_color(&opts.color)?;\n    let keys = resolve_key_selection(&opts)?;\n    output.dry_run_preview(DryRunAction::FillKeys {\n        keys: keys.clone(),\n        total_count: keys.len(),\n        color_input: opts.color.clone(),\n        color_hex: parsed_color.to_hex(),\n        color_rgb: parsed_color.to_rgb_tuple(),\n        device_model: device.info().model.clone(),\n    });\n    return Ok(());\n}\n```\n\n## Robot Mode Output\n```json\n{\n  \"dry_run\": true,\n  \"command\": \"fill-keys\",\n  \"color\": {\n    \"input\": \"red\",\n    \"hex\": \"#FF0000\",\n    \"rgb\": [255, 0, 0]\n  },\n  \"would_fill\": [0, 1, 2, 3, 4, 5, 6, 7],\n  \"total_keys\": 8,\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"total_keys\": 32\n  }\n}\n```\n\n## Human Mode Output\n```\nDRY RUN: Would fill 8 keys with color\n  Keys: 0-7\n  Color: red → #FF0000 (RGB: 255, 0, 0)\n  No changes will be made.\n```\n\n## Color Validation\n- Validate color format before preview\n- Show both input and normalized forms\n- Return error if color invalid (even in dry-run)\n\n## Logging Requirements\n- TRACE: Color parsing steps\n- DEBUG: Key selection, color normalization\n- INFO: Dry-run summary\n- WARN: (none)\n- ERROR: Invalid color format\n\n## Success Criteria\n- [ ] fill-key shows single key preview with color info\n- [ ] fill-keys shows batch preview with color info\n- [ ] Color normalized to hex for preview\n- [ ] Invalid colors caught during dry-run\n- [ ] Robot mode returns structured preview","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.368495216Z","created_by":"ubuntu","updated_at":"2026-01-19T21:46:07.418534180Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-5v0","depends_on_id":"bd-1uz","type":"blocks","created_at":"2026-01-19T21:46:06.717234143Z","created_by":"ubuntu"},{"issue_id":"bd-5v0","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.379338892Z","created_by":"ubuntu"},{"issue_id":"bd-5v0","depends_on_id":"bd-3lf","type":"blocks","created_at":"2026-01-19T21:46:07.418483605Z","created_by":"ubuntu"}]}
{"id":"bd-8r8","title":"Implement apply command","description":"Implement sd apply <name>:\n1. Load profile from database\n2. Verify device compatibility\n3. Set brightness if stored\n4. Apply each key (image, color, or clear)\n5. Report results\n\nConsider: partial application, error handling.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:31.101462966Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:31.110721928Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-8r8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:31.110682404Z","created_by":"ubuntu"}]}
{"id":"bd-9c7","title":"Implement dry-run for set-key command","description":"## Purpose\nImplement dry-run mode for set-key command that validates and previews image operations without applying to device.\n\n## Implementation\n\n```rust\n// src/commands/set_key.rs\nuse std::path::Path;\nuse crate::device::{DeviceOperations, DeviceInfo};\nuse crate::error::{Result, SdError};\nuse crate::output::{Output, DryRunResponse, SetKeyDetails, ImageSource};\nuse tracing::{debug, info, instrument};\n\n#[derive(Debug)]\npub struct SetKeyOptions {\n    pub key: u8,\n    pub image_path: PathBuf,\n    pub dry_run: bool,\n}\n\n#[instrument(skip(device, output))]\npub async fn cmd_set_key(\n    device: &mut dyn DeviceOperations,\n    options: SetKeyOptions,\n    output: &dyn Output,\n) -> Result<()> {\n    let device_info = device.info();\n    \n    // Validate key index\n    if options.key >= device_info.key_count {\n        return Err(SdError::InvalidKey(options.key, device_info.key_count));\n    }\n    \n    // Analyze the source image\n    let source_info = analyze_image(&options.image_path)?;\n    \n    // Calculate processing requirements\n    let target_dims = device_info.key_dimensions();\n    let resize_needed = source_info.width != target_dims.0 || \n                        source_info.height != target_dims.1;\n    \n    if options.dry_run {\n        let details = SetKeyDetails {\n            key: options.key,\n            source: source_info,\n            processing: ProcessingInfo {\n                resize_needed,\n                target_dimensions: target_dims,\n                estimated_time_ms: estimate_processing_time(&source_info, resize_needed),\n            },\n        };\n        \n        let response = DryRunResponse::success(\n            \"set_key_image\",\n            details,\n            device_context(device_info),\n        );\n        \n        // Add warning if resize needed\n        let response = if resize_needed {\n            response.with_warnings(vec![\n                format!(\n                    \"Image dimensions ({}x{}) will be resized to {}x{}\",\n                    source_info.width, source_info.height,\n                    target_dims.0, target_dims.1\n                )\n            ])\n        } else {\n            response\n        };\n        \n        return output.dry_run(&response);\n    }\n    \n    // Actually apply the image\n    info!(key = options.key, path = %options.image_path.display(), \"Setting key image\");\n    device.set_key_image(options.key, &options.image_path).await?;\n    \n    output.set_key_success(options.key, &options.image_path)\n}\n\n/// Analyze an image file without loading full pixel data\nfn analyze_image(path: &Path) -> Result<ImageSource> {\n    use image::io::Reader as ImageReader;\n    \n    // Check file exists\n    if !path.exists() {\n        return Err(SdError::ImageNotFound(path.display().to_string()));\n    }\n    \n    // Check file is readable\n    let metadata = std::fs::metadata(path)\n        .map_err(|e| SdError::IoError(e))?;\n    \n    if !metadata.is_file() {\n        return Err(SdError::ImageNotFound(format!(\n            \"{} is not a file\", path.display()\n        )));\n    }\n    \n    // Get format from extension\n    let format = path.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| e.to_lowercase())\n        .unwrap_or_default();\n    \n    // Read image dimensions without decoding full image\n    let reader = ImageReader::open(path)\n        .map_err(|e| SdError::ImageFormat(format!(\"Cannot open: {}\", e)))?\n        .with_guessed_format()\n        .map_err(|e| SdError::ImageFormat(format!(\"Unknown format: {}\", e)))?;\n    \n    let dimensions = reader.into_dimensions()\n        .map_err(|e| SdError::ImageFormat(format!(\"Cannot read dimensions: {}\", e)))?;\n    \n    Ok(ImageSource {\n        path: path.to_path_buf(),\n        exists: true,\n        readable: true,\n        format: Some(format),\n        dimensions: Some((dimensions.0, dimensions.1)),\n        size_bytes: Some(metadata.len()),\n    })\n}\n\nfn estimate_processing_time(source: &ImageSource, resize_needed: bool) -> Option<u32> {\n    if !resize_needed {\n        return Some(5); // Just format conversion\n    }\n    \n    // Rough estimate based on pixel count\n    if let Some((w, h)) = source.dimensions {\n        let pixels = w * h;\n        // Assume ~1ms per 10,000 pixels for resize\n        Some(((pixels as f64 / 10000.0) + 10.0) as u32)\n    } else {\n        None\n    }\n}\n\nfn device_context(info: &DeviceInfo) -> DeviceContext {\n    DeviceContext {\n        model: format!(\"{:?}\", info.model),\n        serial: Some(info.serial.clone()),\n        connected: true,\n        key_count: info.key_count,\n        key_dimensions: info.key_dimensions(),\n    }\n}\n```\n\n## Output Structures\n\n```rust\n// src/output/dry_run.rs\n#[derive(Debug, Serialize)]\npub struct SetKeyDetails {\n    pub key: u8,\n    pub source: ImageSource,\n    pub processing: ProcessingInfo,\n}\n\n#[derive(Debug, Serialize)]\npub struct ImageSource {\n    pub path: PathBuf,\n    pub exists: bool,\n    pub readable: bool,\n    pub format: Option<String>,\n    pub dimensions: Option<(u32, u32)>,\n    pub size_bytes: Option<u64>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ProcessingInfo {\n    pub resize_needed: bool,\n    pub target_dimensions: (u32, u32),\n    pub estimated_time_ms: Option<u32>,\n}\n```\n\n## Robot Mode JSON Output\n\n### Success (Image Found)\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key_image\",\n  \"would_succeed\": true,\n  \"failure_reason\": null,\n  \"validation\": {\n    \"inputs_valid\": true,\n    \"errors\": [],\n    \"warnings\": [\"Image dimensions (256x256) will be resized to 96x96\"]\n  },\n  \"details\": {\n    \"key\": 5,\n    \"source\": {\n      \"path\": \"/home/user/icons/chrome.png\",\n      \"exists\": true,\n      \"readable\": true,\n      \"format\": \"png\",\n      \"dimensions\": [256, 256],\n      \"size_bytes\": 24576\n    },\n    \"processing\": {\n      \"resize_needed\": true,\n      \"target_dimensions\": [96, 96],\n      \"estimated_time_ms\": 45\n    }\n  },\n  \"device\": {\n    \"model\": \"StreamDeckXL\",\n    \"serial\": \"ABC123\",\n    \"connected\": true,\n    \"key_count\": 32,\n    \"key_dimensions\": [96, 96]\n  }\n}\n```\n\n### Failure (Image Missing)\n```json\n{\n  \"dry_run\": true,\n  \"action\": \"set_key_image\",\n  \"would_succeed\": false,\n  \"failure_reason\": \"Image file not found\",\n  \"validation\": {\n    \"inputs_valid\": false,\n    \"errors\": [\n      {\n        \"field\": \"image_path\",\n        \"error\": \"File not found: /home/user/missing.png\",\n        \"suggestion\": \"Check the file path. Use absolute paths or paths relative to current directory.\"\n      }\n    ],\n    \"warnings\": []\n  },\n  \"details\": {\n    \"key\": 5,\n    \"source\": {\n      \"path\": \"/home/user/missing.png\",\n      \"exists\": false,\n      \"readable\": false,\n      \"format\": null,\n      \"dimensions\": null,\n      \"size_bytes\": null\n    },\n    \"processing\": null\n  },\n  \"device\": {...}\n}\n```\n\n## Human Mode Output\n\n```\nDRY RUN: Would set key 5\n\nSource: /home/user/icons/chrome.png\n  Format: PNG\n  Size: 24.0 KB\n  Dimensions: 256x256\n\nProcessing:\n  ⚠ Resize needed: 256x256 → 96x96\n  Estimated time: ~45ms\n\nTarget: Stream Deck XL (serial: ABC123), key 5\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::device::MockDevice;\n    use crate::output::TestOutput;\n    use tempfile::TempDir;\n    use std::fs;\n    \n    #[tokio::test]\n    async fn test_set_key_dry_run_valid_image() {\n        let temp = TempDir::new().unwrap();\n        \n        // Create a valid PNG (minimal valid file)\n        let img_path = temp.path().join(\"test.png\");\n        create_test_png(&img_path, 256, 256);\n        \n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        cmd_set_key(\n            &mut device,\n            SetKeyOptions {\n                key: 5,\n                image_path: img_path.clone(),\n                dry_run: true,\n            },\n            &output,\n        ).await.unwrap();\n        \n        // Key should NOT be set in dry-run mode\n        assert!(!device.key_has_image(5));\n        \n        // Output should contain dry-run info\n        let out = output.last_output();\n        assert!(out.contains(\"dry_run\") || out.contains(\"DRY RUN\"));\n    }\n    \n    #[tokio::test]\n    async fn test_set_key_dry_run_missing_image() {\n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        let result = cmd_set_key(\n            &mut device,\n            SetKeyOptions {\n                key: 5,\n                image_path: PathBuf::from(\"/nonexistent/image.png\"),\n                dry_run: true,\n            },\n            &output,\n        ).await;\n        \n        // Should return error even in dry-run mode\n        assert!(result.is_err());\n    }\n    \n    #[tokio::test]\n    async fn test_set_key_dry_run_invalid_key() {\n        let temp = TempDir::new().unwrap();\n        let img_path = temp.path().join(\"test.png\");\n        create_test_png(&img_path, 72, 72);\n        \n        let mut device = MockDevice::new_xl(); // 32 keys: 0-31\n        let output = TestOutput::new();\n        \n        let result = cmd_set_key(\n            &mut device,\n            SetKeyOptions {\n                key: 50, // Invalid for XL\n                image_path: img_path,\n                dry_run: true,\n            },\n            &output,\n        ).await;\n        \n        assert!(matches!(result, Err(SdError::InvalidKey(50, 32))));\n    }\n    \n    #[tokio::test]\n    async fn test_set_key_no_resize_needed() {\n        let temp = TempDir::new().unwrap();\n        \n        // Create image with exact device dimensions\n        let img_path = temp.path().join(\"test.png\");\n        create_test_png(&img_path, 96, 96); // XL key size\n        \n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        cmd_set_key(\n            &mut device,\n            SetKeyOptions {\n                key: 5,\n                image_path: img_path,\n                dry_run: true,\n            },\n            &output,\n        ).await.unwrap();\n        \n        // Should not have resize warning\n        let out = output.last_output();\n        assert!(!out.contains(\"resize\") || out.contains(\"resize_needed\\\":false\"));\n    }\n    \n    #[tokio::test]\n    async fn test_set_key_actual_apply() {\n        let temp = TempDir::new().unwrap();\n        let img_path = temp.path().join(\"test.png\");\n        create_test_png(&img_path, 96, 96);\n        \n        let mut device = MockDevice::new_xl();\n        let output = TestOutput::new();\n        \n        cmd_set_key(\n            &mut device,\n            SetKeyOptions {\n                key: 5,\n                image_path: img_path.clone(),\n                dry_run: false, // Actually apply\n            },\n            &output,\n        ).await.unwrap();\n        \n        // Key SHOULD be set\n        device.assert_key_has_image(5);\n    }\n    \n    #[test]\n    fn test_analyze_image_png() {\n        let temp = TempDir::new().unwrap();\n        let img_path = temp.path().join(\"test.png\");\n        create_test_png(&img_path, 128, 64);\n        \n        let info = analyze_image(&img_path).unwrap();\n        \n        assert!(info.exists);\n        assert!(info.readable);\n        assert_eq!(info.format, Some(\"png\".to_string()));\n        assert_eq!(info.dimensions, Some((128, 64)));\n        assert!(info.size_bytes.is_some());\n    }\n    \n    #[test]\n    fn test_analyze_image_missing() {\n        let result = analyze_image(Path::new(\"/nonexistent/image.png\"));\n        assert!(matches!(result, Err(SdError::ImageNotFound(_))));\n    }\n    \n    fn create_test_png(path: &Path, width: u32, height: u32) {\n        use image::{RgbaImage, Rgba};\n        let img = RgbaImage::from_pixel(width, height, Rgba([255, 0, 0, 255]));\n        img.save(path).unwrap();\n    }\n}\n```\n\n## Success Criteria\n- [ ] Image existence validated\n- [ ] Image dimensions read without full decode\n- [ ] Resize requirement correctly detected\n- [ ] Key index validated against device\n- [ ] Robot mode JSON output complete\n- [ ] Human mode output clear and helpful\n- [ ] No device operations in dry-run mode\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Image analysis steps\n- DEBUG: Image dimensions, resize calculations\n- INFO: Dry-run preview summary\n- WARN: Image requires resizing\n- ERROR: Missing/invalid image files","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.180066411Z","created_by":"ubuntu","updated_at":"2026-01-19T21:46:04.662169598Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9c7","depends_on_id":"bd-1uz","type":"blocks","created_at":"2026-01-19T21:46:03.929208454Z","created_by":"ubuntu"},{"issue_id":"bd-9c7","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.190801533Z","created_by":"ubuntu"},{"issue_id":"bd-9c7","depends_on_id":"bd-3lf","type":"blocks","created_at":"2026-01-19T21:46:04.662125265Z","created_by":"ubuntu"}]}
{"id":"bd-9gy","title":"Test generated completions for bash","description":"Manual testing:\n1. Generate: sd completions bash > /tmp/sd.bash\n2. Source: source /tmp/sd.bash\n3. Test: sd <TAB> shows commands\n4. Test: sd --<TAB> shows flags\n5. Verify no syntax errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.664311526Z","created_by":"ubuntu","updated_at":"2026-01-19T21:03:11.702369434Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-9gy","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:11.702321995Z","created_by":"ubuntu"},{"issue_id":"bd-9gy","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.674414859Z","created_by":"ubuntu"}]}
{"id":"bd-a1n","title":"Implement KeySelector parsing and resolution","description":"## Purpose\nImplement KeySelector enum with parsing from config map keys and resolution to concrete key indices.\n\n## Implementation\n\n```rust\n// src/config/selector.rs\nuse std::str::FromStr;\nuse crate::error::{Result, SdError};\nuse crate::device::DeviceInfo;\n\n/// Selector for targeting one or more keys in configuration\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum KeySelector {\n    /// Single key by index: \"0\", \"15\"\n    Single(u8),\n    \n    /// Inclusive range: \"8-15\"\n    Range { start: u8, end: u8 },\n    \n    /// All keys in a row: \"row-0\", \"row-3\"\n    Row(u8),\n    \n    /// All keys in a column: \"col-0\", \"col-4\"\n    Column(u8),\n    \n    /// All keys not matched by other selectors\n    Default,\n}\n\nimpl KeySelector {\n    /// Parse selector from string\n    pub fn parse(s: &str) -> Result<Self> {\n        let s = s.trim();\n        \n        if s == \"default\" {\n            return Ok(KeySelector::Default);\n        }\n        \n        if let Some(row) = s.strip_prefix(\"row-\") {\n            let row_num = row.parse::<u8>()\n                .map_err(|_| SdError::ConfigParse(format!(\"Invalid row number: {}\", row)))?;\n            return Ok(KeySelector::Row(row_num));\n        }\n        \n        if let Some(col) = s.strip_prefix(\"col-\") {\n            let col_num = col.parse::<u8>()\n                .map_err(|_| SdError::ConfigParse(format!(\"Invalid column number: {}\", col)))?;\n            return Ok(KeySelector::Column(col_num));\n        }\n        \n        if let Some(dash_pos) = s.find('-') {\n            // Could be negative number or range\n            if dash_pos > 0 {\n                let start = s[..dash_pos].parse::<u8>()\n                    .map_err(|_| SdError::ConfigParse(format!(\"Invalid range start: {}\", &s[..dash_pos])))?;\n                let end = s[dash_pos + 1..].parse::<u8>()\n                    .map_err(|_| SdError::ConfigParse(format!(\"Invalid range end: {}\", &s[dash_pos + 1..])))?;\n                \n                if start > end {\n                    return Err(SdError::ConfigParse(\n                        format!(\"Range start ({}) must be <= end ({})\", start, end)\n                    ));\n                }\n                \n                return Ok(KeySelector::Range { start, end });\n            }\n        }\n        \n        // Try single key index\n        let index = s.parse::<u8>()\n            .map_err(|_| SdError::ConfigParse(format!(\"Invalid key selector: '{}'\", s)))?;\n        \n        Ok(KeySelector::Single(index))\n    }\n    \n    /// Resolve selector to concrete key indices for a device\n    pub fn resolve(&self, device: &DeviceInfo) -> Result<Vec<u8>> {\n        match self {\n            KeySelector::Single(idx) => {\n                if *idx >= device.key_count {\n                    return Err(SdError::InvalidKey(*idx, device.key_count));\n                }\n                Ok(vec![*idx])\n            }\n            \n            KeySelector::Range { start, end } => {\n                if *end >= device.key_count {\n                    return Err(SdError::InvalidKey(*end, device.key_count));\n                }\n                Ok((*start..=*end).collect())\n            }\n            \n            KeySelector::Row(row) => {\n                if *row >= device.key_rows {\n                    return Err(SdError::ConfigInvalid(\n                        format!(\"Row {} out of range (device has {} rows)\", row, device.key_rows)\n                    ));\n                }\n                let start = *row * device.key_cols;\n                let end = start + device.key_cols;\n                Ok((start..end).collect())\n            }\n            \n            KeySelector::Column(col) => {\n                if *col >= device.key_cols {\n                    return Err(SdError::ConfigInvalid(\n                        format!(\"Column {} out of range (device has {} columns)\", col, device.key_cols)\n                    ));\n                }\n                let indices: Vec<u8> = (0..device.key_rows)\n                    .map(|row| row * device.key_cols + col)\n                    .collect();\n                Ok(indices)\n            }\n            \n            KeySelector::Default => {\n                // Return empty - handled specially during config resolution\n                Ok(vec![])\n            }\n        }\n    }\n    \n    /// Priority for resolution (lower = higher priority)\n    pub fn priority(&self) -> u8 {\n        match self {\n            KeySelector::Single(_) => 0,\n            KeySelector::Range { .. } => 1,\n            KeySelector::Row(_) | KeySelector::Column(_) => 2,\n            KeySelector::Default => 255,\n        }\n    }\n}\n\nimpl FromStr for KeySelector {\n    type Err = SdError;\n    \n    fn from_str(s: &str) -> Result<Self> {\n        Self::parse(s)\n    }\n}\n\n/// Custom deserializer for YAML map keys\nimpl<'de> serde::Deserialize<'de> for KeySelector {\n    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let s = String::deserialize(deserializer)?;\n        KeySelector::parse(&s).map_err(serde::de::Error::custom)\n    }\n}\n\nimpl serde::Serialize for KeySelector {\n    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let s = match self {\n            KeySelector::Single(idx) => idx.to_string(),\n            KeySelector::Range { start, end } => format!(\"{}-{}\", start, end),\n            KeySelector::Row(row) => format!(\"row-{}\", row),\n            KeySelector::Column(col) => format!(\"col-{}\", col),\n            KeySelector::Default => \"default\".to_string(),\n        };\n        serializer.serialize_str(&s)\n    }\n}\n```\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    fn xl_device() -> DeviceInfo {\n        DeviceInfo {\n            model: DeviceModel::XL,\n            serial: \"TEST\".to_string(),\n            firmware: \"1.0\".to_string(),\n            key_count: 32,\n            key_cols: 8,\n            key_rows: 4,\n            key_width: 96,\n            key_height: 96,\n        }\n    }\n    \n    fn mini_device() -> DeviceInfo {\n        DeviceInfo {\n            model: DeviceModel::Mini,\n            serial: \"TEST\".to_string(),\n            firmware: \"1.0\".to_string(),\n            key_count: 6,\n            key_cols: 3,\n            key_rows: 2,\n            key_width: 72,\n            key_height: 72,\n        }\n    }\n    \n    #[test]\n    fn test_parse_single() {\n        assert_eq!(KeySelector::parse(\"0\").unwrap(), KeySelector::Single(0));\n        assert_eq!(KeySelector::parse(\"15\").unwrap(), KeySelector::Single(15));\n        assert_eq!(KeySelector::parse(\" 5 \").unwrap(), KeySelector::Single(5));\n    }\n    \n    #[test]\n    fn test_parse_range() {\n        assert_eq!(\n            KeySelector::parse(\"8-15\").unwrap(),\n            KeySelector::Range { start: 8, end: 15 }\n        );\n        assert_eq!(\n            KeySelector::parse(\"0-0\").unwrap(),\n            KeySelector::Range { start: 0, end: 0 }\n        );\n    }\n    \n    #[test]\n    fn test_parse_range_invalid() {\n        assert!(KeySelector::parse(\"15-8\").is_err()); // start > end\n        assert!(KeySelector::parse(\"abc-def\").is_err());\n    }\n    \n    #[test]\n    fn test_parse_row() {\n        assert_eq!(KeySelector::parse(\"row-0\").unwrap(), KeySelector::Row(0));\n        assert_eq!(KeySelector::parse(\"row-3\").unwrap(), KeySelector::Row(3));\n    }\n    \n    #[test]\n    fn test_parse_column() {\n        assert_eq!(KeySelector::parse(\"col-0\").unwrap(), KeySelector::Column(0));\n        assert_eq!(KeySelector::parse(\"col-7\").unwrap(), KeySelector::Column(7));\n    }\n    \n    #[test]\n    fn test_parse_default() {\n        assert_eq!(KeySelector::parse(\"default\").unwrap(), KeySelector::Default);\n    }\n    \n    #[test]\n    fn test_parse_invalid() {\n        assert!(KeySelector::parse(\"\").is_err());\n        assert!(KeySelector::parse(\"foo\").is_err());\n        assert!(KeySelector::parse(\"row-\").is_err());\n        assert!(KeySelector::parse(\"-5\").is_err());\n    }\n    \n    #[test]\n    fn test_resolve_single() {\n        let device = xl_device();\n        assert_eq!(KeySelector::Single(0).resolve(&device).unwrap(), vec![0]);\n        assert_eq!(KeySelector::Single(31).resolve(&device).unwrap(), vec![31]);\n    }\n    \n    #[test]\n    fn test_resolve_single_out_of_range() {\n        let device = xl_device();\n        assert!(KeySelector::Single(32).resolve(&device).is_err());\n    }\n    \n    #[test]\n    fn test_resolve_range() {\n        let device = xl_device();\n        assert_eq!(\n            KeySelector::Range { start: 8, end: 15 }.resolve(&device).unwrap(),\n            vec![8, 9, 10, 11, 12, 13, 14, 15]\n        );\n    }\n    \n    #[test]\n    fn test_resolve_row_xl() {\n        let device = xl_device();\n        // XL is 8x4, row 0 is keys 0-7\n        assert_eq!(\n            KeySelector::Row(0).resolve(&device).unwrap(),\n            vec![0, 1, 2, 3, 4, 5, 6, 7]\n        );\n        // Row 3 is keys 24-31\n        assert_eq!(\n            KeySelector::Row(3).resolve(&device).unwrap(),\n            vec![24, 25, 26, 27, 28, 29, 30, 31]\n        );\n    }\n    \n    #[test]\n    fn test_resolve_row_mini() {\n        let device = mini_device();\n        // Mini is 3x2, row 0 is keys 0-2\n        assert_eq!(\n            KeySelector::Row(0).resolve(&device).unwrap(),\n            vec![0, 1, 2]\n        );\n        assert_eq!(\n            KeySelector::Row(1).resolve(&device).unwrap(),\n            vec![3, 4, 5]\n        );\n    }\n    \n    #[test]\n    fn test_resolve_column() {\n        let device = xl_device();\n        // XL is 8x4, column 0 is keys 0, 8, 16, 24\n        assert_eq!(\n            KeySelector::Column(0).resolve(&device).unwrap(),\n            vec![0, 8, 16, 24]\n        );\n    }\n    \n    #[test]\n    fn test_resolve_row_out_of_range() {\n        let device = xl_device();\n        assert!(KeySelector::Row(4).resolve(&device).is_err()); // XL has rows 0-3\n    }\n    \n    #[test]\n    fn test_priority_ordering() {\n        assert!(KeySelector::Single(0).priority() < KeySelector::Range { start: 0, end: 5 }.priority());\n        assert!(KeySelector::Range { start: 0, end: 5 }.priority() < KeySelector::Row(0).priority());\n        assert!(KeySelector::Row(0).priority() < KeySelector::Default.priority());\n    }\n    \n    #[test]\n    fn test_serde_roundtrip() {\n        let selectors = vec![\n            KeySelector::Single(5),\n            KeySelector::Range { start: 8, end: 15 },\n            KeySelector::Row(2),\n            KeySelector::Column(3),\n            KeySelector::Default,\n        ];\n        \n        for selector in selectors {\n            let json = serde_json::to_string(&selector).unwrap();\n            let parsed: KeySelector = serde_json::from_str(&json).unwrap();\n            assert_eq!(selector, parsed);\n        }\n    }\n}\n```\n\n## Success Criteria\n- [ ] All selector types parse correctly\n- [ ] Invalid selectors return helpful errors\n- [ ] Resolution works for all device types\n- [ ] Out-of-range detection with clear errors\n- [ ] Serde serialization/deserialization works\n- [ ] Priority ordering is correct\n- [ ] All tests pass\n\n## Logging Requirements\n- TRACE: Selector parsing attempts\n- DEBUG: Resolved key indices\n- INFO: (none)\n- WARN: Selector targets keys beyond device range\n- ERROR: Parse failures","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:55.902317074Z","created_by":"ubuntu","updated_at":"2026-01-19T21:40:41.331708575Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-a1n","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:55.914061186Z","created_by":"ubuntu"}]}
{"id":"bd-aox","title":"Implement text overlay on images","description":"Add overlay function:\n```rust\npub fn overlay_text(\n    base: &RgbaImage,\n    text: &str,\n    opts: &TextOverlay,\n) -> RgbaImage\n```\n\nOptional background rectangle for readability.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:29:15.807308593Z","created_by":"ubuntu","updated_at":"2026-01-19T18:29:15.818600052Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-aox","depends_on_id":"bd-1sl","type":"parent-child","created_at":"2026-01-19T18:29:15.818546131Z","created_by":"ubuntu"}]}
{"id":"bd-b14","title":"Set up axum server skeleton","description":"## Purpose\nCreate the foundational web server infrastructure using axum for the Stream Deck web dashboard.\n\n## Implementation\n```rust\n// src/server/mod.rs\npub mod api;\npub mod state;\n\nuse axum::{Router, routing::get, Extension};\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tower_http::cors::{CorsLayer, Any};\nuse tower_http::services::ServeDir;\nuse tracing::{debug, info, warn, error, instrument};\n\nuse crate::device::Device;\n\npub use state::AppState;\n\n/// Server configuration\n#[derive(Debug, Clone)]\npub struct ServerConfig {\n    pub port: u16,\n    pub host: String,\n    pub auto_open: bool,\n    pub static_dir: Option<std::path::PathBuf>,\n}\n\nimpl Default for ServerConfig {\n    fn default() -> Self {\n        Self {\n            port: 8420,\n            host: \"127.0.0.1\".to_string(),\n            auto_open: true,\n            static_dir: None,\n        }\n    }\n}\n\n/// Create the main application router\n#[instrument(skip(state))]\npub fn create_router(state: AppState, config: &ServerConfig) -> Router {\n    info!(\"Creating API router\");\n    \n    let api_routes = Router::new()\n        .route(\"/device\", get(api::get_device_info))\n        .route(\"/brightness\", get(api::get_brightness).put(api::set_brightness))\n        .route(\"/keys\", get(api::get_keys))\n        .route(\"/keys/:id\", \n            axum::routing::put(api::set_key)\n                .delete(api::clear_key))\n        .route(\"/keys/:id/color\", axum::routing::put(api::set_key_color))\n        .route(\"/health\", get(api::health_check));\n    \n    let mut router = Router::new()\n        .nest(\"/api\", api_routes)\n        .layer(CorsLayer::new()\n            .allow_origin(Any)\n            .allow_methods(Any)\n            .allow_headers(Any))\n        .with_state(state);\n    \n    // Serve static files (frontend)\n    if let Some(ref static_dir) = config.static_dir {\n        debug!(dir = %static_dir.display(), \"Serving static files\");\n        router = router.nest_service(\"/\", ServeDir::new(static_dir));\n    } else {\n        // In release builds, serve embedded assets\n        #[cfg(not(debug_assertions))]\n        {\n            use crate::server::embedded::EmbeddedAssets;\n            router = router.fallback_service(EmbeddedAssets);\n        }\n        \n        #[cfg(debug_assertions)]\n        {\n            // In debug, serve from default static directory\n            let default_static = std::path::PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n                .join(\"static\");\n            if default_static.exists() {\n                debug!(dir = %default_static.display(), \"Serving static files from default location\");\n                router = router.nest_service(\"/\", ServeDir::new(default_static));\n            }\n        }\n    }\n    \n    router\n}\n\n/// Start the web server\n#[instrument(skip(device))]\npub async fn start_server(\n    device: Device,\n    config: ServerConfig,\n) -> Result<(), ServerError> {\n    let addr: SocketAddr = format!(\"{}:{}\", config.host, config.port)\n        .parse()\n        .map_err(|e| ServerError::InvalidAddress(format!(\"{}\", e)))?;\n    \n    let state = AppState::new(device);\n    let router = create_router(state, &config);\n    \n    info!(\n        host = %config.host,\n        port = %config.port,\n        \"Starting web server\"\n    );\n    \n    // Auto-open browser\n    if config.auto_open {\n        let url = format!(\"http://{}:{}\", config.host, config.port);\n        info!(url = %url, \"Opening browser\");\n        \n        if let Err(e) = open_browser(&url) {\n            warn!(error = %e, \"Failed to open browser automatically\");\n        }\n    }\n    \n    println!(\"Stream Deck web interface running at http://{}:{}\", config.host, config.port);\n    println!(\"Press Ctrl+C to stop\");\n    \n    let listener = tokio::net::TcpListener::bind(addr).await\n        .map_err(|e| ServerError::BindFailed(e))?;\n    \n    axum::serve(listener, router)\n        .await\n        .map_err(|e| ServerError::ServerFailed(e))?;\n    \n    Ok(())\n}\n\n/// Open URL in default browser\nfn open_browser(url: &str) -> Result<(), std::io::Error> {\n    #[cfg(target_os = \"macos\")]\n    {\n        std::process::Command::new(\"open\").arg(url).spawn()?;\n    }\n    \n    #[cfg(target_os = \"linux\")]\n    {\n        std::process::Command::new(\"xdg-open\").arg(url).spawn()?;\n    }\n    \n    #[cfg(target_os = \"windows\")]\n    {\n        std::process::Command::new(\"cmd\")\n            .args([\"/C\", \"start\", url])\n            .spawn()?;\n    }\n    \n    Ok(())\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ServerError {\n    #[error(\"Invalid address: {0}\")]\n    InvalidAddress(String),\n    \n    #[error(\"Failed to bind to address: {0}\")]\n    BindFailed(std::io::Error),\n    \n    #[error(\"Server error: {0}\")]\n    ServerFailed(std::io::Error),\n}\n```\n\n### Application State\n```rust\n// src/server/state.rs\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse crate::device::Device;\n\n/// Shared application state for all handlers\n#[derive(Clone)]\npub struct AppState {\n    /// Device handle (thread-safe)\n    device: Arc<RwLock<Device>>,\n}\n\nimpl AppState {\n    pub fn new(device: Device) -> Self {\n        Self {\n            device: Arc::new(RwLock::new(device)),\n        }\n    }\n    \n    /// Get read access to device\n    pub async fn device(&self) -> tokio::sync::RwLockReadGuard<'_, Device> {\n        self.device.read().await\n    }\n    \n    /// Get write access to device\n    pub async fn device_mut(&self) -> tokio::sync::RwLockWriteGuard<'_, Device> {\n        self.device.write().await\n    }\n}\n```\n\n### Health Check Endpoint\n```rust\n// src/server/api.rs (partial)\nuse axum::Json;\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct HealthResponse {\n    pub status: String,\n    pub version: String,\n    pub device_connected: bool,\n}\n\npub async fn health_check(\n    State(state): State<AppState>,\n) -> Json<HealthResponse> {\n    let device_connected = state.device().await.is_connected();\n    \n    Json(HealthResponse {\n        status: \"ok\".to_string(),\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        device_connected,\n    })\n}\n```\n\n### CLI Integration\n```rust\n// In src/main.rs cmd_serve handler\nasync fn cmd_serve(opts: ServeOptions, device: Device) -> Result<()> {\n    let config = ServerConfig {\n        port: opts.port,\n        host: opts.host.unwrap_or_else(|| \"127.0.0.1\".to_string()),\n        auto_open: !opts.no_open,\n        static_dir: opts.static_dir,\n    };\n    \n    server::start_server(device, config).await?;\n    \n    Ok(())\n}\n```\n\n## Dependencies to Add\n```toml\n# Cargo.toml additions\n[dependencies]\naxum = \"0.8\"\ntokio = { version = \"1\", features = [\"full\"] }\ntower = \"0.5\"\ntower-http = { version = \"0.6\", features = [\"fs\", \"cors\"] }\n```\n\n## Success Criteria\n- [ ] Server starts on configurable port (default 8420)\n- [ ] CORS enabled for local development\n- [ ] Static files served from filesystem or embedded\n- [ ] Browser auto-opens on start (unless --no-open)\n- [ ] Health check endpoint returns device status\n- [ ] Graceful shutdown on Ctrl+C\n\n## Logging Requirements\n- TRACE: (none for server skeleton)\n- DEBUG: Static file directory, request routing\n- INFO: Server starting, browser opening, server address\n- WARN: Failed to open browser\n- ERROR: Bind failed, server error","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:42.555773688Z","created_by":"ubuntu","updated_at":"2026-01-19T20:53:01.456137464Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-b14","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:42.584443487Z","created_by":"ubuntu"}]}
{"id":"bd-bxu","title":"Create integration test module structure","description":"## Purpose\nOrganize integration tests that test component interactions without real hardware.\n\n## Directory Structure\n```\ntests/\n├── common/\n│   ├── mod.rs\n│   ├── cli.rs        # E2E CLI helpers\n│   ├── mock.rs       # MockDevice re-export\n│   └── fixtures.rs   # Fixture path helpers\n├── fixtures/         # Test data (see other task)\n├── e2e/\n│   ├── mod.rs\n│   ├── batch.rs\n│   ├── brightness.rs\n│   ├── config.rs\n│   └── watch.rs\n└── integration/\n    ├── mod.rs\n    ├── device_operations.rs\n    ├── image_processing.rs\n    ├── config_parsing.rs\n    └── state_management.rs\n```\n\n## Integration Test Examples\n```rust\n// tests/integration/device_operations.rs\nuse sd::device::{MockDevice, DeviceModel, DeviceOperations};\n\n#[test]\nfn test_brightness_bounds() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    \n    // Valid brightness\n    device.set_brightness(50).unwrap();\n    assert_eq!(device.get_brightness(), 50);\n    \n    // Boundary values\n    device.set_brightness(0).unwrap();\n    device.set_brightness(100).unwrap();\n}\n\n#[test]\nfn test_key_image_recording() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    let image_data = vec![0u8; 72 * 72 * 3];\n    \n    device.set_key_image(0, &image_data).unwrap();\n    \n    let ops = device.get_operations();\n    assert!(matches!(ops[0], Operation::SetKeyImage { key: 0, .. }));\n    assert_eq!(device.get_key_image(0), Some(&image_data[..]));\n}\n\n#[test]\nfn test_error_injection() {\n    let mut device = MockDevice::new(DeviceModel::XL);\n    device.inject_error(SdError::DeviceDisconnected);\n    \n    let result = device.set_brightness(50);\n    assert!(matches!(result, Err(SdError::DeviceDisconnected)));\n}\n```\n\n## Success Criteria\n- [ ] Test modules organized by feature area\n- [ ] Integration tests use MockDevice\n- [ ] Tests cover happy path and error cases\n- [ ] Tests are independent and can run in parallel\n- [ ] Clear naming convention for test functions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:52.095169802Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:52.105597025Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-bxu","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:52.105542662Z","created_by":"ubuntu"}]}
{"id":"bd-df0","title":"Handle missing source images gracefully","description":"When restoring and source image is missing:\n1. Check for cached version in snapshot\n2. If cached exists, use it and warn user\n3. If no cache, skip key and report error\n4. Continue with other keys (dont fail completely)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:05.843973672Z","created_by":"ubuntu","updated_at":"2026-01-21T11:24:31.630045325Z","closed_at":"2026-01-21T11:24:31.629974542Z","close_reason":"Implemented in apply_cached_image function. Restore command tries cached image first, falls back to source path if missing, logs warnings, and continues with other keys rather than failing completely.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-df0","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.853607040Z","created_by":"ubuntu"}]}
{"id":"bd-e36","title":"Implement session state tracking","description":"## Purpose\nTrack device state changes during a session for snapshots and export functionality.\n\n## Implementation\n\n```rust\n// src/state.rs\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::sync::{Arc, RwLock};\nuse tracing::{debug, trace, info, instrument};\n\n/// State of a single key\n#[derive(Debug, Clone)]\npub enum KeyState {\n    /// Key has an image set (source path)\n    Image(PathBuf),\n    /// Key filled with solid color (hex)\n    Color(String),\n    /// Key explicitly cleared\n    Cleared,\n}\n\n/// Tracked session state\n#[derive(Debug, Clone, Default)]\npub struct SessionState {\n    /// Current brightness (if set during session)\n    pub brightness: Option<u8>,\n    /// Per-key state (only keys modified during session)\n    pub keys: HashMap<u8, KeyState>,\n}\n\nimpl SessionState {\n    /// Record a brightness change\n    #[instrument(skip(self))]\n    pub fn record_brightness(&mut self, level: u8) {\n        debug!(level = %level, \"Recording brightness change\");\n        self.brightness = Some(level);\n    }\n    \n    /// Record setting a key image\n    #[instrument(skip(self), fields(key = %key, path = %path.display()))]\n    pub fn record_set_key(&mut self, key: u8, path: PathBuf) {\n        trace!(\"Recording key image\");\n        self.keys.insert(key, KeyState::Image(path));\n    }\n    \n    /// Record filling a key with color\n    #[instrument(skip(self), fields(key = %key, color = %color))]\n    pub fn record_fill_key(&mut self, key: u8, color: String) {\n        trace!(\"Recording key color\");\n        self.keys.insert(key, KeyState::Color(color));\n    }\n    \n    /// Record clearing a key\n    #[instrument(skip(self))]\n    pub fn record_clear_key(&mut self, key: u8) {\n        trace!(key = %key, \"Recording key clear\");\n        self.keys.insert(key, KeyState::Cleared);\n    }\n    \n    /// Clear all tracked state\n    pub fn reset(&mut self) {\n        info!(\"Session state reset\");\n        self.brightness = None;\n        self.keys.clear();\n    }\n    \n    /// Check if any state has been tracked\n    pub fn is_empty(&self) -> bool {\n        self.brightness.is_none() && self.keys.is_empty()\n    }\n    \n    /// Get count of tracked keys\n    pub fn key_count(&self) -> usize {\n        self.keys.len()\n    }\n}\n\n/// Global session state with thread-safe access\nstatic SESSION_STATE: once_cell::sync::Lazy<Arc<RwLock<SessionState>>> = \n    once_cell::sync::Lazy::new(|| Arc::new(RwLock::new(SessionState::default())));\n\n/// Get read access to session state\npub fn session_state() -> std::sync::RwLockReadGuard<'static, SessionState> {\n    SESSION_STATE.read().unwrap()\n}\n\n/// Get write access to session state\npub fn session_state_mut() -> std::sync::RwLockWriteGuard<'static, SessionState> {\n    SESSION_STATE.write().unwrap()\n}\n\n/// Record operations using the global state\npub mod record {\n    use super::*;\n    \n    pub fn brightness(level: u8) {\n        session_state_mut().record_brightness(level);\n    }\n    \n    pub fn set_key(key: u8, path: PathBuf) {\n        session_state_mut().record_set_key(key, path);\n    }\n    \n    pub fn fill_key(key: u8, color: String) {\n        session_state_mut().record_fill_key(key, color);\n    }\n    \n    pub fn clear_key(key: u8) {\n        session_state_mut().record_clear_key(key);\n    }\n}\n```\n\n## Integration Points\n- All mutating commands call record::* after successful device operation\n- Snapshot save serializes session_state()\n- Export iterates session_state().keys\n- New session resets state (optional, for long-running processes)\n\n## Edge Cases\n- Multiple operations on same key → latest wins\n- clear-all → iterate all keys or track separately\n- No operations → empty state (valid for empty snapshot)\n\n## Logging Requirements\n- TRACE: Each individual state change\n- DEBUG: State change with details (path, color, level)\n- INFO: State reset, summary on snapshot save\n- WARN: (none expected)\n- ERROR: (none - state changes can't fail)\n\n## Success Criteria\n- [ ] All mutating commands update state\n- [ ] State survives across commands in session\n- [ ] Thread-safe for potential concurrent access\n- [ ] Reset clears all tracked data\n- [ ] State serializes correctly for snapshots","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:05.077604396Z","created_by":"ubuntu","updated_at":"2026-01-21T11:15:23.627388501Z","closed_at":"2026-01-21T11:15:23.627337876Z","close_reason":"Implemented session state tracking in src/state.rs with SessionState struct, KeyState enum, global state access via LazyLock+RwLock, record module for convenience functions, and comprehensive tests. Integrated into all mutating commands in main.rs.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e36","depends_on_id":"bd-34i","type":"parent-child","created_at":"2026-01-19T18:24:05.086576789Z","created_by":"ubuntu"}]}
{"id":"bd-e3b","title":"Implement cache key generation","description":"Generate cache key from:\n- SHA256 of source file contents\n- Target dimensions (width, height)\n\nFormat: {hash}-{w}x{h}.bin\nExample: a1b2c3d4...72x72.bin","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.776692846Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.786506503Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e3b","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.786457801Z","created_by":"ubuntu"}]}
{"id":"bd-eg3r","title":"Implement version_info with styled info Panel","description":"# Implement version_info with styled info Panel\n\n## Purpose\nDisplay version and build information in a polished panel format. This is shown when users run sd version and provides useful debugging information while looking professional.\n\n## Target Output\n```\n╭───────────────────── sd ─────────────────────╮\n│                                              │\n│  Version     0.1.0                           │\n│  Git SHA     8ce48bc (dirty)                 │\n│  Built       2026-01-19T10:30:00Z            │\n│  Rust        1.85.0-nightly                  │\n│  Target      x86_64-unknown-linux-gnu        │\n│                                              │\n╰──────────────────────────────────────────────╯\n```\n\n## Implementation\n\n### version_info Method\n```rust\nfn version_info(&self, version: &str, git_sha: Option<&str>, build_time: Option<&str>) {\n    let mut content = Text::new(\"\\n\");\n    \n    // Version (always present)\n    content.append_styled(\"  Version     \", self.theme.label.clone());\n    content.append_styled(&format!(\"{}\\n\", version), self.theme.value.clone());\n    \n    // Git SHA (from vergen, may include dirty flag)\n    if let Some(sha) = git_sha {\n        content.append_styled(\"  Git SHA     \", self.theme.label.clone());\n        \n        // Color dirty indicator red\n        if sha.contains(\"dirty\") {\n            let clean_sha = sha.replace(\" (dirty)\", \"\").replace(\"(dirty)\", \"\");\n            content.append_styled(&clean_sha, self.theme.value.clone());\n            content.append_styled(\" (dirty)\", Style::new().color(self.theme.warning.clone()));\n        } else {\n            content.append_styled(sha, self.theme.value.clone());\n        }\n        content.append(\"\\n\");\n    }\n    \n    // Build time\n    if let Some(time) = build_time {\n        content.append_styled(\"  Built       \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", time), self.theme.muted.clone());\n    }\n    \n    // Rust version (from env at compile time)\n    if let Ok(rustc) = std::env::var(\"VERGEN_RUSTC_SEMVER\") {\n        content.append_styled(\"  Rust        \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", rustc), self.theme.muted.clone());\n    }\n    \n    // Target triple\n    if let Ok(target) = std::env::var(\"VERGEN_CARGO_TARGET_TRIPLE\") {\n        content.append_styled(\"  Target      \", self.theme.label.clone());\n        content.append_styled(&format!(\"{}\\n\", target), self.theme.muted.clone());\n    }\n    \n    content.append(\"\\n\");\n    \n    let panel = Panel::from_rich_text(content, self.width().saturating_sub(4))\n        .title(\"sd\")\n        .border_style(Style::new().color(self.theme.accent.clone()))\n        .rounded();\n    \n    self.console.print_renderable(&panel);\n}\n```\n\n### Compile-Time Metadata Access\nThe build.rs uses vergen to embed these at compile time:\n```rust\n// Access in main.rs or version command\nconst VERSION: &str = env!(\"CARGO_PKG_VERSION\");\nconst GIT_SHA: Option<&str> = option_env!(\"VERGEN_GIT_SHA\");\nconst GIT_DIRTY: Option<&str> = option_env!(\"VERGEN_GIT_DIRTY\");\nconst BUILD_TIME: Option<&str> = option_env!(\"VERGEN_BUILD_TIMESTAMP\");\nconst RUSTC_VERSION: Option<&str> = option_env!(\"VERGEN_RUSTC_SEMVER\");\nconst TARGET_TRIPLE: Option<&str> = option_env!(\"VERGEN_CARGO_TARGET_TRIPLE\");\n\n// Combine SHA and dirty flag\nlet git_sha = match (GIT_SHA, GIT_DIRTY) {\n    (Some(sha), Some(\"true\")) => Some(format!(\"{} (dirty)\", sha)),\n    (Some(sha), _) => Some(sha.to_string()),\n    _ => None,\n};\n```\n\n## Design Decisions\n\n### Panel Title \"sd\"\n- Short, recognizable\n- Matches CLI name\n- Centered in accent color\n\n### Label Alignment\n- Fixed-width labels (12 chars with padding)\n- Creates visual column alignment\n- Easy to scan\n\n### Dirty Indicator\n- Yellow/amber color draws attention\n- Indicates uncommitted changes in build\n- Useful for debugging version issues\n\n### Optional Fields\n- Git SHA may not be available (non-git checkout)\n- Build time may be disabled\n- Gracefully omit missing fields\n\n### Information Selection\n- Version: Primary identifier\n- Git SHA: Exact commit for bug reports\n- Build time: When binary was compiled\n- Rust version: Compiler used\n- Target: Architecture (useful for cross-compiled binaries)\n\n## Testing\n```rust\n#[test]\nfn version_info_shows_version() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| {\n        output.version_info(\"0.1.0\", Some(\"abc123\"), Some(\"2026-01-01T00:00:00Z\"));\n    });\n    \n    assert!(captured.contains(\"0.1.0\"));\n    assert!(captured.contains(\"abc123\"));\n}\n\n#[test]\nfn version_info_highlights_dirty() {\n    let output = HumanOutput::new(test_console());\n    \n    let captured = capture_output(|| {\n        output.version_info(\"0.1.0\", Some(\"abc123 (dirty)\"), None);\n    });\n    \n    // Verify dirty indicator is present and styled differently\n    assert!(captured.contains(\"dirty\"));\n}\n```\n\n## Acceptance Criteria\n- [ ] Version info displays in styled panel\n- [ ] Panel title is \"sd\"\n- [ ] Labels are aligned in a column\n- [ ] Dirty indicator is highlighted in amber/yellow\n- [ ] Missing fields are gracefully omitted\n- [ ] Border uses accent color","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:08:14.737413735Z","created_by":"ubuntu","updated_at":"2026-01-19T21:08:14.781492096Z","compaction_level":0,"original_size":0,"labels":["metadata","phase-2","rich-rust","version"],"dependencies":[{"issue_id":"bd-eg3r","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:08:14.781454505Z","created_by":"ubuntu"},{"issue_id":"bd-eg3r","depends_on_id":"bd-533","type":"parent-child","created_at":"2026-01-19T21:08:14.775782225Z","created_by":"ubuntu"}]}
{"id":"bd-gbs","title":"Implement cmd_completions handler in main.rs","description":"Implement the completions command:\n```rust\nuse clap::CommandFactory;\nuse clap_complete::generate;\n\nfn cmd_completions(shell: clap_complete::Shell) {\n    let mut cmd = Cli::command();\n    let name = cmd.get_name().to_string();\n    generate(shell, &mut cmd, name, &mut std::io::stdout());\n}\n```\n\nAdd dispatch in main match statement.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:59.459670076Z","created_by":"ubuntu","updated_at":"2026-01-21T11:00:01.404462766Z","closed_at":"2026-01-21T11:00:01.404416969Z","close_reason":"Already implemented in main.rs:703-706 using clap_complete::generate","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-gbs","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:24:59.469880500Z","created_by":"ubuntu"}]}
{"id":"bd-hgu","title":"Implement ImageCache struct with get/put","description":"## Purpose\nCreate the core ImageCache struct that stores pre-processed, device-ready image data.\n\n## Implementation\n```rust\n// src/cache.rs\nuse std::path::{Path, PathBuf};\nuse std::io;\nuse tracing::{debug, trace, info, warn, error, instrument};\n\n/// Content-addressable image cache for pre-processed device images\npub struct ImageCache {\n    cache_dir: PathBuf,\n    /// Track hits and misses for statistics\n    hits: std::sync::atomic::AtomicU64,\n    misses: std::sync::atomic::AtomicU64,\n}\n\nimpl ImageCache {\n    /// Create new cache, initializing directory structure\n    #[instrument]\n    pub fn new() -> Result<Self, CacheError> {\n        let cache_dir = Self::default_cache_dir()?;\n        \n        trace!(dir = %cache_dir.display(), \"Creating cache directory\");\n        std::fs::create_dir_all(&cache_dir)?;\n        \n        info!(dir = %cache_dir.display(), \"Image cache initialized\");\n        \n        Ok(Self {\n            cache_dir,\n            hits: std::sync::atomic::AtomicU64::new(0),\n            misses: std::sync::atomic::AtomicU64::new(0),\n        })\n    }\n    \n    /// Create cache at specific location (for testing)\n    pub fn with_dir(cache_dir: PathBuf) -> Result<Self, CacheError> {\n        std::fs::create_dir_all(&cache_dir)?;\n        Ok(Self {\n            cache_dir,\n            hits: std::sync::atomic::AtomicU64::new(0),\n            misses: std::sync::atomic::AtomicU64::new(0),\n        })\n    }\n    \n    /// Get default cache directory (~/.cache/sd/images/)\n    fn default_cache_dir() -> Result<PathBuf, CacheError> {\n        dirs::cache_dir()\n            .ok_or(CacheError::NoCacheDir)\n            .map(|d| d.join(\"sd\").join(\"images\"))\n    }\n    \n    /// Retrieve cached image data if it exists\n    #[instrument(skip(self), fields(cache_key))]\n    pub fn get(&self, source: &Path, width: u32, height: u32) -> Option<Vec<u8>> {\n        let key = cache_key(source, width, height)?;\n        let cache_path = self.cache_dir.join(&key);\n        \n        tracing::Span::current().record(\"cache_key\", &key);\n        \n        match std::fs::read(&cache_path) {\n            Ok(data) => {\n                self.hits.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                debug!(\n                    size_bytes = %data.len(),\n                    \"Cache hit\"\n                );\n                Some(data)\n            }\n            Err(e) if e.kind() == io::ErrorKind::NotFound => {\n                self.misses.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                trace!(\"Cache miss\");\n                None\n            }\n            Err(e) => {\n                warn!(error = %e, \"Cache read error\");\n                self.misses.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                None\n            }\n        }\n    }\n    \n    /// Store processed image in cache\n    #[instrument(skip(self, data), fields(cache_key, size_bytes = %data.len()))]\n    pub fn put(&self, source: &Path, width: u32, height: u32, data: &[u8]) -> Result<(), CacheError> {\n        let key = cache_key(source, width, height)\n            .ok_or(CacheError::InvalidSource)?;\n        let cache_path = self.cache_dir.join(&key);\n        \n        tracing::Span::current().record(\"cache_key\", &key);\n        \n        trace!(\"Writing to cache\");\n        \n        // Write to temp file first, then rename (atomic)\n        let temp_path = cache_path.with_extension(\"tmp\");\n        std::fs::write(&temp_path, data)?;\n        std::fs::rename(&temp_path, &cache_path)?;\n        \n        debug!(\"Cached successfully\");\n        Ok(())\n    }\n    \n    /// Get cache statistics\n    pub fn stats(&self) -> CacheStats {\n        let entries = std::fs::read_dir(&self.cache_dir)\n            .map(|rd| rd.filter_map(|e| e.ok()).collect::<Vec<_>>())\n            .unwrap_or_default();\n        \n        let total_size: u64 = entries.iter()\n            .filter_map(|e| e.metadata().ok())\n            .map(|m| m.len())\n            .sum();\n        \n        let hits = self.hits.load(std::sync::atomic::Ordering::Relaxed);\n        let misses = self.misses.load(std::sync::atomic::Ordering::Relaxed);\n        \n        CacheStats {\n            location: self.cache_dir.clone(),\n            entries: entries.len(),\n            size_bytes: total_size,\n            hits,\n            misses,\n        }\n    }\n    \n    /// Clear all cached images, returns count of removed entries\n    #[instrument(skip(self))]\n    pub fn clear(&self) -> Result<usize, CacheError> {\n        let entries = std::fs::read_dir(&self.cache_dir)?;\n        let mut count = 0;\n        \n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            if path.extension().map(|e| e == \"bin\").unwrap_or(false) {\n                trace!(file = %path.display(), \"Removing cached file\");\n                std::fs::remove_file(&path)?;\n                count += 1;\n            }\n        }\n        \n        info!(removed = %count, \"Cache cleared\");\n        Ok(count)\n    }\n}\n\n/// Generate cache key from source file and dimensions\nfn cache_key(source: &Path, width: u32, height: u32) -> Option<String> {\n    use sha2::{Sha256, Digest};\n    \n    let content = std::fs::read(source).ok()?;\n    \n    let mut hasher = Sha256::new();\n    hasher.update(&content);\n    hasher.update(width.to_le_bytes());\n    hasher.update(height.to_le_bytes());\n    let hash = hasher.finalize();\n    \n    Some(format!(\"{:x}-{}x{}.bin\", hash, width, height))\n}\n\n#[derive(Debug)]\npub struct CacheStats {\n    pub location: PathBuf,\n    pub entries: usize,\n    pub size_bytes: u64,\n    pub hits: u64,\n    pub misses: u64,\n}\n\nimpl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        let total = self.hits + self.misses;\n        if total == 0 {\n            0.0\n        } else {\n            self.hits as f64 / total as f64\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum CacheError {\n    #[error(\"No cache directory available\")]\n    NoCacheDir,\n    #[error(\"Invalid source path\")]\n    InvalidSource,\n    #[error(\"IO error: {0}\")]\n    Io(#[from] io::Error),\n}\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_cache_miss_then_hit() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        // Create a test image file\n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"fake image data\").unwrap();\n        \n        // First access should miss\n        assert!(cache.get(&img_path, 72, 72).is_none());\n        \n        // Store data\n        cache.put(&img_path, 72, 72, b\"processed data\").unwrap();\n        \n        // Second access should hit\n        let data = cache.get(&img_path, 72, 72).unwrap();\n        assert_eq!(data, b\"processed data\");\n    }\n    \n    #[test]\n    fn test_different_dimensions_different_keys() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"fake image\").unwrap();\n        \n        cache.put(&img_path, 72, 72, b\"72x72 data\").unwrap();\n        cache.put(&img_path, 96, 96, b\"96x96 data\").unwrap();\n        \n        assert_eq!(cache.get(&img_path, 72, 72).unwrap(), b\"72x72 data\");\n        assert_eq!(cache.get(&img_path, 96, 96).unwrap(), b\"96x96 data\");\n    }\n    \n    #[test]\n    fn test_stats() {\n        let temp = TempDir::new().unwrap();\n        let cache = ImageCache::with_dir(temp.path().to_path_buf()).unwrap();\n        \n        let img_path = temp.path().join(\"test.png\");\n        std::fs::write(&img_path, b\"test\").unwrap();\n        \n        // Miss, store, hit, hit\n        cache.get(&img_path, 72, 72);  // miss\n        cache.put(&img_path, 72, 72, b\"data\").unwrap();\n        cache.get(&img_path, 72, 72);  // hit\n        cache.get(&img_path, 72, 72);  // hit\n        \n        let stats = cache.stats();\n        assert_eq!(stats.hits, 2);\n        assert_eq!(stats.misses, 1);\n        assert_eq!(stats.entries, 1);\n    }\n}\n```\n\n## Success Criteria\n- [ ] Cache directory created at ~/.cache/sd/images/ (or custom path)\n- [ ] get() returns None on miss, Some(data) on hit\n- [ ] put() writes data atomically (via temp file rename)\n- [ ] Different dimensions produce different cache keys\n- [ ] stats() returns accurate entry count, size, hits/misses\n- [ ] clear() removes all .bin files\n\n## Logging Requirements\n- TRACE: Cache directory creation, cache miss, removing individual files\n- DEBUG: Cache hit with size, cached successfully\n- INFO: Cache initialized, cache cleared with count\n- WARN: Cache read error (non-NotFound)\n- ERROR: (none for this module - errors bubble up via Result)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.475179194Z","created_by":"ubuntu","updated_at":"2026-01-19T20:49:51.475743626Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-hgu","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.484576697Z","created_by":"ubuntu"}]}
{"id":"bd-i146","title":"Implement robot mode regression tests for JSON output","description":"# Implement robot mode regression tests for JSON output\n\n## Purpose\nCreate comprehensive unit tests that verify robot mode JSON output is IDENTICAL to the pre-refactor behavior. This is the most critical testing task because AI agents depend on consistent JSON structure.\n\n## Background\nAI coding agents are the primary users of sd --robot mode. They parse JSON output programmatically. ANY change to JSON structure, field names, or formatting will break agent workflows. These tests are the safety net.\n\n## Test Strategy\n\n### Approach 1: Golden File Testing\n1. Capture current (pre-refactor) output for each command as golden files\n2. Store in tests/golden/robot/\n3. After refactor, compare output against golden files\n4. Any difference (except allowed variance like timestamps) is a regression\n\n### Approach 2: Schema Validation  \nFor outputs with variable content (timestamps, dynamic IDs), use JSON schema validation:\n- Structure is correct\n- Required fields present\n- Field types match expectations\n\n### Approach 3: Semantic Comparison\nFor complex outputs, parse JSON and compare semantically:\n- Field values match expected data\n- Array lengths correct\n- No extra/missing fields\n\n## Golden File Setup\n\n### Directory Structure\ntests/\n├── golden/\n│   └── robot/\n│       ├── list_single.json\n│       ├── list_multiple.json\n│       ├── list_empty.json\n│       ├── info.json\n│       ├── error_no_device.json\n│       ├── error_multiple.json\n│       ├── brightness_set.json\n│       ├── key_set.json\n│       ├── key_cleared.json\n│       ├── all_cleared.json\n│       ├── button_press.json\n│       └── version.json\n└── unit/\n    └── robot_output.rs\n\n### Golden File Generation Script\nCreate a script to generate golden files (run BEFORE refactor):\n#!/bin/bash\n# scripts/generate_golden.sh\nset -e\nGOLDEN_DIR=tests/golden/robot\n\necho \"Generating golden files for robot mode...\"\n\n# Note: These require a Stream Deck connected or mock device\n# For CI, use synthetic test data\n\n# Generate synthetic golden files from current output\ncat > $GOLDEN_DIR/list_single.json << 'EOF'\n[\n  {\n    \"serial\": \"AL12XL0001\",\n    \"product_name\": \"Stream Deck XL\",\n    \"firmware_version\": \"1.5.3\",\n    \"key_count\": 32,\n    \"key_width\": 96,\n    \"key_height\": 96,\n    \"rows\": 4,\n    \"cols\": 8,\n    \"kind\": \"Xl\"\n  }\n]\nEOF\n\n# ... etc for other golden files\n\n## Test Implementation\n\n### Test Module (tests/unit/robot_output.rs)\nuse sd::output::{RobotOutput, RobotFormat, Output};\nuse sd::device::{DeviceInfo, ButtonEvent};\nuse sd::error::SdError;\nuse crate::common::*;\nuse tracing::{info, debug, error, instrument};\nuse std::path::Path;\n\n/// Initialize tracing for tests\nfn setup() {\n    init_test_logging();\n}\n\n// === Device List Tests ===\n\n#[test]\n#[instrument]\nfn robot_device_list_json_structure() {\n    setup();\n    info!(\"Testing device list JSON structure\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let devices = vec![mock_device_xl()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    debug!(captured_len = captured.len(), \"Captured output\");\n    \n    // Parse and validate\n    let parsed: Vec<serde_json::Value> = serde_json::from_str(&captured)\n        .expect(\"should be valid JSON array\");\n    \n    assert_eq!(parsed.len(), 1, \"Should have exactly one device\");\n    \n    let device = &parsed[0];\n    debug!(?device, \"Parsed device\");\n    \n    // Verify ALL required fields exist and have correct types\n    assert_json_has_fields(&captured, &[\n        \"serial\", \"product_name\", \"firmware_version\",\n        \"key_count\", \"key_width\", \"key_height\", \n        \"rows\", \"cols\", \"kind\"\n    ]);\n    \n    // Verify field values\n    assert_eq!(device[\"serial\"], \"AL12XL0001\");\n    assert_eq!(device[\"product_name\"], \"Stream Deck XL\");\n    assert_eq!(device[\"firmware_version\"], \"1.5.3\");\n    assert_eq!(device[\"key_count\"], 32);\n    assert_eq!(device[\"key_width\"], 96);\n    assert_eq!(device[\"key_height\"], 96);\n    assert_eq!(device[\"rows\"], 4);\n    assert_eq!(device[\"cols\"], 8);\n    assert_eq!(device[\"kind\"], \"Xl\");\n    \n    info!(\"✓ Device list structure validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_device_list_empty() {\n    setup();\n    info!(\"Testing empty device list\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let captured = capture_stdout(|| output.device_list(&[]));\n    \n    let parsed: Vec<serde_json::Value> = serde_json::from_str(&captured)\n        .expect(\"should be valid JSON array\");\n    \n    assert!(parsed.is_empty(), \"Empty device list should be empty array\");\n    assert_eq!(captured.trim(), \"[]\", \"Empty list should be []\");\n    \n    info!(\"✓ Empty device list validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_device_list_multiple() {\n    setup();\n    info!(\"Testing multiple devices\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let devices = mock_multiple_devices();\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    \n    let parsed: Vec<DeviceInfo> = serde_json::from_str(&captured)\n        .expect(\"should deserialize to Vec<DeviceInfo>\");\n    \n    assert_eq!(parsed.len(), 3, \"Should have 3 devices\");\n    \n    // Verify each device is distinct\n    let serials: Vec<_> = parsed.iter().map(|d| &d.serial).collect();\n    assert_eq!(serials.len(), serials.iter().collect::<std::collections::HashSet<_>>().len(),\n        \"Serials should be unique\");\n    \n    info!(\"✓ Multiple devices validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_device_list_compact_json() {\n    setup();\n    info!(\"Testing compact JSON output\");\n    \n    let output = RobotOutput::new(RobotFormat::JsonCompact);\n    let devices = vec![mock_device_xl()];\n    \n    let captured = capture_stdout(|| output.device_list(&devices));\n    \n    // Compact JSON should be single line (no internal newlines)\n    let line_count = captured.trim().lines().count();\n    assert_eq!(line_count, 1, \"Compact JSON should be single line, got {} lines\", line_count);\n    \n    // Should still be valid JSON\n    let _: Vec<DeviceInfo> = serde_json::from_str(&captured)\n        .expect(\"Compact JSON should still parse\");\n    \n    info!(\"✓ Compact JSON validated\");\n}\n\n// === Error Response Tests ===\n\n#[test]\n#[instrument]\nfn robot_error_json_structure() {\n    setup();\n    info!(\"Testing error JSON structure\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let err = SdError::NoDevicesFound;\n    \n    let captured = capture_stdout(|| output.error(&err));\n    debug!(captured = %captured, \"Error output\");\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured)\n        .expect(\"Error should be valid JSON\");\n    \n    // Required fields for all errors\n    assert_eq!(parsed[\"error\"], true, \"error field must be true\");\n    assert!(parsed[\"message\"].is_string(), \"message must be string\");\n    assert!(parsed[\"recoverable\"].is_boolean(), \"recoverable must be boolean\");\n    \n    // For recoverable errors, suggestion should be present\n    if parsed[\"recoverable\"] == true {\n        assert!(parsed[\"suggestion\"].is_string() || parsed[\"suggestion\"].is_null(),\n            \"recoverable errors should have suggestion\");\n    }\n    \n    info!(\"✓ Error structure validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_error_multiple_devices() {\n    setup();\n    info!(\"Testing multiple devices error\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let err = SdError::MultipleDevices {\n        serials: vec![\"AAA\".to_string(), \"BBB\".to_string(), \"CCC\".to_string()],\n    };\n    \n    let captured = capture_stdout(|| output.error(&err));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"error\"], true);\n    let msg = parsed[\"message\"].as_str().unwrap();\n    assert!(msg.contains(\"Multiple\") || msg.contains(\"multiple\"),\n        \"Message should mention multiple devices\");\n    \n    info!(\"✓ Multiple devices error validated\");\n}\n\n// === Button Event Tests ===\n\n#[test]\n#[instrument]\nfn robot_button_event_single_line() {\n    setup();\n    info!(\"Testing button event is single line\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let event = mock_button_press(5);\n    \n    let captured = capture_stdout(|| output.button_event(&event));\n    \n    // CRITICAL: Button events MUST be single-line for streaming parsers\n    assert_eq!(captured.trim().lines().count(), 1,\n        \"Button events must be single-line JSON for streaming\");\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"key\"], 5);\n    assert_eq!(parsed[\"pressed\"], true);\n    assert!(parsed[\"timestamp_ms\"].is_number(), \"timestamp_ms must be number\");\n    \n    info!(\"✓ Button event structure validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_button_release_event() {\n    setup();\n    info!(\"Testing button release event\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let event = mock_button_release(10);\n    \n    let captured = capture_stdout(|| output.button_event(&event));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"key\"], 10);\n    assert_eq!(parsed[\"pressed\"], false);\n    \n    info!(\"✓ Button release validated\");\n}\n\n// === Success Confirmation Tests ===\n\n#[test]\n#[instrument]\nfn robot_brightness_set_json() {\n    setup();\n    info!(\"Testing brightness set confirmation\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    \n    let captured = capture_stdout(|| output.brightness_set(50));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"brightness\"], 50);\n    assert_eq!(parsed[\"ok\"], true);\n    \n    info!(\"✓ Brightness set validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_key_set_json() {\n    setup();\n    info!(\"Testing key set confirmation\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let path = Path::new(\"/path/to/icon.png\");\n    \n    let captured = capture_stdout(|| output.key_set(5, path));\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"key\"], 5);\n    assert!(parsed[\"image\"].as_str().unwrap().contains(\"icon.png\"));\n    assert_eq!(parsed[\"ok\"], true);\n    \n    info!(\"✓ Key set validated\");\n}\n\n#[test]\n#[instrument]\nfn robot_all_cleared_json() {\n    setup();\n    info!(\"Testing all cleared confirmation\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    \n    let captured = capture_stdout(|| output.all_cleared());\n    \n    let parsed: serde_json::Value = serde_json::from_str(&captured).unwrap();\n    \n    assert_eq!(parsed[\"all_cleared\"], true);\n    assert_eq!(parsed[\"ok\"], true);\n    \n    info!(\"✓ All cleared validated\");\n}\n\n// === ANSI Code Prohibition ===\n\n#[test]\n#[instrument]\nfn robot_output_no_ansi_codes() {\n    setup();\n    info!(\"Testing robot output has no ANSI codes\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    \n    // Test all output methods\n    let tests = vec![\n        (\"device_list\", capture_stdout(|| output.device_list(&[mock_device_xl()]))),\n        (\"device_info\", capture_stdout(|| output.device_info(&mock_device_xl()))),\n        (\"error\", capture_stdout(|| output.error(&SdError::NoDevicesFound))),\n        (\"success\", capture_stdout(|| output.success(\"Test message\"))),\n        (\"warning\", capture_stdout(|| output.warning(\"Test warning\"))),\n        (\"brightness_set\", capture_stdout(|| output.brightness_set(50))),\n    ];\n    \n    for (name, captured) in tests {\n        debug!(method = name, output = %captured, \"Checking for ANSI\");\n        assert_no_ansi(&captured);\n    }\n    \n    info!(\"✓ No ANSI codes in any robot output\");\n}\n\n// === Golden File Comparison ===\n\n#[test]\n#[instrument]\nfn robot_golden_device_list() {\n    setup();\n    info!(\"Comparing against golden file\");\n    \n    let golden = include_str!(\"../golden/robot/list_single.json\");\n    let golden_parsed: Vec<serde_json::Value> = serde_json::from_str(golden)\n        .expect(\"Golden file should be valid JSON\");\n    \n    let output = RobotOutput::new(RobotFormat::Json);\n    let captured = capture_stdout(|| output.device_list(&[mock_device_xl()]));\n    let actual_parsed: Vec<serde_json::Value> = serde_json::from_str(&captured)\n        .expect(\"Output should be valid JSON\");\n    \n    // Compare structure and types (values may differ for dynamic data)\n    assert_eq!(golden_parsed.len(), actual_parsed.len(), \n        \"Array lengths should match golden file\");\n    \n    if !golden_parsed.is_empty() {\n        let golden_keys: std::collections::HashSet<_> = \n            golden_parsed[0].as_object().unwrap().keys().collect();\n        let actual_keys: std::collections::HashSet<_> = \n            actual_parsed[0].as_object().unwrap().keys().collect();\n        \n        assert_eq!(golden_keys, actual_keys, \n            \"JSON keys should match golden file\");\n    }\n    \n    info!(\"✓ Golden file comparison passed\");\n}\n\n## Acceptance Criteria\n- [ ] Tests for ALL Output trait methods in robot mode\n- [ ] JSON structure validated for each command\n- [ ] Compact JSON verified as single-line\n- [ ] No ANSI codes in any robot output\n- [ ] Error responses include all required fields\n- [ ] Button events are single-line for streaming\n- [ ] Golden file comparison tests\n- [ ] All tests include tracing instrumentation\n- [ ] Tests run with RUST_LOG for debugging\n- [ ] All tests pass","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:10:29.943463786Z","created_by":"ubuntu","updated_at":"2026-01-19T21:24:57.017374235Z","compaction_level":0,"original_size":0,"labels":["phase-4","regression","rich-rust","robot-mode","testing"],"dependencies":[{"issue_id":"bd-i146","depends_on_id":"bd-1gx6","type":"blocks","created_at":"2026-01-19T21:22:54.560473164Z","created_by":"ubuntu"},{"issue_id":"bd-i146","depends_on_id":"bd-1xd","type":"blocks","created_at":"2026-01-19T21:10:29.995557258Z","created_by":"ubuntu"},{"issue_id":"bd-i146","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:10:29.989736849Z","created_by":"ubuntu"}]}
{"id":"bd-i5h","title":"Implement dry-run for set-keys (batch)","description":"When dry_run=true:\n- Scan directory and show all matches\n- For each key: show source, dimensions, resize needed\n- Show keys that would be skipped (no file)\n- Summary: N keys would be set, M would be skipped","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:24:44.755545788Z","created_by":"ubuntu","updated_at":"2026-01-19T21:46:10.175830249Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-i5h","depends_on_id":"bd-1uz","type":"blocks","created_at":"2026-01-19T21:46:09.473961710Z","created_by":"ubuntu"},{"issue_id":"bd-i5h","depends_on_id":"bd-35a","type":"parent-child","created_at":"2026-01-19T18:24:44.764953701Z","created_by":"ubuntu"},{"issue_id":"bd-i5h","depends_on_id":"bd-3lf","type":"blocks","created_at":"2026-01-19T21:46:10.175784393Z","created_by":"ubuntu"}]}
{"id":"bd-iuk","title":"Add keymap gesture support","description":"Extend keymap format:\n```yaml\nkeys:\n  0:\n    tap: open -a Chrome\n    long_press: open -a \"Chrome Canary\"\n    double_tap: open new window\n    hold: push-to-talk script\n```\n\nIntegrate with scripting hooks.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:02.758897955Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:02.768966392Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-iuk","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:02.768925646Z","created_by":"ubuntu"}]}
{"id":"bd-kguu","title":"Final verification checklist and manual testing","description":"# Final verification checklist and manual testing\n\n## Purpose\nComprehensive manual testing to verify the rich_rust integration works correctly across all commands and modes. This is the final gate before marking the epic complete.\n\n## Verification Checklist\n\n### Build Verification\n- [ ] cargo check --all-targets passes\n- [ ] cargo clippy --all-targets -- -D warnings passes\n- [ ] cargo fmt --check passes\n- [ ] cargo test passes\n- [ ] cargo build --release succeeds\n\n### Robot Mode Verification\nFor each command, verify JSON output is unchanged:\n\n- [ ] sd list --robot\n- [ ] sd info --robot\n- [ ] sd brightness 50 --robot\n- [ ] sd set-key 0 test.png --robot\n- [ ] sd clear-key 0 --robot\n- [ ] sd clear-all --robot\n- [ ] sd fill-key 0 #FF0000 --robot\n- [ ] sd fill-all #0080FF --robot\n- [ ] sd watch --robot (press button, verify JSON event)\n- [ ] sd read --robot\n- [ ] sd version --robot\n\n### Human Mode Verification\nFor each command, verify styled output looks correct:\n\n- [ ] sd list - Panel with device cards\n- [ ] sd info - Table with key layout grid\n- [ ] sd brightness 50 - Progress bar panel\n- [ ] sd set-key 0 test.png - Checkmark confirmation\n- [ ] sd clear-key 0 - Checkmark confirmation\n- [ ] sd clear-all - Checkmark confirmation\n- [ ] sd fill-key 0 #FF0000 - Checkmark with color\n- [ ] sd fill-all #0080FF - Checkmark with color\n- [ ] sd watch - Event stream with icons\n- [ ] sd read - State display\n- [ ] sd version - Info panel\n\n### Error Handling Verification\n- [ ] sd info (no device) - Error panel with suggestion\n- [ ] sd set-key 99 test.png - Invalid key error\n- [ ] sd brightness 150 - Invalid brightness error\n- [ ] sd set-key 0 nonexistent.png - File not found error\n- [ ] Multiple devices without --serial - Error with device list\n\n### Environment Verification\n- [ ] NO_COLOR=1 sd list - No ANSI codes\n- [ ] FORCE_COLOR=3 sd list - Full color even when piped\n- [ ] sd list | cat - No ANSI codes (non-TTY)\n- [ ] sd list --ascii - ASCII box characters\n\n### Cross-Platform (if possible)\n- [ ] Linux terminal - Colors and Unicode work\n- [ ] macOS Terminal.app - Colors and Unicode work\n- [ ] Windows Terminal - Colors and Unicode work\n- [ ] SSH session - Colors and Unicode work\n\n### Edge Cases\n- [ ] Very narrow terminal (<40 cols) - Output doesn't crash\n- [ ] Very wide terminal (>200 cols) - Output doesn't look broken\n- [ ] Empty device list - Shows helpful message\n- [ ] Long device serial - Wraps or truncates gracefully\n\n## Testing Commands Script\n```bash\n#!/bin/bash\n# Quick verification script\n\nset -e\n\necho \"=== Robot Mode Tests ===\"\nsd list --robot | jq .\nsd version --robot | jq .\n\necho \"=== Human Mode Tests ===\"\nsd list\nsd version\n\necho \"=== Error Tests ===\"\nsd set-key 99 /dev/null || echo \"Expected error\"\n\necho \"=== Environment Tests ===\"\nNO_COLOR=1 sd list | grep -v $'\\e' && echo \"NO_COLOR works\"\n\necho \"=== All tests passed ===\"\n```\n\n## Sign-off\nAfter completing all checks:\n- [ ] All automated tests pass\n- [ ] All manual checks pass\n- [ ] No regressions found\n- [ ] Ready for merge\n\n## Acceptance Criteria\n- [ ] All build checks pass\n- [ ] All robot mode outputs verified unchanged\n- [ ] All human mode outputs verified styled correctly\n- [ ] Error handling works correctly\n- [ ] Environment variables respected\n- [ ] Edge cases handled gracefully","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:12:42.207854333Z","created_by":"ubuntu","updated_at":"2026-01-19T21:12:42.255072626Z","compaction_level":0,"original_size":0,"labels":["phase-5","qa","rich-rust","verification"],"dependencies":[{"issue_id":"bd-kguu","depends_on_id":"bd-1z7d","type":"parent-child","created_at":"2026-01-19T21:12:42.248997408Z","created_by":"ubuntu"},{"issue_id":"bd-kguu","depends_on_id":"bd-2lfp","type":"blocks","created_at":"2026-01-19T21:12:42.255036759Z","created_by":"ubuntu"}]}
{"id":"bd-kmt","title":"Document testing strategy and guidelines","description":"## Purpose\nProvide clear guidelines for writing tests in this project.\n\n## Document Contents\nCreate `docs/TESTING.md`:\n\n```markdown\n# Testing Guide for sd\n\n## Test Categories\n\n### Unit Tests (src/**/*.rs)\n- Test individual functions in isolation\n- Use MockDevice for device operations\n- Fast, run on every commit\n- Target: 80%+ coverage\n\n### Integration Tests (tests/integration/)\n- Test component interactions\n- Use MockDevice and fixtures\n- Medium speed, run on every commit\n- Focus on data flow between components\n\n### E2E Tests (tests/e2e/)\n- Test CLI behavior end-to-end\n- Use CliRunner helper\n- May be slower, run on PR and main\n- Test user-facing behavior\n\n## Writing Tests\n\n### Naming Convention\n```rust\n#[test]\nfn test_<function>_<scenario>_<expected_outcome>() {\n    // e.g., test_set_brightness_out_of_range_returns_error\n}\n```\n\n### Test Structure (AAA Pattern)\n```rust\n#[test]\nfn test_example() {\n    // Arrange\n    let mut device = MockDevice::new(DeviceModel::XL);\n    \n    // Act\n    let result = device.set_brightness(50);\n    \n    // Assert\n    assert!(result.is_ok());\n    assert_eq!(device.get_brightness(), 50);\n}\n```\n\n### Using Fixtures\n```rust\nuse crate::common::fixtures::fixtures_path;\n\n#[test]\nfn test_with_fixture() {\n    let image_path = fixtures_path(\"images/valid/72x72.png\");\n    // ...\n}\n```\n\n## Running Tests\n\n```bash\n# All tests\ncargo test\n\n# Unit tests only\ncargo test --lib\n\n# Integration tests\ncargo test --test integration\n\n# E2E tests\ncargo test --test e2e\n\n# With logging\nRUST_LOG=debug cargo test -- --nocapture\n\n# Coverage\ncargo tarpaulin\n```\n\n## Mocking Guidelines\n\n### When to use MockDevice\n- Testing command logic\n- Testing error handling\n- Testing state management\n\n### When NOT to mock\n- Testing actual image processing (use real images)\n- Testing file I/O (use fixtures)\n- Testing CLI parsing (use CliRunner)\n```\n\n## Success Criteria\n- [ ] TESTING.md created\n- [ ] All test categories documented\n- [ ] Examples provided for each category\n- [ ] Guidelines for mocking\n- [ ] Instructions for running tests\n- [ ] CI integration documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:36:53.199538236Z","created_by":"ubuntu","updated_at":"2026-01-19T18:36:53.209925994Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-kmt","depends_on_id":"bd-31u","type":"parent-child","created_at":"2026-01-19T18:36:53.209878063Z","created_by":"ubuntu"}]}
{"id":"bd-ldu5","title":"Add ClearKeys batch command for clearing multiple keys","description":"## Purpose\nAdd `sd clear-keys` command to clear multiple keys in one operation.\n\n## CLI Definition\n```rust\n#[derive(Parser, Debug)]\npub struct ClearKeysCommand {\n    /// Clear ALL keys on the device\n    #[arg(long, conflicts_with_all = [\"range\", \"keys\"])]\n    pub all: bool,\n\n    /// Range of keys to clear (e.g., \"0-7\" for first row)\n    #[arg(long, short = 'r')]\n    pub range: Option<String>,\n\n    /// Specific key indices to clear (space-separated)\n    #[arg(value_name = \"KEYS\")]\n    pub keys: Vec<u8>,\n\n    /// Continue clearing other keys if one fails\n    #[arg(long, short = 'c')]\n    pub continue_on_error: bool,\n}\n```\n\n## Usage Examples\n```bash\n# Clear all keys\nsd clear-keys --all\n\n# Clear first row (keys 0-7)\nsd clear-keys --range 0-7\n\n# Clear specific keys\nsd clear-keys 0 5 10 15\n\n# Clear with robot mode output\nsd clear-keys --all --robot\n```\n\n## Robot Mode Output\n```json\n{\n  \"command\": \"clear-keys\",\n  \"results\": [\n    {\"key\": 0, \"status\": \"cleared\"},\n    {\"key\": 1, \"status\": \"cleared\"}\n  ],\n  \"summary\": {\n    \"total\": 32,\n    \"cleared\": 32,\n    \"failed\": 0\n  }\n}\n```\n\n## Logging Requirements\n- TRACE: Each key clear operation\n- DEBUG: Range parsing, key selection\n- INFO: Operation start/complete with counts\n- WARN: Individual key failures with continue-on-error\n- ERROR: Fatal failures\n\n## Success Criteria\n- [ ] --all clears entire device\n- [ ] --range parses and clears key ranges\n- [ ] Specific keys can be listed\n- [ ] Robot mode returns per-key status\n- [ ] Human mode shows progress","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T21:21:17.121679262Z","created_by":"ubuntu","updated_at":"2026-01-21T11:07:26.431228832Z","closed_at":"2026-01-21T11:07:26.431182264Z","close_reason":"Implemented sd clear-keys with --all, --range, --keys options, continue-on-error, and robot mode JSON output","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-ldu5","depends_on_id":"bd-1ch","type":"blocks","created_at":"2026-01-19T21:53:23.730254479Z","created_by":"ubuntu"},{"issue_id":"bd-ldu5","depends_on_id":"bd-1q8","type":"blocks","created_at":"2026-01-19T21:53:30.782724147Z","created_by":"ubuntu"},{"issue_id":"bd-ldu5","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T21:21:17.151945330Z","created_by":"ubuntu"}]}
{"id":"bd-mwd","title":"Add robot mode rate limit reporting","description":"## Purpose\nAdd comprehensive robot mode reporting for rate limiting status in batch operations.\n\n## Implementation\n\\`\\`\\`rust\n// In src/output/robot.rs\nuse serde::Serialize;\n\n/// Rate limit information for robot mode output\n#[derive(Debug, Serialize)]\npub struct RateLimitInfo {\n    /// Whether rate limiting is enabled for this operation\n    pub enabled: bool,\n    /// Configured interval in milliseconds\n    pub interval_ms: Option<u64>,\n    /// Burst capacity (if using TokenBucket)\n    pub burst_capacity: Option<usize>,\n}\n\n/// Per-operation rate limit status\n#[derive(Debug, Serialize)]\npub struct OperationRateLimitStatus {\n    /// Whether this specific operation was delayed by rate limiting\n    pub rate_limited: bool,\n    /// How long we waited in milliseconds (0 if not rate limited)\n    pub waited_ms: u64,\n    /// Current tokens available (for TokenBucket)\n    pub tokens_available: Option<f64>,\n}\n\n/// Batch result with rate limit info\n#[derive(Debug, Serialize)]\npub struct BatchResultRobot {\n    pub command: String,\n    pub rate_limit: RateLimitInfo,\n    pub operations: Vec<OperationResultRobot>,\n    pub summary: BatchSummaryRobot,\n}\n\n#[derive(Debug, Serialize)]\npub struct OperationResultRobot {\n    pub key: u8,\n    pub status: String,\n    pub error: Option<String>,\n    pub rate_limit_status: OperationRateLimitStatus,\n    pub duration_ms: u64,\n}\n\n#[derive(Debug, Serialize)]\npub struct BatchSummaryRobot {\n    pub total: usize,\n    pub successful: usize,\n    pub failed: usize,\n    pub skipped: usize,\n    pub total_duration_ms: u64,\n    pub operations_rate_limited: usize,\n    pub total_wait_time_ms: u64,\n}\n\\`\\`\\`\n\n### Example Robot Mode Output\n\\`\\`\\`json\n{\n  \"command\": \"set-keys\",\n  \"rate_limit\": {\n    \"enabled\": true,\n    \"interval_ms\": 50,\n    \"burst_capacity\": null\n  },\n  \"operations\": [\n    {\n      \"key\": 0,\n      \"status\": \"success\",\n      \"error\": null,\n      \"rate_limit_status\": {\n        \"rate_limited\": false,\n        \"waited_ms\": 0,\n        \"tokens_available\": null\n      },\n      \"duration_ms\": 45\n    },\n    {\n      \"key\": 1,\n      \"status\": \"success\",\n      \"error\": null,\n      \"rate_limit_status\": {\n        \"rate_limited\": true,\n        \"waited_ms\": 48,\n        \"tokens_available\": null\n      },\n      \"duration_ms\": 92\n    },\n    {\n      \"key\": 2,\n      \"status\": \"failed\",\n      \"error\": \"Device disconnected\",\n      \"rate_limit_status\": {\n        \"rate_limited\": true,\n        \"waited_ms\": 51,\n        \"tokens_available\": null\n      },\n      \"duration_ms\": 55\n    }\n  ],\n  \"summary\": {\n    \"total\": 3,\n    \"successful\": 2,\n    \"failed\": 1,\n    \"skipped\": 0,\n    \"total_duration_ms\": 192,\n    \"operations_rate_limited\": 2,\n    \"total_wait_time_ms\": 99\n  }\n}\n\\`\\`\\`\n\n### Token Bucket Status Example\n\\`\\`\\`json\n{\n  \"command\": \"set-keys\",\n  \"rate_limit\": {\n    \"enabled\": true,\n    \"interval_ms\": 50,\n    \"burst_capacity\": 5\n  },\n  \"operations\": [\n    {\n      \"key\": 0,\n      \"status\": \"success\",\n      \"rate_limit_status\": {\n        \"rate_limited\": false,\n        \"waited_ms\": 0,\n        \"tokens_available\": 4.0\n      }\n    },\n    {\n      \"key\": 5,\n      \"status\": \"success\",\n      \"rate_limit_status\": {\n        \"rate_limited\": true,\n        \"waited_ms\": 42,\n        \"tokens_available\": 0.0\n      }\n    }\n  ]\n}\n\\`\\`\\`\n\n### Integration with Output System\n\\`\\`\\`rust\nimpl RobotOutput {\n    pub fn batch_result(&self, result: &BatchResult, rate_limiter: Option<&dyn RateLimiting>) -> Result<()> {\n        let robot_result = BatchResultRobot {\n            command: \"set-keys\".to_string(),\n            rate_limit: RateLimitInfo {\n                enabled: rate_limiter.is_some(),\n                interval_ms: rate_limiter.map(|r| r.interval_ms()),\n                burst_capacity: rate_limiter.and_then(|r| r.burst_capacity()),\n            },\n            operations: result.operations.iter().map(|op| {\n                OperationResultRobot {\n                    key: op.key,\n                    status: op.status.to_string(),\n                    error: op.error_message(),\n                    rate_limit_status: OperationRateLimitStatus {\n                        rate_limited: op.rate_limited,\n                        waited_ms: op.wait_ms,\n                        tokens_available: op.tokens_available,\n                    },\n                    duration_ms: op.duration_ms,\n                }\n            }).collect(),\n            summary: BatchSummaryRobot {\n                total: result.operations.len(),\n                successful: result.successful_count(),\n                failed: result.failed_count(),\n                skipped: result.skipped_count(),\n                total_duration_ms: result.total_duration_ms,\n                operations_rate_limited: result.rate_limited_count,\n                total_wait_time_ms: result.total_wait_time_ms(),\n            },\n        };\n        \n        println!(\"{}\", serde_json::to_string(&robot_result)?);\n        Ok(())\n    }\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] Rate limit info included in batch results\n- [ ] Per-operation rate limit status reported\n- [ ] Summary includes rate limit statistics\n- [ ] TokenBucket tokens available included when applicable\n- [ ] Output is valid JSON and parseable\n\n## Logging Requirements\n- TRACE: (none - robot mode doesn't log)\n- DEBUG: (none)\n- INFO: (none)\n- WARN: (none)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:21.134002733Z","created_by":"ubuntu","updated_at":"2026-01-19T21:29:46.499672418Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-mwd","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:21.145981728Z","created_by":"ubuntu"}]}
{"id":"bd-ndun","title":"Add FillKeys batch command for filling multiple keys with color","description":"## Purpose\nAdd `sd fill-keys` command to fill multiple keys with a solid color in one operation.\n\n## CLI Definition\n```rust\n#[derive(Parser, Debug)]\npub struct FillKeysCommand {\n    /// Color to fill (hex #RRGGBB, rgb(r,g,b), or named color)\n    #[arg(value_name = \"COLOR\")]\n    pub color: String,\n\n    /// Fill ALL keys on the device\n    #[arg(long, conflicts_with_all = [\"range\", \"keys\"])]\n    pub all: bool,\n\n    /// Range of keys to fill (e.g., \"0-7\" for first row)\n    #[arg(long, short = 'r')]\n    pub range: Option<String>,\n\n    /// Specific key indices to fill (space-separated)\n    #[arg(long, short = 'k')]\n    pub keys: Vec<u8>,\n\n    /// Continue filling other keys if one fails\n    #[arg(long, short = 'c')]\n    pub continue_on_error: bool,\n}\n```\n\n## Usage Examples\n```bash\n# Fill all keys with red\nsd fill-keys \"#FF0000\" --all\n\n# Fill first row with blue\nsd fill-keys \"#0000FF\" --range 0-7\n\n# Fill specific keys with green\nsd fill-keys \"green\" --keys 0 5 10 15\n\n# Fill with RGB notation\nsd fill-keys \"rgb(255,128,0)\" --all\n```\n\n## Robot Mode Output\n```json\n{\n  \"command\": \"fill-keys\",\n  \"color\": \"#FF0000\",\n  \"results\": [\n    {\"key\": 0, \"status\": \"filled\"},\n    {\"key\": 1, \"status\": \"filled\"}\n  ],\n  \"summary\": {\n    \"total\": 32,\n    \"filled\": 32,\n    \"failed\": 0\n  }\n}\n```\n\n## Color Parsing\nSupport multiple color formats:\n- Hex: `#RGB`, `#RRGGBB`\n- RGB: `rgb(255,128,0)`\n- Named: `red`, `green`, `blue`, `black`, `white`\n\n## Logging Requirements\n- TRACE: Each key fill operation\n- DEBUG: Color parsing, range parsing\n- INFO: Operation start/complete with counts\n- WARN: Individual key failures with continue-on-error\n- ERROR: Invalid color format, fatal failures\n\n## Success Criteria\n- [ ] --all fills entire device\n- [ ] --range parses and fills key ranges\n- [ ] Specific keys can be listed\n- [ ] Multiple color formats supported\n- [ ] Robot mode returns per-key status\n- [ ] Human mode shows progress","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T21:21:32.470548223Z","created_by":"ubuntu","updated_at":"2026-01-21T11:07:24.093534200Z","closed_at":"2026-01-21T11:07:24.093488133Z","close_reason":"Implemented sd fill-keys with --all, --range, --keys options, continue-on-error, and robot mode JSON output","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-ndun","depends_on_id":"bd-1ch","type":"blocks","created_at":"2026-01-19T21:53:21.931692340Z","created_by":"ubuntu"},{"issue_id":"bd-ndun","depends_on_id":"bd-1q8","type":"blocks","created_at":"2026-01-19T21:53:27.869690840Z","created_by":"ubuntu"},{"issue_id":"bd-ndun","depends_on_id":"bd-3ju","type":"parent-child","created_at":"2026-01-19T21:21:32.498873205Z","created_by":"ubuntu"}]}
{"id":"bd-oqp","title":"Implement long-press detection","description":"Long press = released after threshold:\n1. Track press start time\n2. On release, check duration\n3. If >= threshold → LongPress\n4. If < threshold → potential Tap\n\nDistinct from Hold (still pressed).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:01.058745696Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:01.069535210Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-oqp","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:01.069490276Z","created_by":"ubuntu"}]}
{"id":"bd-p9h","title":"Implement tap/double-tap detection with deferral","description":"Tap detection requires deferral:\n1. On release, record potential tap time\n2. Start timer for double-tap window\n3. If another press within window → DoubleTap\n4. If window expires → emit deferred Tap\n\nThis prevents emitting Tap before DoubleTap is ruled out.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:00.663327449Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:00.673778296Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-p9h","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:00.673732490Z","created_by":"ubuntu"}]}
{"id":"bd-pls","title":"Implement command template substitution","description":"Replace placeholders in command strings:\n- {key} → key index (e.g., \"5\")\n- {pressed} → \"true\" or \"false\"\n- {timestamp} → ISO timestamp\n\nUse simple string replacement, not shell interpolation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:18.638071617Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:18.652607365Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-pls","depends_on_id":"bd-156","type":"parent-child","created_at":"2026-01-19T18:26:18.652559995Z","created_by":"ubuntu"}]}
{"id":"bd-pnk","title":"Add rich_rust dependency to Cargo.toml","description":"# Add rich_rust dependency to Cargo.toml\n\n## Purpose\nAdd the rich_rust crate as a dependency, which provides all the terminal formatting capabilities needed for beautiful human-mode output.\n\n## Background\nrich_rust is located at /dp/rich_rust and provides:\n- Console: Central coordinator for terminal output\n- Style/Color: Text styling with automatic capability detection\n- Table: Auto-sizing tables with headers and borders\n- Panel: Boxed content with titles\n- ProgressBar: Visual progress indicators\n- Rule: Horizontal dividers\n- Markup parsing: [bold red]text[/] syntax\n\n## Technical Details\n\n### Dependency Specification\n```toml\n[dependencies]\nrich_rust = { path = \"/dp/rich_rust\", features = [\"json\"] }\n```\n\nNote: Using path dependency for local development. When rich_rust is published to crates.io, this should change to:\n```toml\nrich_rust = { version = \"0.1\", features = [\"json\"] }\n```\n\n### Feature Selection\n- json: Enables JSON pretty-printing (useful for displaying device info)\n- NOT including: syntax, markdown (not needed for this CLI)\n\n### What NOT to Remove (Yet)\nKeep the colored crate temporarily during migration. It will be removed in a later task (bd-XXX) after all output has been migrated.\n\n## Implementation Steps\n1. Open Cargo.toml\n2. Add rich_rust dependency in [dependencies] section\n3. Run cargo check to verify resolution\n4. Run cargo build to ensure compilation\n\n## Verification\n```bash\ncargo check --all-targets\ncargo clippy --all-targets -- -D warnings\n```\n\n## Considerations\n- Path dependency works for local dev but needs version for publishing\n- The json feature adds serde_json (already a dependency, so no bloat)\n- rich_rust itself has minimal dependencies (crossterm, unicode-width, etc.)\n\n## Acceptance Criteria\n- [ ] Cargo.toml contains rich_rust dependency\n- [ ] cargo check passes\n- [ ] cargo build succeeds\n- [ ] use rich_rust::prelude::* compiles in any source file","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:30.486547563Z","created_by":"ubuntu","updated_at":"2026-01-19T21:02:30.520014755Z","compaction_level":0,"original_size":0,"labels":["cargo","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-pnk","depends_on_id":"bd-1vw","type":"parent-child","created_at":"2026-01-19T21:02:30.519969480Z","created_by":"ubuntu"}]}
{"id":"bd-qch","title":"Handle edge cases (delete, rename)","description":"Handle file operations:\n- File deleted: warn and continue watching (may reappear)\n- File renamed: re-watch new path?\n- Directory deleted: error and exit\n\nDecide on behavior and document.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:27:36.265137410Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:36.276036341Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qch","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:36.275979654Z","created_by":"ubuntu"}]}
{"id":"bd-qf8","title":"Audit existing src/config/ code and identify gaps","description":"Review existing infrastructure:\n- src/config/loader.rs: ZIP extraction capabilities\n- src/config/db.rs: SQLite schema and operations\n- src/config/types.rs: Profile, Key, Action types\n\nDocument what exists vs what needs implementation.\nThis is RESEARCH - produces a gap analysis document.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:29.966270817Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:29.994810562Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qf8","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:29.994765116Z","created_by":"ubuntu"}]}
{"id":"bd-qvw","title":"Write tests for gesture edge cases","description":"## Test Coverage for Gesture Detection\n\n### Unit Tests - Tap Detection\n\n1. **Single Tap Tests**\n   - Press + quick release (< 200ms) = tap\n   - Tap fires after release, not on press\n   - Multiple taps on same key distinguished\n   - Tap on different key during wait = two taps\n\n2. **Double-Tap Tests**\n   - Two taps within 300ms = double-tap\n   - Two taps > 300ms apart = two single taps\n   - Triple tap = double-tap + single tap\n   - Double-tap fires only after timeout (no third tap coming)\n   - Exact boundary: 299ms = double, 301ms = two singles\n\n3. **Tap Deferral Tests**\n   - First tap doesn't fire immediately (waiting for double)\n   - If double-tap detected, first tap cancelled\n   - If timeout expires, deferred tap fires\n   - Deferral timeout configurable\n\n### Unit Tests - Long Press Detection\n\n4. **Long Press Threshold Tests**\n   - Hold < 500ms = tap (not long press)\n   - Hold >= 500ms = long press\n   - Exact boundary: 499ms = tap, 500ms = long press\n   - Threshold configurable via --long-press-ms\n\n5. **Hold Duration Tests**\n   - Hold start event at threshold\n   - Hold tick events every 100ms (configurable)\n   - Hold end event on release\n   - Total hold duration reported accurately\n\n6. **Long Press Cancellation**\n   - Moving to different key cancels\n   - (Not applicable for physical buttons)\n\n### Unit Tests - State Machine\n\n7. **State Transitions**\n   - Idle → Pressed on press\n   - Pressed → Held after threshold\n   - Pressed → Released on quick release\n   - Held → Released on release\n   - Released → Idle after timeout\n\n8. **Event Emission Order**\n   - Events in correct order for each gesture\n   - No duplicate events\n   - No missing events\n   - Timestamps accurate\n\n### Integration Tests (require MockDevice)\n\n1. **Simultaneous Keys**\n   - Press key 0, then key 1 while 0 held\n   - Both gestures tracked independently\n   - Release order doesn't matter\n   - No state corruption\n\n2. **Rapid Sequences**\n   - 10 taps in 1 second on same key\n   - All detected correctly\n   - Performance doesn't degrade\n   - No events lost\n\n3. **Gesture + Hook Integration**\n   - Long press triggers hook\n   - Double-tap triggers different hook\n   - Tap triggers tap hook\n   - All hooks fire correctly\n\n4. **Watch Mode Stress Test**\n   - Many rapid gestures\n   - Memory stable\n   - CPU reasonable\n   - All events reported\n\n### E2E Tests (require E2E harness)\n\n1. **CLI Gesture Configuration**\n   ```bash\n   sd watch --long-press-ms 500 --double-tap-ms 300\n   ```\n   - Verify thresholds respected\n   - Verify events in output\n\n2. **Keymap Gesture Hooks**\n   ```yaml\n   keys:\n     0:\n       tap: \"echo tap\"\n       double_tap: \"echo double\"\n       long_press: \"echo long\"\n       hold_tick: \"echo holding\"\n   ```\n   - All gesture types trigger correct hook\n\n3. **Robot Mode Events**\n   ```json\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"tap\"}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"long_press_start\"}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"hold_tick\", \"duration_ms\": 600}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"long_press_end\", \"duration_ms\": 1500}\n   {\"event\": \"gesture\", \"key\": 0, \"type\": \"double_tap\"}\n   ```\n\n### Edge Case Tests\n\n1. **Boundary Conditions**\n   - Press duration exactly at threshold\n   - Tap interval exactly at double-tap threshold\n   - Zero-duration press (immediate release)\n   - Very long press (> 30 seconds)\n\n2. **Clock Skew**\n   - System time changes during hold\n   - Monotonic clock used (unaffected)\n\n3. **Device Disconnection**\n   - Disconnect during held state\n   - Reconnect clears gesture state\n   - No orphaned events\n\n### Test Fixtures (tests/fixtures/gestures/)\n\n```\ngestures/\n├── gesture-keymap.yaml    # All gesture types mapped\n├── tap-only.yaml          # Only tap hooks\n├── timing-test.yaml       # Tight timing thresholds\n└── stress-test.yaml       # Many keys, many hooks\n```\n\n### Performance Requirements\n- Gesture detection latency < 5ms\n- State machine handles 100 events/second\n- Memory per tracked key < 100 bytes","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:03.175268351Z","created_by":"ubuntu","updated_at":"2026-01-19T20:43:58.136516085Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-qvw","depends_on_id":"bd-180","type":"blocks","created_at":"2026-01-19T18:39:00.339019776Z","created_by":"ubuntu"},{"issue_id":"bd-qvw","depends_on_id":"bd-1v8","type":"parent-child","created_at":"2026-01-19T18:28:03.185587339Z","created_by":"ubuntu"}]}
{"id":"bd-rfp","title":"Add --retry and --retry-delay CLI flags","description":"## Purpose\nAdd global CLI flags for retry configuration, applying to all commands that open a device.\n\n## Implementation\n\n### CLI Changes\n```rust\n// src/main.rs - Add to GlobalOpts struct\n#[derive(Debug, Clone, Parser)]\npub struct GlobalOpts {\n    /// Retry N times on connection failure (default: 0 = no retry)\n    #[arg(long, global = true, default_value = \"0\")]\n    pub retry: u32,\n    \n    /// Initial delay between retries in milliseconds (default: 1000)\n    #[arg(long, global = true, default_value = \"1000\")]\n    pub retry_delay: u64,\n    \n    /// Maximum delay cap for exponential backoff in milliseconds (default: 10000)\n    #[arg(long, global = true, default_value = \"10000\")]\n    pub retry_max_delay: u64,\n    \n    /// Backoff multiplier for retry delay (default: 1.5)\n    #[arg(long, global = true, default_value = \"1.5\")]\n    pub retry_backoff: f32,\n    \n    // ... existing fields ...\n}\n```\n\n### ConnectionOptions Builder\n```rust\nimpl GlobalOpts {\n    /// Build ConnectionOptions from CLI flags\n    pub fn connection_options(&self) -> ConnectionOptions {\n        if self.retry == 0 {\n            ConnectionOptions {\n                max_retries: 1,  // Single attempt, no retry\n                retry_delay: Duration::from_millis(0),\n                backoff_factor: 1.0,\n                max_delay: Duration::from_millis(0),\n            }\n        } else {\n            ConnectionOptions {\n                max_retries: self.retry,\n                retry_delay: Duration::from_millis(self.retry_delay),\n                backoff_factor: self.retry_backoff,\n                max_delay: Duration::from_millis(self.retry_max_delay),\n            }\n        }\n    }\n}\n```\n\n### Robot Mode Output\nWhen retry is enabled, emit events:\n```json\n{\"event\":\"connection_attempt\",\"attempt\":1,\"max_attempts\":3,\"timestamp\":\"...\"}\n{\"event\":\"connection_retry\",\"attempt\":1,\"delay_ms\":1000,\"error\":\"Device not found\",\"timestamp\":\"...\"}\n{\"event\":\"connection_attempt\",\"attempt\":2,\"max_attempts\":3,\"timestamp\":\"...\"}\n{\"event\":\"connected\",\"attempt\":2,\"device\":{...},\"timestamp\":\"...\"}\n```\n\n## CLI Help Text\n```\n--retry <N>           Retry N times on connection failure (default: 0)\n--retry-delay <MS>    Initial delay between retries in milliseconds (default: 1000)\n--retry-max-delay <MS> Maximum delay cap for backoff in milliseconds (default: 10000)\n--retry-backoff <F>   Backoff multiplier for retry delay (default: 1.5)\n```\n\n## Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_retry_disabled_by_default() {\n        let opts: GlobalOpts = GlobalOpts::parse_from([\"sd\", \"info\"]);\n        assert_eq!(opts.retry, 0);\n    }\n    \n    #[test]\n    fn test_connection_options_no_retry() {\n        let opts = GlobalOpts { retry: 0, ..Default::default() };\n        let conn = opts.connection_options();\n        assert_eq!(conn.max_retries, 1);\n    }\n    \n    #[test]\n    fn test_connection_options_with_retry() {\n        let opts = GlobalOpts {\n            retry: 5,\n            retry_delay: 500,\n            retry_max_delay: 5000,\n            retry_backoff: 2.0,\n            ..Default::default()\n        };\n        let conn = opts.connection_options();\n        assert_eq!(conn.max_retries, 5);\n        assert_eq!(conn.retry_delay, Duration::from_millis(500));\n        assert_eq!(conn.max_delay, Duration::from_millis(5000));\n        assert_eq!(conn.backoff_factor, 2.0);\n    }\n    \n    #[test]\n    fn test_cli_parsing() {\n        let opts = GlobalOpts::parse_from([\n            \"sd\", \"--retry\", \"3\", \"--retry-delay\", \"2000\", \"info\"\n        ]);\n        assert_eq!(opts.retry, 3);\n        assert_eq!(opts.retry_delay, 2000);\n    }\n}\n```\n\n## Logging Requirements\n- DEBUG: Parsed retry options\n- INFO: When retry is enabled with settings\n\n## Success Criteria\n- [ ] --retry flag accepts 0-N\n- [ ] --retry-delay sets initial delay in ms\n- [ ] --retry-max-delay caps exponential backoff\n- [ ] --retry-backoff sets multiplier\n- [ ] Default is no retry (fail fast)\n- [ ] ConnectionOptions built correctly\n- [ ] Robot mode emits retry events","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T18:24:25.030520980Z","created_by":"ubuntu","updated_at":"2026-01-21T11:03:03.180426201Z","closed_at":"2026-01-21T11:03:03.180363593Z","close_reason":"Implemented --retry, --retry-delay, --retry-max-delay, --retry-backoff global CLI flags with helper open_device() function in main.rs","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-rfp","depends_on_id":"bd-1os","type":"blocks","created_at":"2026-01-19T21:52:58.781543540Z","created_by":"ubuntu"},{"issue_id":"bd-rfp","depends_on_id":"bd-ylj","type":"parent-child","created_at":"2026-01-19T18:24:25.045697124Z","created_by":"ubuntu"}]}
{"id":"bd-s04","title":"EPIC: Elgato Profile Import","description":"## Overview\n**Rank: #6 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nComplete the `sd init --import <file.streamDeckProfile>` command to load official Elgato Stream Deck profiles.\n\n## Problem Statement\nUsers with existing Stream Deck setups have invested significant time configuring their devices through the official Elgato software. To migrate to this CLI, they currently must:\n- Manually recreate every key configuration\n- Re-source and re-apply all images\n- Lose any complex configurations (folders, multi-actions)\n\nThis is a huge barrier to adoption. Users wont switch if it means starting from scratch.\n\n## Solution\nImport official Elgato profile files:\n```bash\n# Import an exported profile\nsd init --import ~/Downloads/MySetup.streamDeckProfile\n\n# The profile is a ZIP containing:\n# - manifest.json (profile metadata)\n# - Profiles/<uuid>/profile.json (key configurations)\n# - Images/<uuid>.png (key images)\n\n# After import, users can:\nsd config show        # See imported configuration\nsd apply default      # Apply the imported profile\n```\n\n## Why This Is #6 Priority\n1. **Infrastructure already built**: `src/config/` has ZIP loader, SQLite schema, profile parser!\n2. **Adoption enabler**: Users can migrate without losing their existing setup\n3. **Competitive advantage**: No other open-source tool does this well\n4. **Trust builder**: Shows we respect users existing investment\n\n## Existing Infrastructure in src/config/\n\nThe `src/config/` module already contains substantial infrastructure:\n\n```\nsrc/config/\n├── mod.rs       # Module exports\n├── loader.rs    # ZIP file extraction and parsing\n├── db.rs        # SQLite schema and operations\n└── types.rs     # Profile, Key, Action type definitions\n```\n\nKey existing code:\n- `ProfileLoader::from_zip()` - Opens and validates profile ZIP\n- `ProfileLoader::extract_to()` - Extracts to temp directory\n- `Profile`, `Key`, `Action` structs defined\n- SQLite schema for storing profiles\n\nWhat needs to be done:\n- Wire loader to CLI commands\n- Implement the `init` and `config` commands\n- Handle the mapping from Elgato action types to our commands\n- Store and retrieve images from the extracted profile\n\n## Elgato Profile Format Analysis\n\nThe `.streamDeckProfile` file is a ZIP archive:\n```\nMySetup.streamDeckProfile (ZIP)\n├── manifest.json\n│   {\n│     \"Version\": \"1.0\",\n│     \"DeviceUUID\": \"...\",\n│     \"DeviceModel\": \"StreamDeckXL\"\n│   }\n├── Profiles/\n│   └── <uuid>/\n│       └── profile.json\n│           {\n│             \"Controller\": \"Encoder\",\n│             \"Name\": \"Default Profile\",\n│             \"Keys\": [\n│               {\n│                 \"UUID\": \"...\",\n│                 \"Title\": \"Chrome\",\n│                 \"Image\": \"Images/abc123.png\",\n│                 \"Actions\": [...]\n│               }\n│             ]\n│           }\n└── Images/\n    ├── abc123.png\n    └── def456.png\n```\n\n## Implementation Approach\n\n### Phase 1: Complete the Init Command\n```rust\n// In src/cli/mod.rs\nInit {\n    /// Import from Elgato profile file\n    #[arg(long)]\n    import: Option<PathBuf>,\n    \n    /// Profile name (default: \"default\")\n    #[arg(long, default_value = \"default\")]\n    name: String,\n}\n\n// In main.rs\nfn cmd_init(import: Option<&Path>, name: &str) -> Result<()> {\n    if let Some(profile_path) = import {\n        let loader = ProfileLoader::from_zip(profile_path)?;\n        let profile = loader.parse()?;\n        \n        // Store in config database\n        let config_dir = config_dir()?;\n        let db = ConfigDb::open(&config_dir)?;\n        db.import_profile(name, &profile)?;\n        \n        // Copy images to config storage\n        for key in &profile.keys {\n            if let Some(image_path) = &key.image {\n                copy_image_to_storage(&config_dir, image_path)?;\n            }\n        }\n        \n        println!(\"Imported profile \\\"{}\\\" with {} keys\", name, profile.keys.len());\n    } else {\n        // Interactive setup\n        println!(\"Interactive setup not yet implemented\");\n    }\n    Ok(())\n}\n```\n\n### Phase 2: Config Show/Apply Commands\n```rust\n// Show imported configuration\nfn cmd_config_show(name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        println!(\"Key {}: {} ({})\", key.index, key.title, key.image_source());\n    }\n    Ok(())\n}\n\n// Apply configuration to device\nfn cmd_apply(device: &Device, name: &str) -> Result<()> {\n    let db = ConfigDb::open(&config_dir()?)?;\n    let profile = db.get_profile(name)?;\n    \n    for key in &profile.keys {\n        if let Some(image_path) = key.resolved_image_path() {\n            set_key_image(device, key.index, &image_path)?;\n        }\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Leverage existing code**: Dont rewrite what exists in src/config/\n2. **Named profiles**: Store multiple profiles, apply by name\n3. **Image copying**: Copy images to our storage for portability\n4. **Graceful degradation**: Handle unsupported Elgato features gracefully\n5. **Forward compatibility**: Design for future Elgato format versions\n\n## Elgato Feature Mapping\n| Elgato Feature | Our Support |\n|----------------|-------------|\n| Static images | Full |\n| Solid colors | Full |\n| System actions | Partial (map to shell commands) |\n| Folders | Not yet (track as nested profiles) |\n| Multi-actions | Not yet (future scripting feature) |\n| Animated GIFs | Not yet |\n\n## Success Criteria\n- [ ] `sd init --import <file>` loads Elgato profile\n- [ ] Imported images stored in config directory\n- [ ] `sd config show` displays imported configuration\n- [ ] `sd apply <name>` applies profile to device\n- [ ] Unsupported features logged with warnings\n- [ ] Robot mode returns import summary JSON\n\n## Files to Modify/Create\n- `src/cli/mod.rs`: Add Init, Config, Apply commands\n- `src/main.rs`: Implement command handlers\n- `src/config/loader.rs`: Complete extraction logic\n- `src/config/db.rs`: Complete storage operations\n\n## Dependencies\n- Soft: Benefits from BATCH-OPS for applying multiple keys efficiently\n\n## Estimated Subtasks\n1. Audit existing src/config/ code and identify gaps\n2. Complete ProfileLoader extraction logic\n3. Implement init --import command\n4. Implement config show command\n5. Implement config list command\n6. Implement apply command\n7. Handle image copying and storage\n8. Add support for unsupported feature warnings\n9. Write tests with sample profile files","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-19T18:12:05.904911952Z","created_by":"ubuntu","updated_at":"2026-01-19T18:12:05.948021860Z","compaction_level":0,"original_size":0,"labels":["config","interoperability","migration","priority-6"]}
{"id":"bd-txy","title":"Add sha2 dependency to Cargo.toml","description":"Add:\n```toml\n[dependencies]\nsha2 = \"0.10\"\n```\n\nUsed for content-addressable cache keys.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:26:38.179210261Z","created_by":"ubuntu","updated_at":"2026-01-19T18:26:38.189556802Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-txy","depends_on_id":"bd-3p6","type":"parent-child","created_at":"2026-01-19T18:26:38.189514442Z","created_by":"ubuntu"}]}
{"id":"bd-uau","title":"Implement config show command","description":"Implement sd config show [name]:\n- Display profile metadata (name, device type, key count)\n- List all key configurations\n- Show image sources and action types\n- Robot mode: Full JSON of profile\n- Human mode: Formatted table","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-19T18:25:30.642852300Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:30.652578512Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-uau","depends_on_id":"bd-s04","type":"parent-child","created_at":"2026-01-19T18:25:30.652525282Z","created_by":"ubuntu"}]}
{"id":"bd-usa2","title":"Implement human mode visual tests","description":"# Implement human mode visual tests\n\n## Purpose\nCreate tests that verify human mode output contains expected visual elements. Since we cannot easily test exact visual appearance, we verify that key elements (text, symbols, structure) are present and that the output adapts correctly to various conditions.\n\n## Test Strategy\n\n### Approach: Content Verification\nTest that output contains expected elements:\n- Text content (device names, serials, etc.)\n- Visual symbols (✓, ✗, ●, ○, ⚠, ℹ)\n- Panel borders (box-drawing characters)\n- Styled text (via presence of ANSI codes)\n- Correct layout adaptation to terminal width\n\n### Using rich_rust Console Capture\nrich_rust Console has built-in capture functionality:\nlet console = Console::builder()\n    .force_terminal(true)\n    .width(80)\n    .build();\n\nconsole.begin_capture();\n// ... output operations ...\nlet captured = console.end_capture();\n\n## Test Implementation\n\n### Test Module (tests/unit/human_output.rs)\nuse sd::output::{HumanOutput, Output};\nuse sd::device::{DeviceInfo, ButtonEvent};\nuse sd::error::SdError;\nuse sd::theme::SdTheme;\nuse rich_rust::prelude::*;\nuse crate::common::*;\nuse tracing::{info, debug, instrument};\nuse std::path::Path;\n\nfn setup() {\n    init_test_logging();\n}\n\n/// Helper to create HumanOutput with capture\nfn output_with_capture<F>(f: F) -> String \nwhere\n    F: FnOnce(&HumanOutput)\n{\n    let console = test_console();\n    console.begin_capture();\n    \n    let output = HumanOutput::new(console.clone());\n    f(&output);\n    \n    console.end_capture()\n}\n\n// === Device List Tests ===\n\n#[test]\n#[instrument]\nfn human_device_list_shows_panel() {\n    setup();\n    info!(\"Testing device list panel\");\n    \n    let captured = output_with_capture(|output| {\n        output.device_list(&[mock_device_xl()]);\n    });\n    \n    debug!(output = %captured, \"Captured device list\");\n    \n    // Should contain panel border characters\n    assert_has_box_chars(&captured);\n    \n    // Should contain title\n    assert!(captured.contains(\"Stream Deck\") || captured.contains(\"Device\"),\n        \"Panel should have a title\");\n    \n    // Should contain device info\n    assert!(captured.contains(\"Stream Deck XL\"), \"Should show device name\");\n    assert!(captured.contains(\"AL12XL0001\"), \"Should show serial\");\n    \n    info!(\"✓ Device list panel validated\");\n}\n\n#[test]\n#[instrument]\nfn human_device_list_empty_shows_warning() {\n    setup();\n    info!(\"Testing empty device list\");\n    \n    let captured = output_with_capture(|output| {\n        output.device_list(&[]);\n    });\n    \n    debug!(output = %captured, \"Empty list output\");\n    \n    assert!(captured.contains(\"No device\") || captured.contains(\"no device\") ||\n            captured.contains(\"not found\"),\n        \"Should indicate no devices\");\n    \n    // Should have helpful suggestion\n    assert!(captured.contains(\"connect\") || captured.contains(\"USB\") ||\n            captured.contains(\"Ensure\"),\n        \"Should suggest checking connection\");\n    \n    info!(\"✓ Empty device list validated\");\n}\n\n#[test]\n#[instrument]\nfn human_device_list_multiple() {\n    setup();\n    info!(\"Testing multiple devices list\");\n    \n    let devices = mock_multiple_devices();\n    \n    let captured = output_with_capture(|output| {\n        output.device_list(&devices);\n    });\n    \n    // All device names should appear\n    assert!(captured.contains(\"Stream Deck XL\"));\n    assert!(captured.contains(\"Stream Deck Mini\"));\n    \n    // Should have numbering or clear separation\n    let has_numbering = captured.contains(\"1.\") || captured.contains(\"1)\");\n    let has_separation = captured.contains(\"───\") || captured.contains(\"\\n\\n\");\n    assert!(has_numbering || has_separation,\n        \"Multiple devices should be numbered or separated\");\n    \n    info!(\"✓ Multiple devices list validated\");\n}\n\n// === Device Info Tests ===\n\n#[test]\n#[instrument]\nfn human_device_info_shows_table() {\n    setup();\n    info!(\"Testing device info display\");\n    \n    let captured = output_with_capture(|output| {\n        output.device_info(&mock_device_xl());\n    });\n    \n    debug!(output = %captured, \"Device info output\");\n    \n    // Should show all key information\n    assert_contains_all(&captured, &[\n        \"Stream Deck XL\",\n        \"AL12XL0001\",  // Serial\n        \"32\",          // Key count\n        \"1.5.3\",       // Firmware\n    ]);\n    \n    // Should have visual structure (box or table)\n    assert_has_box_chars(&captured);\n    \n    info!(\"✓ Device info validated\");\n}\n\n#[test]\n#[instrument]\nfn human_device_info_shows_key_layout() {\n    setup();\n    info!(\"Testing key layout in device info\");\n    \n    let captured = output_with_capture(|output| {\n        output.device_info(&mock_device_xl());\n    });\n    \n    // For Stream Deck XL (8x4), should show dimensions\n    assert!(captured.contains(\"8\") && captured.contains(\"4\") ||\n            captured.contains(\"32\"),\n        \"Should show key layout dimensions\");\n    \n    info!(\"✓ Key layout validated\");\n}\n\n// === Error Output Tests ===\n\n#[test]\n#[instrument]\nfn human_error_shows_panel_with_icon() {\n    setup();\n    info!(\"Testing error display\");\n    \n    let captured = output_with_capture(|output| {\n        output.error(&SdError::NoDevicesFound);\n    });\n    \n    debug!(output = %captured, \"Error output\");\n    \n    // Error icon\n    assert!(captured.contains('✗') || captured.contains(\"Error\") || \n            captured.contains(\"error\"),\n        \"Should show error indicator\");\n    \n    // Panel border\n    assert_has_box_chars(&captured);\n    \n    // Should have ANSI styling\n    assert_has_ansi(&captured);\n    \n    info!(\"✓ Error display validated\");\n}\n\n#[test]\n#[instrument]\nfn human_error_shows_suggestion() {\n    setup();\n    info!(\"Testing error suggestion\");\n    \n    let captured = output_with_capture(|output| {\n        output.error(&SdError::NoDevicesFound);\n    });\n    \n    // Recoverable errors should show suggestion\n    assert!(captured.contains(\"Suggestion\") || captured.contains(\"suggestion\") ||\n            captured.contains(\"Try\") || captured.contains(\"connect\"),\n        \"Recoverable errors should show suggestion\");\n    \n    info!(\"✓ Error suggestion validated\");\n}\n\n#[test]\n#[instrument]\nfn human_error_multiple_devices_lists_serials() {\n    setup();\n    info!(\"Testing multiple devices error\");\n    \n    let captured = output_with_capture(|output| {\n        output.error(&SdError::MultipleDevices {\n            serials: vec![\"AAA\".into(), \"BBB\".into()],\n        });\n    });\n    \n    // Should list available serials\n    assert!(captured.contains(\"AAA\"), \"Should show first serial\");\n    assert!(captured.contains(\"BBB\"), \"Should show second serial\");\n    assert!(captured.contains(\"--serial\") || captured.contains(\"-s\"),\n        \"Should suggest using --serial flag\");\n    \n    info!(\"✓ Multiple devices error validated\");\n}\n\n// === Button Event Tests ===\n\n#[test]\n#[instrument]\nfn human_button_pressed_shows_filled_circle() {\n    setup();\n    info!(\"Testing button press display\");\n    \n    let captured = output_with_capture(|output| {\n        output.button_event(&mock_button_press(5));\n    });\n    \n    debug!(output = %captured, \"Button press output\");\n    \n    // Filled circle for press\n    assert!(captured.contains('●') || captured.contains(\"pressed\"),\n        \"Should indicate button press\");\n    \n    // Key number\n    assert!(captured.contains(\"5\") || captured.contains(\"Key 5\"),\n        \"Should show key number\");\n    \n    info!(\"✓ Button press display validated\");\n}\n\n#[test]\n#[instrument]\nfn human_button_released_shows_empty_circle() {\n    setup();\n    info!(\"Testing button release display\");\n    \n    let captured = output_with_capture(|output| {\n        output.button_event(&mock_button_release(5));\n    });\n    \n    // Empty circle for release\n    assert!(captured.contains('○') || captured.contains(\"released\"),\n        \"Should indicate button release\");\n    \n    info!(\"✓ Button release display validated\");\n}\n\n#[test]\n#[instrument]\nfn human_button_event_timestamp() {\n    setup();\n    info!(\"Testing button event timestamp\");\n    \n    let captured = output_with_capture(|output| {\n        output.button_event(&mock_button_press(0));\n    });\n    \n    // Should show some form of timestamp or time indicator\n    // Could be relative time, HH:MM:SS, or ms\n    let has_time = captured.contains(':') || captured.contains(\"ms\") ||\n                   captured.contains(\"ago\");\n    // Time display is optional but good to have\n    debug!(has_time, \"Timestamp present\");\n    \n    info!(\"✓ Button event timestamp checked\");\n}\n\n// === Watch Command Streaming Tests ===\n\n#[test]\n#[instrument]\nfn human_watch_header() {\n    setup();\n    info!(\"Testing watch command header\");\n    \n    let captured = output_with_capture(|output| {\n        output.rule(Some(\"Watching for button events\"));\n    });\n    \n    assert!(captured.contains(\"Watch\") || captured.contains(\"button\") ||\n            captured.contains(\"events\"),\n        \"Watch header should describe what's happening\");\n    \n    // Should have visual separator\n    assert!(captured.contains('─') || captured.contains('-'),\n        \"Rule should have horizontal line\");\n    \n    info!(\"✓ Watch header validated\");\n}\n\n#[test]\n#[instrument]\nfn human_button_events_streaming() {\n    setup();\n    info!(\"Testing streaming button events\");\n    \n    // Simulate multiple events in sequence\n    let console = test_console();\n    console.begin_capture();\n    let output = HumanOutput::new(console.clone());\n    \n    // Multiple events\n    output.button_event(&mock_button_press(0));\n    output.button_event(&mock_button_release(0));\n    output.button_event(&mock_button_press(5));\n    output.button_event(&mock_button_press(10));\n    output.button_event(&mock_button_release(5));\n    \n    let captured = console.end_capture();\n    \n    // Should show all events\n    let lines: Vec<_> = captured.lines().filter(|l| !l.is_empty()).collect();\n    assert!(lines.len() >= 5, \"Should have at least 5 event lines\");\n    \n    // Events should be distinguishable\n    let press_count = captured.matches('●').count();\n    let release_count = captured.matches('○').count();\n    assert_eq!(press_count, 3, \"Should have 3 press events\");\n    assert_eq!(release_count, 2, \"Should have 2 release events\");\n    \n    info!(\"✓ Streaming events validated\");\n}\n\n// === Key Operation Tests ===\n\n#[test]\n#[instrument]\nfn human_key_set_shows_checkmark() {\n    setup();\n    info!(\"Testing key set confirmation\");\n    \n    let captured = output_with_capture(|output| {\n        output.key_set(5, Path::new(\"/path/to/icon.png\"));\n    });\n    \n    // Success indicator\n    assert!(captured.contains('✓') || captured.contains(\"Set\") ||\n            captured.contains(\"success\"),\n        \"Should show success indicator\");\n    \n    // Key and image info\n    assert!(captured.contains(\"5\") || captured.contains(\"Key 5\"));\n    assert!(captured.contains(\"icon.png\"), \"Should show image filename\");\n    \n    info!(\"✓ Key set confirmation validated\");\n}\n\n#[test]\n#[instrument]\nfn human_brightness_shows_progress_bar() {\n    setup();\n    info!(\"Testing brightness display\");\n    \n    let captured = output_with_capture(|output| {\n        output.brightness_set(75);\n    });\n    \n    debug!(output = %captured, \"Brightness output\");\n    \n    // Should show percentage\n    assert!(captured.contains(\"75\") || captured.contains(\"75%\"),\n        \"Should show brightness value\");\n    \n    // May contain progress bar characters (█, ▓, ░, etc.)\n    // This is optional but preferred\n    let has_progress = captured.contains('█') || captured.contains('▓') ||\n                       captured.contains('░') || captured.contains('=');\n    debug!(has_progress, \"Progress bar present\");\n    \n    info!(\"✓ Brightness display validated\");\n}\n\n// === Version Info Tests ===\n\n#[test]\n#[instrument]\nfn human_version_shows_panel() {\n    setup();\n    info!(\"Testing version info panel\");\n    \n    let captured = output_with_capture(|output| {\n        output.version_info(\"0.1.0\", Some(\"abc1234\"), Some(\"2026-01-01\"));\n    });\n    \n    // Version number\n    assert!(captured.contains(\"0.1.0\"), \"Should show version\");\n    \n    // Git SHA (short form)\n    assert!(captured.contains(\"abc1234\"), \"Should show git sha\");\n    \n    // Build date\n    assert!(captured.contains(\"2026\") || captured.contains(\"01-01\"),\n        \"Should show build time\");\n    \n    // Should be in a panel\n    assert_has_box_chars(&captured);\n    \n    info!(\"✓ Version info validated\");\n}\n\n// === ANSI Code Presence Tests ===\n\n#[test]\n#[instrument]\nfn human_output_contains_ansi_codes() {\n    setup();\n    info!(\"Testing human mode has ANSI codes\");\n    \n    let captured = output_with_capture(|output| {\n        output.success(\"Test message\");\n    });\n    \n    assert_has_ansi(&captured);\n    \n    info!(\"✓ ANSI codes present\");\n}\n\n// === Rule Tests ===\n\n#[test]\n#[instrument]\nfn human_rule_with_title() {\n    setup();\n    info!(\"Testing rule with title\");\n    \n    let captured = output_with_capture(|output| {\n        output.rule(Some(\"Section Title\"));\n    });\n    \n    assert!(captured.contains(\"Section Title\"), \"Should show title\");\n    assert!(captured.contains('─') || captured.contains('-'),\n        \"Should have horizontal line\");\n    \n    info!(\"✓ Rule with title validated\");\n}\n\n#[test]\n#[instrument]\nfn human_rule_without_title() {\n    setup();\n    info!(\"Testing rule without title\");\n    \n    let captured = output_with_capture(|output| {\n        output.rule(None);\n    });\n    \n    // Should just be a line\n    assert!(captured.contains('─') || captured.contains('-'),\n        \"Rule should have horizontal line\");\n    \n    info!(\"✓ Rule without title validated\");\n}\n\n// === Width Adaptation Tests ===\n\n#[test]\n#[instrument]\nfn human_output_narrow_terminal() {\n    setup();\n    info!(\"Testing narrow terminal adaptation\");\n    \n    let console = Console::builder()\n        .width(40)  // Narrow terminal\n        .force_terminal(true)\n        .color_system(ColorSystem::TrueColor)\n        .build();\n    \n    console.begin_capture();\n    let output = HumanOutput::new(console.clone());\n    output.device_list(&[mock_device_xl()]);\n    let captured = console.end_capture();\n    \n    // Content should still be present\n    assert!(captured.contains(\"Stream Deck XL\"));\n    \n    // Lines should not exceed width (approximately)\n    for line in captured.lines() {\n        let visible_len = strip_ansi(line).chars().count();\n        assert!(visible_len <= 45, // Allow some tolerance\n            \"Line too long for 40-char terminal: {} chars\", visible_len);\n    }\n    \n    info!(\"✓ Narrow terminal adaptation validated\");\n}\n\n#[test]\n#[instrument]\nfn human_output_wide_terminal() {\n    setup();\n    info!(\"Testing wide terminal\");\n    \n    let console = Console::builder()\n        .width(120)  // Wide terminal\n        .force_terminal(true)\n        .color_system(ColorSystem::TrueColor)\n        .build();\n    \n    console.begin_capture();\n    let output = HumanOutput::new(console.clone());\n    output.device_list(&[mock_device_xl()]);\n    let captured = console.end_capture();\n    \n    // Content should still be present and properly formatted\n    assert!(captured.contains(\"Stream Deck XL\"));\n    assert_has_box_chars(&captured);\n    \n    info!(\"✓ Wide terminal validated\");\n}\n\n/// Helper to strip ANSI codes for length calculation\nfn strip_ansi(s: &str) -> String {\n    let re = regex::Regex::new(r\"\\x1b\\[[0-9;]*m\").unwrap();\n    re.replace_all(s, \"\").to_string()\n}\n\n## Acceptance Criteria\n- [ ] Tests verify key text content present\n- [ ] Tests verify visual symbols (✓, ✗, ●, ○, ⚠, ℹ)\n- [ ] Tests verify panel structure (box characters)\n- [ ] Tests verify ANSI codes present in human mode\n- [ ] Empty/error states tested\n- [ ] Watch command streaming tested\n- [ ] Width adaptation tested (narrow and wide)\n- [ ] All tests include tracing instrumentation\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T21:10:59.401997030Z","created_by":"ubuntu","updated_at":"2026-01-19T21:38:23.402298261Z","compaction_level":0,"original_size":0,"labels":["human-mode","phase-4","rich-rust","testing","visual"],"dependencies":[{"issue_id":"bd-usa2","depends_on_id":"bd-1bgd","type":"blocks","created_at":"2026-01-19T21:38:23.402255581Z","created_by":"ubuntu"},{"issue_id":"bd-usa2","depends_on_id":"bd-1gx6","type":"blocks","created_at":"2026-01-19T21:22:55.246853073Z","created_by":"ubuntu"},{"issue_id":"bd-usa2","depends_on_id":"bd-248","type":"blocks","created_at":"2026-01-19T21:10:59.453317987Z","created_by":"ubuntu"},{"issue_id":"bd-usa2","depends_on_id":"bd-36gs","type":"parent-child","created_at":"2026-01-19T21:10:59.447902151Z","created_by":"ubuntu"}]}
{"id":"bd-vc3","title":"EPIC: Rate Limiting and Burst Protection","description":"## Overview\n**Rank: #13 of 15** | **Impact: Low** | **Effort: Low** | **Confidence: High**\n\nPrevent USB communication floods with configurable rate limiting to protect device stability.\n\n## Problem Statement\nRapid-fire commands from scripts or AI agents can:\n- Overwhelm the USB communication channel\n- Cause device firmware to misbehave\n- Lead to dropped commands or corrupted state\n- Create unpredictable timing issues\n\nWhile the current single-command CLI naturally rate-limits (each command is a separate process), future features like daemon mode, batch operations, or scripted sequences could hit these limits.\n\n## Solution\nConfigurable rate limiting with sensible defaults:\n```bash\n# Explicit rate limiting\nsd set-keys ~/layout/ --rate-limit 50ms\n\n# Global rate limit for all operations\nsd --rate-limit 100ms brightness 50\n\n# Burst mode with queue\nsd batch --queue-size 100 --rate-limit 20ms < commands.txt\n```\n\nInternal rate limiter for programmatic use:\n```rust\nlet limiter = RateLimiter::new(Duration::from_millis(50));\n\nfor key in 0..32 {\n    limiter.wait(); // Blocks until rate limit allows\n    device.set_key_image(key, &images[key])?;\n}\n```\n\n## Why This Is #13 Priority\n1. **Defensive programming**: Prevents edge case failures\n2. **Low effort**: Token bucket is ~50 lines\n3. **Future-proofing**: Needed for daemon/server mode\n4. **Low immediate impact**: Current CLI is naturally limited\n5. **Invisible when working**: Users dont notice rate limiting\n\n## Implementation Approach\n\n### Token Bucket Rate Limiter\n```rust\n// In src/rate_limit.rs (new file)\nuse std::time::{Duration, Instant};\n\npub struct RateLimiter {\n    min_interval: Duration,\n    last_action: Option<Instant>,\n}\n\nimpl RateLimiter {\n    pub fn new(min_interval: Duration) -> Self {\n        Self {\n            min_interval,\n            last_action: None,\n        }\n    }\n    \n    /// Block until rate limit allows next action\n    pub fn wait(&mut self) {\n        if let Some(last) = self.last_action {\n            let elapsed = last.elapsed();\n            if elapsed < self.min_interval {\n                std::thread::sleep(self.min_interval - elapsed);\n            }\n        }\n        self.last_action = Some(Instant::now());\n    }\n    \n    /// Check if action is allowed without blocking\n    pub fn check(&self) -> bool {\n        self.last_action\n            .map(|last| last.elapsed() >= self.min_interval)\n            .unwrap_or(true)\n    }\n    \n    /// Try to acquire permission, return false if rate limited\n    pub fn try_acquire(&mut self) -> bool {\n        if self.check() {\n            self.last_action = Some(Instant::now());\n            true\n        } else {\n            false\n        }\n    }\n}\n\n// Advanced: Token bucket with burst capacity\npub struct TokenBucket {\n    capacity: usize,\n    tokens: f64,\n    refill_rate: f64,  // tokens per second\n    last_refill: Instant,\n}\n\nimpl TokenBucket {\n    pub fn new(capacity: usize, rate_per_second: f64) -> Self {\n        Self {\n            capacity,\n            tokens: capacity as f64,\n            refill_rate: rate_per_second,\n            last_refill: Instant::now(),\n        }\n    }\n    \n    pub fn try_acquire(&mut self, count: usize) -> bool {\n        self.refill();\n        if self.tokens >= count as f64 {\n            self.tokens -= count as f64;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn refill(&mut self) {\n        let now = Instant::now();\n        let elapsed = now.duration_since(self.last_refill).as_secs_f64();\n        self.tokens = (self.tokens + elapsed * self.refill_rate).min(self.capacity as f64);\n        self.last_refill = now;\n    }\n}\n```\n\n### Integration Points\n```rust\n// In device operations\nimpl Device {\n    pub fn set_key_image_rate_limited(\n        &self,\n        key: u8,\n        image: &[u8],\n        limiter: &mut RateLimiter,\n    ) -> Result<()> {\n        limiter.wait();\n        self.set_key_image(key, image)\n    }\n}\n\n// In batch operations\nfn cmd_set_keys(device: &Device, dir: &Path, rate_limit_ms: Option<u64>) -> Result<()> {\n    let mut limiter = rate_limit_ms\n        .map(|ms| RateLimiter::new(Duration::from_millis(ms)));\n    \n    for (key, path) in keys_to_set {\n        if let Some(ref mut l) = limiter {\n            l.wait();\n        }\n        set_key_image(device, key, &path)?;\n    }\n    Ok(())\n}\n```\n\n## Key Design Decisions\n1. **Optional by default**: Dont rate limit unless requested or in batch mode\n2. **Simple interval limiter**: Default implementation, easy to understand\n3. **Token bucket for burst**: Advanced option for daemon/server mode\n4. **Per-operation granularity**: Rate limit individual USB operations\n5. **Configurable via CLI**: --rate-limit flag on relevant commands\n\n## Success Criteria\n- [ ] RateLimiter struct implemented with wait/check/try_acquire\n- [ ] TokenBucket implemented for burst scenarios\n- [ ] --rate-limit flag available on batch commands\n- [ ] Batch operations use rate limiting by default\n- [ ] Rate limiting is invisible when not needed\n- [ ] Robot mode reports when rate limited\n\n## Files to Create/Modify\n- `src/rate_limit.rs`: New rate limiting module\n- `src/cli/mod.rs`: Add --rate-limit flag to relevant commands\n- `src/main.rs`: Integrate rate limiter into batch operations\n\n## Dependencies\n- Useful for BATCH-OPS (#1) and future daemon mode\n\n## Estimated Subtasks\n1. Implement simple RateLimiter struct\n2. Implement TokenBucket for burst scenarios\n3. Add --rate-limit CLI flag\n4. Integrate into batch set-keys command\n5. Add robot mode rate limit reporting\n6. Write tests","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-19T18:21:38.963557809Z","created_by":"ubuntu","updated_at":"2026-01-19T18:21:38.996177816Z","compaction_level":0,"original_size":0,"labels":["defensive","priority-13","reliability","usb"]}
{"id":"bd-vh6","title":"Write integration tests for web API","description":"## Test Coverage for Web API\n\n### Endpoint Tests (Unit/Integration)\n\n1. **Device Info Endpoint (GET /api/device)**\n   - Returns device model (XL, MK2, Mini)\n   - Returns firmware version\n   - Returns serial number\n   - Returns key count and grid dimensions\n   - Returns 200 OK for connected device\n   - Returns 503 Service Unavailable when device disconnected\n   - Robot mode: Returns JSON matching schema\n\n2. **Health Check Endpoint (GET /api/health)**\n   - Returns 200 OK when server running\n   - Includes version in response\n   - Includes device connection status\n   - Response time < 50ms\n\n3. **Brightness Endpoints**\n   - GET /api/brightness returns current level (0-100)\n   - PUT /api/brightness with valid level (50) succeeds\n   - PUT /api/brightness with 0 succeeds (minimum)\n   - PUT /api/brightness with 100 succeeds (maximum)\n   - PUT /api/brightness with -1 returns 400 Bad Request\n   - PUT /api/brightness with 101 returns 400 Bad Request\n   - PUT /api/brightness with non-numeric returns 400\n\n4. **Key Image Endpoints**\n   - PUT /api/keys/:id with valid PNG succeeds\n   - PUT /api/keys/:id with valid JPG succeeds\n   - PUT /api/keys/:id with valid WebP succeeds\n   - PUT /api/keys/:id validates key index range\n   - PUT /api/keys/:id with invalid key returns 400\n   - PUT /api/keys/:id with corrupted image returns 400\n   - Content-Type must be image/* or multipart/form-data\n   - Large images (4K) are auto-resized\n\n5. **Key Color Endpoints**\n   - PUT /api/keys/:id/color with hex (#FF5500) succeeds\n   - PUT /api/keys/:id/color with named color (red) succeeds\n   - PUT /api/keys/:id/color with rgb(255,85,0) succeeds\n   - PUT /api/keys/:id/color with invalid color returns 400\n\n6. **Clear Key Endpoints**\n   - DELETE /api/keys/:id clears specific key\n   - DELETE /api/keys/:id returns 204 No Content\n   - DELETE /api/keys/:id with invalid key returns 400\n\n7. **Keys Listing Endpoint (GET /api/keys)**\n   - Returns array of key states\n   - Each key has index, type (image/color/empty)\n   - Includes last-modified timestamp\n\n### WebSocket Tests (if WebSocket endpoint exists)\n\n8. **WebSocket Connection**\n   - Client can connect to /ws/events\n   - Connection survives across operations\n   - Proper close handshake\n\n9. **Event Streaming**\n   - Key press events delivered\n   - Key release events delivered\n   - Events include key index and timestamp\n   - No events lost during rapid presses\n\n### Error Handling Tests\n\n10. **CORS Headers**\n    - OPTIONS requests return proper CORS headers\n    - Allow-Origin set correctly for local development\n    - Credentials handled appropriately\n\n11. **Error Response Format**\n    - All errors return JSON body\n    - Error includes code, message, suggestion\n    - 400 errors include validation details\n    - 500 errors don't leak internal info\n\n### Performance Tests\n\n12. **Concurrent Requests**\n    - 10 concurrent brightness sets don't corrupt\n    - Image uploads don't block other requests\n    - Server remains responsive under load\n\n13. **Resource Limits**\n    - Max upload size enforced\n    - Request timeout enforced\n    - Connection limits enforced\n\n### Integration with MockDevice\n\n14. **MockDevice Assertions**\n    - Verify set_key_image called with correct data\n    - Verify set_brightness called with correct value\n    - Verify clear_key called for correct key\n    - Track operation order\n\n### Logging Requirements\n- TRACE: Request/response bodies (summarized for large)\n- DEBUG: Request routing, handler entry/exit\n- INFO: Server start/stop, client connections\n- WARN: Invalid requests, rate limiting\n- ERROR: Handler panics, device errors\n\n### Test Data\n- Use test fixtures from bd-2ky\n- Include small, medium, large test images\n- Include valid and intentionally corrupted images","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:51.964820103Z","created_by":"ubuntu","updated_at":"2026-01-19T21:38:24.575793166Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-vh6","depends_on_id":"bd-1xy","type":"blocks","created_at":"2026-01-19T21:03:08.145081713Z","created_by":"ubuntu"},{"issue_id":"bd-vh6","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:51.981074787Z","created_by":"ubuntu"},{"issue_id":"bd-vh6","depends_on_id":"bd-2ky","type":"blocks","created_at":"2026-01-19T21:38:24.575743182Z","created_by":"ubuntu"},{"issue_id":"bd-vh6","depends_on_id":"bd-bxu","type":"blocks","created_at":"2026-01-19T18:39:04.558546814Z","created_by":"ubuntu"}]}
{"id":"bd-xjo","title":"Implement brightness endpoint","description":"GET /api/brightness → { \"level\": 80 }\nPUT /api/brightness { \"level\": 50 } → { \"success\": true }\n\nThread-safe device access via Mutex.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:43.725990551Z","created_by":"ubuntu","updated_at":"2026-01-19T18:28:43.742484065Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-xjo","depends_on_id":"bd-271","type":"parent-child","created_at":"2026-01-19T18:28:43.742385780Z","created_by":"ubuntu"}]}
{"id":"bd-ylj","title":"EPIC: Connection Health Monitoring with Auto-Reconnect","description":"## Overview\n**Rank: #3 of 15** | **Impact: High** | **Effort: Medium** | **Confidence: High**\n\nDetect USB disconnection/reconnection and handle it gracefully. Add `--retry` flag for commands and robust reconnection in `sd watch` for long-running usage.\n\n## Problem Statement\nStream Decks can disconnect unexpectedly due to:\n- USB power issues (especially on hubs)\n- System sleep/wake cycles\n- USB hub resets\n- Physical cable issues\n- Driver glitches\n\nCurrently, the CLI just fails with a USB error. Users must manually re-run commands. This is especially problematic for:\n- `sd watch` which is designed for long-running event streaming\n- AI agents that expect reliable operation without crash-restart loops\n- Automated scripts that run unattended\n\n## Solution\nIntelligent connection management with configurable retry behavior:\n```bash\n# Retry on connection failure\nsd brightness 50 --retry 3 --retry-delay 1000\n\n# Watch mode with auto-reconnect\nsd watch --reconnect --reconnect-delay 2000\n\n# Monitor connection health\nsd monitor --health-check-interval 5000\n```\n\n## Why This Is #3 Priority\n1. **Real pain point**: USB flakiness is common, especially with hubs\n2. **Essential for `sd watch`**: Long-running monitoring needs resilience\n3. **Robot-mode critical**: Agents need robust operation, not crash loops\n4. **Invisible quality**: Users dont notice it working, but definitely notice failures\n\n## Implementation Approach\n\n### Phase 1: Retry Logic for Single Commands\n```rust\n// In src/device.rs\npub struct ConnectionOptions {\n    pub max_retries: u32,\n    pub retry_delay: Duration,\n    pub backoff_factor: f32,  // Exponential backoff\n}\n\nimpl Device {\n    pub fn open_with_retry(\n        serial: Option<&str>, \n        opts: &ConnectionOptions\n    ) -> Result<Self> {\n        let mut delay = opts.retry_delay;\n        \n        for attempt in 1..=opts.max_retries {\n            match Self::open(serial) {\n                Ok(dev) => return Ok(dev),\n                Err(e) if e.is_connection_error() && attempt < opts.max_retries => {\n                    eprintln!(\"Connection failed, retrying in {:?}...\", delay);\n                    std::thread::sleep(delay);\n                    delay = Duration::from_secs_f32(\n                        delay.as_secs_f32() * opts.backoff_factor\n                    );\n                }\n                Err(e) => return Err(e),\n            }\n        }\n        unreachable!()\n    }\n}\n```\n\n### Phase 2: Auto-Reconnect for Watch Mode\n```rust\n// In main.rs, watch command\nfn cmd_watch(opts: WatchOptions) -> Result<()> {\n    let mut device = Device::open_with_retry(opts.serial, &opts.connection)?;\n    \n    loop {\n        match device.read_input(opts.timeout) {\n            Ok(Some(event)) => emit_event(&event, opts.robot),\n            Ok(None) => continue,  // Timeout, no event\n            Err(e) if e.is_connection_error() && opts.reconnect => {\n                emit_disconnected(opts.robot);\n                device = reconnect_with_backoff(&opts)?;\n                emit_reconnected(opts.robot);\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n\nfn reconnect_with_backoff(opts: &WatchOptions) -> Result<Device> {\n    let mut delay = opts.reconnect_delay;\n    loop {\n        std::thread::sleep(delay);\n        match Device::open(opts.serial) {\n            Ok(dev) => return Ok(dev),\n            Err(_) => {\n                delay = std::cmp::min(\n                    delay * 2,\n                    Duration::from_secs(30)  // Max backoff\n                );\n            }\n        }\n    }\n}\n```\n\n### Phase 3: Connection Health Events\n```json\n// Robot mode output for connection events\n{\"event\": \"disconnected\", \"timestamp\": \"...\", \"reason\": \"usb_error\"}\n{\"event\": \"reconnecting\", \"attempt\": 1, \"delay_ms\": 2000}\n{\"event\": \"reconnected\", \"timestamp\": \"...\", \"downtime_ms\": 4500}\n```\n\n## Key Design Decisions\n1. **Exponential backoff**: Prevents USB flood during recovery\n2. **Maximum backoff cap**: 30 seconds max to balance responsiveness\n3. **Explicit opt-in**: `--retry` and `--reconnect` flags, not default behavior\n4. **Event emission**: Connection state changes are reported in robot mode\n5. **Graceful degradation**: Single commands fail fast by default, long-running commands are resilient\n\n## Error Classification\nNeed to distinguish connection errors from other errors:\n```rust\nimpl SdError {\n    pub fn is_connection_error(&self) -> bool {\n        matches!(self, \n            SdError::DeviceNotFound |\n            SdError::UsbError(_) |\n            SdError::DeviceDisconnected\n        )\n    }\n}\n```\n\n## Success Criteria\n- [ ] `--retry N` flag retries failed connections N times\n- [ ] `--retry-delay MS` controls initial retry delay\n- [ ] `sd watch --reconnect` automatically reconnects on disconnect\n- [ ] Connection events emitted in robot mode JSON\n- [ ] Exponential backoff prevents USB flooding\n- [ ] Maximum backoff prevents infinite slow retries\n- [ ] Works correctly across sleep/wake cycles\n\n## Files to Modify\n- `src/cli/mod.rs`: Add retry/reconnect flags to relevant commands\n- `src/device.rs`: Add open_with_retry and connection options\n- `src/error.rs`: Add is_connection_error classification\n- `src/main.rs`: Update command handlers to use retry logic\n\n## Dependencies\nNone - enhances existing functionality\n\n## Estimated Subtasks\n1. Add error classification (is_connection_error)\n2. Implement open_with_retry in device.rs\n3. Add --retry and --retry-delay CLI flags\n4. Update single commands to use retry logic\n5. Implement auto-reconnect for watch command\n6. Add connection event emission for robot mode\n7. Implement exponential backoff with cap\n8. Test across sleep/wake cycles\n9. Write integration tests","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-19T18:10:27.991892800Z","created_by":"ubuntu","updated_at":"2026-01-21T11:27:10.657786731Z","closed_at":"2026-01-21T11:27:10.657719284Z","close_reason":"All major success criteria met: --retry/--retry-delay flags implemented for single commands, --reconnect/--reconnect-delay/--max-reconnect-attempts for watch command, connection event emission in robot mode, exponential backoff (1.5x) with 30s cap. Only remaining is bd-34h (P2) for manual sleep/wake testing.","compaction_level":0,"original_size":0,"labels":["agent-friendly","priority-3","reliability","usb"]}
{"id":"bd-ym1","title":"Implement diff command","description":"Implement sd diff <config.yaml>:\n- Load current state (from session or device)\n- Load config file\n- Compare and show differences\n- Format: \"Key 0: (empty) → ~/icons/chrome.png\"\n\nNote: Requires state tracking from SAVE-RESTORE epic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:58.847465402Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:58.864068762Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-ym1","depends_on_id":"bd-1r4","type":"parent-child","created_at":"2026-01-19T18:25:58.863954908Z","created_by":"ubuntu"}]}
{"id":"bd-zcq","title":"Add --rate-limit CLI flag","description":"## Purpose\nAdd --rate-limit CLI flag to control operation frequency for batch commands.\n\n## Implementation\n\\`\\`\\`rust\n// In src/cli.rs - add to SetKeysCommand, ClearKeysCommand, FillKeysCommand\n#[derive(Parser, Debug)]\npub struct SetKeysCommand {\n    // ... existing fields\n    \n    /// Minimum interval between operations in milliseconds\n    /// Prevents USB flooding on rapid operations\n    #[arg(long, value_name = \"MS\", default_value = \"0\")]\n    pub rate_limit: u64,\n    \n    /// Use burst mode with specified capacity\n    /// Allows burst of operations up to capacity, then rate-limits\n    #[arg(long, value_name = \"COUNT\", requires = \"rate_limit\")]\n    pub burst: Option<usize>,\n}\n\n#[derive(Parser, Debug)]\npub struct ClearKeysCommand {\n    // ... existing fields\n    \n    #[arg(long, value_name = \"MS\", default_value = \"0\")]\n    pub rate_limit: u64,\n}\n\n#[derive(Parser, Debug)]\npub struct FillKeysCommand {\n    // ... existing fields\n    \n    #[arg(long, value_name = \"MS\", default_value = \"0\")]\n    pub rate_limit: u64,\n}\n\\`\\`\\`\n\n### Help Text\n\\`\\`\\`\nsd set-keys --help\n\nOPTIONS:\n    --rate-limit <MS>    Minimum interval between operations in milliseconds [default: 0]\n                         Use to prevent USB flooding with many keys. Recommended: 20-50ms.\n    --burst <COUNT>      Allow burst of COUNT operations before rate limiting [requires --rate-limit]\n\\`\\`\\`\n\n### Command Integration\n\\`\\`\\`rust\n// In batch operation handler\nfn create_rate_limiter(rate_limit_ms: u64, burst: Option<usize>) -> Option<Box<dyn RateLimiting>> {\n    if rate_limit_ms == 0 {\n        return None;\n    }\n    \n    let interval = Duration::from_millis(rate_limit_ms);\n    \n    match burst {\n        Some(capacity) => Some(Box::new(TokenBucket::new(capacity, 1000.0 / rate_limit_ms as f64))),\n        None => Some(Box::new(RateLimiter::new(interval))),\n    }\n}\n\nasync fn execute_batch_operation(\n    device: &mut Device,\n    operations: Vec<KeyOperation>,\n    rate_limiter: Option<&mut dyn RateLimiting>,\n    progress: &ProgressReporter,\n) -> Result<BatchResult> {\n    let mut results = Vec::new();\n    \n    for (i, op) in operations.iter().enumerate() {\n        // Apply rate limiting\n        if let Some(limiter) = rate_limiter.as_mut() {\n            limiter.wait().await;\n        }\n        \n        // Execute operation\n        let result = execute_single_operation(device, op).await;\n        results.push(result);\n        \n        progress.update(i + 1, operations.len());\n    }\n    \n    Ok(BatchResult { operations: results })\n}\n\\`\\`\\`\n\n### Robot Mode Output\n\\`\\`\\`json\n{\n  \"command\": \"set-keys\",\n  \"rate_limit\": {\n    \"enabled\": true,\n    \"interval_ms\": 50,\n    \"burst_capacity\": null\n  },\n  \"operations\": [\n    {\"key\": 0, \"status\": \"success\", \"rate_limited\": false},\n    {\"key\": 1, \"status\": \"success\", \"rate_limited\": true, \"waited_ms\": 48}\n  ]\n}\n\\`\\`\\`\n\n## Success Criteria\n- [ ] --rate-limit flag added to set-keys, clear-keys, fill-keys\n- [ ] --burst flag works in combination with --rate-limit\n- [ ] Default value of 0 means no rate limiting\n- [ ] Help text clearly explains the flag\n- [ ] Robot mode includes rate limit status\n\n## Logging Requirements\n- TRACE: (none)\n- DEBUG: Rate limiter created with interval\n- INFO: (none)\n- WARN: Very low rate limit values (< 10ms)\n- ERROR: (none)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-19T18:28:19.669438641Z","created_by":"ubuntu","updated_at":"2026-01-19T21:28:26.496291653Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zcq","depends_on_id":"bd-vc3","type":"parent-child","created_at":"2026-01-19T18:28:19.683856817Z","created_by":"ubuntu"}]}
{"id":"bd-zg7","title":"Add notify dependency for file watching","description":"Add to Cargo.toml:\n```toml\n[dependencies]\nnotify = \"6\"\n```\n\nThis is the standard Rust crate for cross-platform file system notifications.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:27:33.503911483Z","created_by":"ubuntu","updated_at":"2026-01-19T18:27:33.533933589Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-zg7","depends_on_id":"bd-1zf","type":"parent-child","created_at":"2026-01-19T18:27:33.533892311Z","created_by":"ubuntu"}]}
{"id":"bd-znw","title":"Add installation instructions to help text","description":"Update completions command help to include installation instructions:\n- Bash: ~/.local/share/bash-completion/completions/sd\n- Zsh: ~/.zfunc/_sd (ensure fpath includes this)\n- Fish: ~/.config/fish/completions/sd.fish\n- PowerShell: >> $PROFILE","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-19T18:25:00.289760717Z","created_by":"ubuntu","updated_at":"2026-01-19T18:25:00.299742470Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-znw","depends_on_id":"bd-3pu","type":"parent-child","created_at":"2026-01-19T18:25:00.299695742Z","created_by":"ubuntu"}]}
